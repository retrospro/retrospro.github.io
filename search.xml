<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Goland远程调试</title>
    <url>/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="1-Goland单步调试"><a href="#1-Goland单步调试" class="headerlink" title="1. Goland单步调试"></a>1. Goland单步调试</h1><h2 id="1-1-Goland侧配置"><a href="#1-1-Goland侧配置" class="headerlink" title="1.1 Goland侧配置"></a>1.1 Goland侧配置</h2><ol>
<li><p>配置代码同步</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225107371.png" alt="image-20240823225107371"></p>
</li>
<li><p>添加Go Remote</p>
<span id="more"></span>

<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225246673.png" alt="image-20240823225246673"></p>
</li>
</ol>
<h2 id="1-2-Linux-侧配置"><a href="#1-2-Linux-侧配置" class="headerlink" title="1.2 Linux 侧配置"></a>1.2 Linux 侧配置</h2><ol>
<li><p>安装go</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225501448.png" alt="image-20240823225501448"></p>
</li>
<li><p>配置环境变量</p>
</li>
</ol>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225711804.png" alt="image-20240823225711804"></p>
<ol start="3">
<li><p>安装dlv</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225759957.png" alt="image-20240823225759957"></p>
</li>
<li><p>编译用于调试的go二进制</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225923905.png" alt="image-20240823225923905"></p>
</li>
<li><p>打开2345端口的防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=2345/tcp</span><br></pre></td></tr></table></figure>
</li>
<li><p>停服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop xxx.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端开启dlv调试</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823230501230.png" alt="image-20240823230501230"></p>
</li>
</ol>
<h2 id="1-3-踩坑记录"><a href="#1-3-踩坑记录" class="headerlink" title="1.3 踩坑记录"></a>1.3 踩坑记录</h2><p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823230835485.png" alt="image-20240823230835485"></p>
<h1 id="2-Goland远程执行单元测试"><a href="#2-Goland远程执行单元测试" class="headerlink" title="2. Goland远程执行单元测试"></a>2. Goland远程执行单元测试</h1><ol>
<li><p>全量执行</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823231615455.png" alt="image-20240823231615455"></p>
</li>
<li><p>单个测试文件执行</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823231956910.png" alt="image-20240823231956910"></p>
</li>
</ol>
<p><strong>注意：如果本地单测文件有改动，记得将改动同步上传至远程服务器</strong></p>
]]></content>
      <categories>
        <category>golang</category>
        <category>golang调试</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>golang调试</tag>
      </tags>
  </entry>
  <entry>
    <title>golang切片</title>
    <url>/2024/08/24/golang%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h1 id="1-make切片时，是否指定size有什么区别？"><a href="#1-make切片时，是否指定size有什么区别？" class="headerlink" title="1. make切片时，是否指定size有什么区别？"></a>1. make切片时，是否指定size有什么区别？</h1><p><strong>切片是否指定size有什么区别呢？</strong><br><strong>例如：</strong><br><strong>slice :&#x3D; make([]int)</strong><br><strong>slice :&#x3D; make([]int, 5)</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建切片时，是否指定 <code>size</code>（即长度）会影响切片的初始状态。下面解释两种情况下的区别：</p>
<h3 id="1-不指定长度"><a href="#1-不指定长度" class="headerlink" title="1. 不指定长度"></a>1. 不指定长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：如果你这样创建切片，由于没有指定长度和容量，Go 将会报错，因为 <code>make([]int)</code> 语法是无效的。</li>
<li><strong>原因</strong>：<code>make</code> 函数在用于创建切片时至少需要一个参数（长度），你必须指定切片的初始长度。</li>
</ul>
<p>因此，你需要至少指定长度，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 0 的切片，其容量也为 0。这是一个空的切片，但仍然可以追加元素。</p>
<h3 id="2-指定长度"><a href="#2-指定长度" class="headerlink" title="2. 指定长度"></a>2. 指定长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：这段代码创建了一个长度为 5 的切片，其容量也为 5。切片中的 5 个元素会被初始化为类型 <code>int</code> 的零值（即 0）。切片的底层数组会包含 5 个元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(slice) <span class="comment">// 输出: [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 输出: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><p><strong>未指定长度（非法操作）</strong>：如果你不指定长度并直接调用 <code>make([]int)</code>，Go 编译器会报错，因为这种用法是不合法的。你至少需要指定长度。</p>
</li>
<li><p><strong>指定长度</strong>：当你指定长度时，切片会被创建并初始化为指定长度的切片。它的容量和长度都等于你指定的长度。如果你在创建切片时指定的长度为 5，那么切片将包含 5 个元素，所有元素的初始值为 0。</p>
</li>
<li><p><strong>创建空切片</strong>：如果你需要一个空切片（长度为 0），你可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这个切片的长度和容量都为 0，可以使用 <code>append</code> 函数向其中添加元素，容量会根据需要自动扩展。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在创建切片时，必须至少指定长度。指定长度的切片会分配一个具有该长度的底层数组，未指定长度（即长度为 0）时，你得到的是一个空切片。</p>
<h1 id="2-make切片时，是否指定容量有什么区别？"><a href="#2-make切片时，是否指定容量有什么区别？" class="headerlink" title="2. make切片时，是否指定容量有什么区别？"></a>2. make切片时，是否指定容量有什么区别？</h1><ul>
<li><p><strong>未指定容量</strong>：当你使用 <code>make([]T, len)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 的切片，并且容量（capacity）等于长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度和容量均为 5 的切片。切片的所有元素都会被初始化为类型 <code>T</code> 的零值（比如对于 <code>int</code> 类型，零值是 0）。</p>
</li>
<li><p><strong>指定容量</strong>：当你使用 <code>make([]T, len, cap)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 且容量为 <code>cap</code> 的切片。容量可以比长度大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 5、容量为 10 的切片。这意味着虽然切片的当前长度是 5，但它最多可以扩展到 10 个元素而无需重新分配内存。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会将容量设置为与长度相同。</li>
<li>如果指定了容量，Go 会为切片预留更多的空间。这在切片需要频繁追加元素的场景下非常有用，因为预先指定较大的容量可以减少在追加元素时的内存重新分配操作，提高性能。</li>
</ul>
<h2 id="3-slice避坑指南"><a href="#3-slice避坑指南" class="headerlink" title="3. slice避坑指南"></a>3. slice避坑指南</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1EL4y1P7hh?p=5&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发编程--基础篇</title>
    <url>/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824160554038.png" alt="image-20240824160554038"></p>
<p>有缓冲channel和无缓冲channel</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824161109182.png" alt="image-20240824161109182"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825222826148.png" alt="image-20240825222826148"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223113423.png" alt="image-20240825223113423"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223516012.png" alt="image-20240825223516012"></p>
<p>1、并行与并发</p>
<ol>
<li>并行<br>要求CPU具备多核计算的能力<br>在同一时刻需要多个线程在多个CPU上同时执行指令，无论宏观上还是微观上都会看到多个线程在同时运行</li>
<li>并发<br>并不要求CPU具备多核计算的能力<br>单核CPU都是独立的，CPU与CPU之间不需要交互</li>
</ol>
<p>2、CSP并发模型</p>
<ol>
<li>Communicating Sequential Process: 通信顺序进程模型</li>
<li>Go语言中有两种并发模型:<br>1、线程与锁的并发模型<br>2、CSP通信顺序进程模型</li>
</ol>
<p>3、根据资源访问权限的不同，内存分为:</p>
<ol>
<li>内核空间<br>可以直接调用计算机底层资源，比如: I&#x2F;O资源</li>
<li>用户空间<br>没有权限调用底层资源，需要通过系统调用等方式切换为内核态从而调用底层资源</li>
</ol>
<p>4、线程是操作系统能调度的最小单位</p>
<ol>
<li>用户线程<ol>
<li>用户空间的代码创建、管理、销毁</li>
<li>同一进程下创建的多个线程对CPU的争夺是进程为单位的，</li>
<li>这只能够对其用户进程被分配的CPU时间，无论很好的利用多线程计算</li>
<li>我们一般情况下说的线程其实是指用户线程</li>
<li>用户线程无法被系统感知，用户线程所属的进程或者内核线程才能被系统直接调用</li>
</ol>
</li>
<li>内核线程<ol>
<li>由操作系统创建、管理、调度</li>
<li>能够直接获取系统底层资源</li>
<li>线程切换时的CPU需要切换到内核态</li>
<li>能够很好的利用多核CPU进行计算的优势</li>
<li>开发人员可以通过系统调用的方式使用内核线程</li>
</ol>
</li>
</ol>
<p>5、线程模型</p>
<ol>
<li><p>用户级线程模型  </p>
<ol>
<li>一个进程对应一个内核线程  </li>
<li>进程内的多线程由用户代码完成，这使得线程的创建、管理，同时等工作量得异常显著级和高效  </li>
<li>进程内的多线程无法很好利用CPU多核运算的优势，只能通过分时复用的方式轮换执行  </li>
<li>如果进程内有线程阻塞，很可能会导致整个进程范围内的阻塞</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223737636.png" alt="image-20240825223737636"></p>
</li>
<li><p>内核级线程模型</p>
<ol>
<li><p>进程中的每个线程都会对应一个内核线程  </p>
</li>
<li><p>进程内部创建一个线程程序会调用操作系统的线程库，在内核创建一个新的内核线程与之对应  </p>
</li>
<li><p>线程的管理和调度由内核系统负责  </p>
<p>这会导致每个线程切换上下文的代价较大，产生不小的资源消耗  </p>
<p>同时创建线程的数量需要限制在系统可创建的线程的数量  </p>
</li>
<li><p>优点是多线程可以充分利用CPU的多核并行计算能力  </p>
</li>
<li><p>进程内某个线程挂起并不会影响到其他线程的工作执行</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825232418190.png" alt="image-20240825232418190"></p>
</li>
</ol>
</li>
<li><p>两级线程模型</p>
<ol>
<li>相当于用户级线程和内核级线程的结合  </li>
<li>一个进程将会对应多个内核级线程，由进程内的调度器来决定进程内线程与内核线程的对应  </li>
<li>进程会先申请一定数量的内核级线程，然后将自己创建的线程与之对应  </li>
<li>线程的调度与管理由进程的调度器负责，而内核级线程的调度由操作系统负责  </li>
<li>这种模型能够有效降低线程创建和管理的资源消耗，也能够很好的提供程序并行计算的能力</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825232639991.png" alt="image-20240825232639991"></p>
</li>
<li><p>MPG模型</p>
<ol>
<li><p>go语言的mpg模型是一种特殊的两级线程模型，它将CPU、内核线程、用户线程之间的管理，描述为M、P、G三者的关系  </p>
</li>
<li><p>M：machine，一个对应一个内核级线程，相当于内核级线程在go中的的映射  </p>
</li>
<li><p>P：processor，一个P代表执行go代码所需要的上下文环境  </p>
</li>
<li><p>G：goroutine，是一个代码片段，相当于用户级线程  </p>
</li>
<li><p>go func aaa() { }，这里的aaa相当于一个用户级线程</p>
</li>
</ol>
</li>
<li><p>MPG  </p>
<ol>
<li>每个M都与一个内核级线程绑定，在运行时，一个M同时只能绑定一个P  </li>
<li>P和G的关系可以是一对多的  </li>
<li>在程序运行过程中，M和内核级线程的绑定关系不会发生变化，在M的生命周期内只会与一个内核级线程绑定</li>
<li>M和P P和G之间的关系都是动态可变的  </li>
<li>在实际的运行过程中，M和P的组合才能为G提供有效的运行环境  </li>
<li>多个可执行的G将会顺序排成一个队列挂在某个P上面，等待调度和执行</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233553727.png" alt="image-20240825233553727"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233652269.png" alt="image-20240825233652269"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233710063.png" alt="image-20240825233710063"></p>
</li>
<li><p>并发编程实践</p>
<ol>
<li>goroutine</li>
<li>channel</li>
<li>select</li>
<li>sync包</li>
<li>atomic包</li>
<li>context包</li>
</ol>
</li>
<li><p>goroutine简介<br>协程goroutine在go语言中属于是轻量级的线程<br>在运行时由runtime管理<br>每个go程序至少启动一个goroutine，main函数也在goroutine上运行  </p>
</li>
<li><p>启动goroutine  </p>
<ol>
<li>关键字 go  </li>
<li>模式  <ol>
<li>go 变量  </li>
<li>go 匿名函数</li>
<li>go 函数</li>
</ol>
</li>
</ol>
</li>
<li><p>需要注意的地方  </p>
<ol>
<li>main的goroutine结束后就意味着整个程序的运行已经结束了，换言之，go的执行是非阻塞的，不会等待  </li>
<li>goroutine之间的代码顺序并不能代表其真实的执行顺序  </li>
<li>go后面的函数的返回值会被忽略，也就是说协程不能有返回值，但是可以通过channel实现有返回值的效果</li>
<li>没有父子goroutine的概念，所有的goroutine是平等的被调度和执行的  </li>
<li>go程序在执行时会单独为main创建一个goroutine，遇到其他go关键字再去创建其他的goroutine  </li>
<li>go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine</li>
</ol>
</li>
<li><p>channel<br>go语言当中使用channel作为goroutine之间同步和通信的手段</p>
<p>channel属于引用类型</p>
<p>每个channel只能传递固定类型的数据</p>
<p>声明格式：var channelName chan T  </p>
</li>
<li><p>channel的发送与接收</p>
<p>channel作为一个队列，会保证数据收发顺序总是遵循先入先出的原则进行<br>也会保证同一时刻只有一个goroutine访问channel来发送和获取数据<br>channel发送数据格式：channel &lt;- value<br>接收channel数据格式：value :&#x3D; &lt;- channel    value, ok :&#x3D; &lt;- channel<br>创建channel格式：ch :&#x3D; make(chan T, sizeOfChannel)  ch :&#x3D; make(chan string, 10)</p>
</li>
</ol>
<p>注意：</p>
<p>在业务代码中应使用 value, ok :&#x3D; &lt;- channel，而避免使用 value :&#x3D; &lt;- channel</p>
<p>在下面的情形中，将导致刷屏现象！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		val := &lt;-ch</span><br><span class="line">		fmt.Println(<span class="string">&quot;value is&quot;</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		ch &lt;- time.Now().Format(GOTIME)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例如下：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		val, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;value is&quot;</span>, val, <span class="string">&quot;, ok is&quot;</span>, ok)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;value is&quot;</span>, val, <span class="string">&quot;, ok is&quot;</span>, ok)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i am test1, new close chan.&quot;</span>)</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		ch &lt;- time.Now().Format(GOTIME)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>by the way， channel一般是写入方进行关闭，而不是读取方进行关闭</strong></p>
<ol>
<li><p>案例<br>无缓冲区channel – 阻塞</p>
<p>ch :&#x3D; make(chan string)</p>
<p>有缓冲区channel – 不阻塞</p>
<p>ch :&#x3D; make(chan string, 5)</p>
</li>
<li><p>select  </p>
<ol>
<li>需要接收多个goroutine中的消息时可以使用select  </li>
<li>当多个case同时到达，select将会执行一个随机算法随机选择一个case  </li>
<li>select与switch的区别：  <ol>
<li>select的每个case必须是一个操作  </li>
<li>select后边不带判断条件  </li>
<li>select中如果多个case同时到达，那么select将会执行一个随机算法，随机选择一个case执行</li>
</ol>
</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240826012532525.png" alt="image-20240826012532525"></p>
</li>
</ol>
<h1 id="1-sync包"><a href="#1-sync包" class="headerlink" title="1. sync包"></a>1. sync包</h1><h2 id="1-1-Mutex-互斥锁"><a href="#1-1-Mutex-互斥锁" class="headerlink" title="1.1 Mutex 互斥锁"></a>1.1 Mutex 互斥锁</h2><p>确保在同一时间段内有且仅有一个goroutine持有锁<br>这就保证了在某一时间段内有且仅有一个goroutine访问共享资源，其他申请锁的goroutine将会被阻塞直到锁被释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;start func1 at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		lock.Lock()</span><br><span class="line">		fmt.Println(<span class="string">&quot;func1 get lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;func1 release lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;start func2 at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		lock.Lock()</span><br><span class="line">		fmt.Println(<span class="string">&quot;func2 get lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;func2 release lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-2-RWMutex-读写锁"><a href="#1-2-RWMutex-读写锁" class="headerlink" title="1.2 RWMutex 读写锁"></a>1.2 RWMutex 读写锁</h2><ol>
<li>在同一时间段内只能有一个goroutine获取到写锁  </li>
<li>在同一时间段内可以有多个goroutine获取到读锁  </li>
<li>在同一时间段只能存在写锁或读锁（读锁和写锁互斥）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start read lock at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> lock.RUnlock()</span><br><span class="line">			lock.RLock()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start write lock at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">			lock.Lock()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get wlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release wlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240826015036876.png" alt="image-20240826015036876"></p>
<h2 id="1-3-WaitGroup-并发等待组"><a href="#1-3-WaitGroup-并发等待组" class="headerlink" title="1.3 WaitGroup 并发等待组"></a>1.3 WaitGroup 并发等待组</h2><p>使用WaitGroup的goroutine会被预设好数量的goroutine都提交执行结束后，才会继续往下执行代码</p>
<p>在goroutine调用WaitGroup之前需要保证WaitGroup中等待数量大于1</p>
<p>保证WaitGroup.Done()执行的次数与WaitGroup.Add()相同，WaitGroup.Done()过少会导致等待goroutine死锁，WaitGroup.Done()过多导致panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 正确的做法是把 wg.Add(1)，写到for循环中去，这样可以尽可能地保证 Add和Done的数量是一致的</span></span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-4-Map-并发安全字典"><a href="#1-4-Map-并发安全字典" class="headerlink" title="1.4 Map 并发安全字典"></a>1.4 Map 并发安全字典</h2><ul>
<li>go语言中原生的Map并不是并发安全的， 在多个goroutine同时往Map中添加数据时，可能会导致部分添加数据的丢失，甚至程序崩溃。</li>
<li>对键值的类型没有限制，在同一个map中可以存储多种不同的键值对</li>
</ul>
<ol>
<li><p>go语言中原生的Map并不是并发安全的，示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//dict := make(map[int]int)</span></span><br><span class="line">	<span class="keyword">var</span> dict sync.Map</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;thread id is &quot;</span>, i)</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">//dict[i] = i</span></span><br><span class="line">			dict.Store(i, fmt.Sprintf(<span class="string">&quot;%daaa&quot;</span>, i))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	value, ok := dict.Load(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824224252751.png" alt="image-20240824224252751"></p>
</li>
<li><p>sync包中的Map</p>
<p>Map对应的接口中的方法：</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824225149901.png" alt="image-20240824225149901"></p>
<p>常用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (m *Map) Load(key any) (value any, ok bool)</span><br><span class="line">根据k获取value，相当于get</span><br><span class="line"></span><br><span class="line">func (m *Map) Store(key, value any)</span><br><span class="line">存储，相当于set，对键值的类型没有限制，在同一个map中可以存储多种不同的键值对</span><br><span class="line"></span><br><span class="line">func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)</span><br><span class="line">如果key存在则返回对应的value，如果key不存在则设置key-value对</span><br><span class="line"></span><br><span class="line">func (m *Map) Range(f func(key, value any) bool)</span><br><span class="line">无序遍历map</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-5-Once-单例模式"><a href="#1-5-Once-单例模式" class="headerlink" title="1.5 Once 单例模式"></a>1.5 Once 单例模式</h2><h2 id="1-6-Cond-条件变量"><a href="#1-6-Cond-条件变量" class="headerlink" title="1.6 Cond 条件变量"></a>1.6 Cond 条件变量</h2><p><a href="https://geektutu.com/post/hpg-sync-cond.html">https://geektutu.com/post/hpg-sync-cond.html</a></p>
<h2 id="1-7-Pool-临时对象池"><a href="#1-7-Pool-临时对象池" class="headerlink" title="1.7 Pool 临时对象池"></a>1.7 Pool 临时对象池</h2><h1 id="2-atomic包"><a href="#2-atomic包" class="headerlink" title="2. atomic包"></a>2. atomic包</h1><ol>
<li><strong>atomic简介</strong></li>
</ol>
<p>当我们想要对某个变量并发安全的修改,除了使用官方提供的 mutex,还可以使用 sync&#x2F;atomic 包的原子操作,它能够<br>保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>Golang提供的原子操作都是非侵入式的,由标准库sync&#x2F;atmoic包提供,直接由底层CPU硬件支持。<br>也就是在硬件层次去实现的,性能较好,不需要像 mutex 那样记录很多状态。当然,mutex 不止是对变量的并发控制,更多的是<br>对代码块的并发控制,2者侧重点不一样。</p>
<ol start="2">
<li><strong>原子操作</strong></li>
</ol>
<ul>
<li><p>原子操作即是进行过程中不能被中断的操作,针对某个值的原子操作在被进行的过程中,CPU绝不会再去进行其他的针对<br>该值的操作。</p>
</li>
<li><p>具体的原子操作在不同的操作系统中实现是不同的。比如在Intel的CPU架构机器上,主要是使用总线锁的方式<br>实现的。大致的意思就是当一个CPU需要操作一个内存块的时候,向总线发送一个LOCK信号,所有CPU收到这个信号后就不对<br>这个内存块进行操作了。等待操作的CPU执行完操作后,发送UNLOCK信号,才结束。在AMD的CPU架构机器上就是使用MESI<br>一致性协议的方式来保证原子操作。所以我们在看atomic源码的时候,我们看到它针对不同的操作系统有不同汇编语言文件。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>Golang在sync包中已经提供了锁,为什么还需要使用atomic原子操作呢?</strong></p>
<ul>
<li><p>加锁的代价比较高,耗时多,需要上下文切换。</p>
</li>
<li><p>原子操作只针对基本数据类型,不支持结构体、自定义数据类型。</p>
</li>
<li><p>原子操作在用户态可以完成,性能比互斥锁要高。</p>
</li>
<li><p>针对特定需求原子操作步骤简单,无需加锁解锁步骤。</p>
</li>
</ul>
</li>
<li><p><strong>为什么 atomic 比mutex快?</strong></p>
<ul>
<li>原子操作很快,因为它们依赖于 CPU 指令而不是依赖外部锁。使用互斥锁时,每次获得锁时, goroutine 都会短暂暂停<br>或中断,这种阻塞占使用互斥锁所花费时间的很大一部分。原子操作可以在没有任何中断的情况下执行。</li>
<li>原子操作是能够保证执行期间是连续且不会被中断的,临界区只能保证访问共享数据是按顺序访问的,但并不能保证访问期间<br>不会被切换上下文。</li>
</ul>
</li>
<li><p>CAS<br>CAS是cpu硬件同步原语,是Compare And Swap的缩写</p>
<p>go中的Cas操作,是借用了CPU提供的原子性指令来实现。</p>
<p>CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查。本质还是不断的占用CPU资源换取加锁带来的开销(比如上下文切换开销)。</p>
<p>原子操作中的CAS,在sync&#x2F;atomic包中,这类原子操作由名称以CompareAndSwap为前缀的若干个函数提供</p>
<p><strong>优势:</strong><br>可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。</p>
<p><strong>劣势:</strong><br>在被操作值被频繁变更的情况下,CAS操作并不那么容易成功。因为需要对old值进行匹配,只有匹配成功了才进行下一步的修改。</p>
<p>当前atomic 包有以下几种原子操作: Add、CompareAndSwap、Load、Store、Swap</p>
</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统编程</title>
    <url>/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-如何理解Linux中的一切皆文件？"><a href="#1-如何理解Linux中的一切皆文件？" class="headerlink" title="1. 如何理解Linux中的一切皆文件？"></a>1. 如何理解Linux中的一切皆文件？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1db411E72q/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240829004845341.png" alt="image-20240829004845341"></p>
<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240829005053280.png" alt="image-20240829005053280"></p>
<p>从实际的开发经验来说：</p>
<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240910022957764.png" alt="image-20240910022957764"></p>
<h2 id="2-虚拟内存与物理内存"><a href="#2-虚拟内存与物理内存" class="headerlink" title="2. 虚拟内存与物理内存"></a>2. 虚拟内存与物理内存</h2><p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/640.png" alt="图片"></p>
<p>操作系统内存管理中，另一个重要概念是虚拟内存，其作用如下：</p>
<ul>
<li>• 在用户与硬件间添加中间代理层（没有什么是加一个中间层解决不了的）</li>
<li>• 优化用户体验（进程感知到获得的内存空间是“连续”的）</li>
<li>• “放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li>
</ul>
<h2 id="3-进程与线程"><a href="#3-进程与线程" class="headerlink" title="3. 进程与线程"></a>3. 进程与线程</h2><p>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>Linux下：	<br>​	线程：最小的执行单<br>​	进程：最小分配资源单位，可看成是只有一个线程的进程。</p>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。<br>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。<br>因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="*线程共享资源*"></a><em><strong>*线程共享资源*</strong></em></h3><p>​	1.文件描述符表<br>​	2.每种信号的处理方式<br>​	3.当前工作目录<br>​	4.用户ID和组ID<br>​	5.内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库) （即：0-3G进程虚拟地址空间，栈除外）</p>
<h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="*线程非共享资源*"></a><em><strong>*线程非共享资源*</strong></em></h3><p>​	1.线程id<br>​	2.处理器现场和栈指针(内核栈)<br>​	3.独立的栈空间(用户空间栈)<br>​	4.errno变量<br>​	5.信号屏蔽字<br>​	6.调度优先级</p>
]]></content>
      <categories>
        <category>linux系统编程</category>
      </categories>
      <tags>
        <tag>linux系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络编程</title>
    <url>/2024/09/10/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-在socket网络编程中，为什么服务端产生两个socket，而客户端只产生一个socket？"><a href="#1-在socket网络编程中，为什么服务端产生两个socket，而客户端只产生一个socket？" class="headerlink" title="1. 在socket网络编程中，为什么服务端产生两个socket，而客户端只产生一个socket？"></a>1. 在socket网络编程中，为什么服务端产生两个socket，而客户端只产生一个socket？</h1><p>在Socket网络编程中，服务端产生两个socket，而客户端只产生一个socket，原因在于服务端和客户端的角色及其通信机制的不同。下面具体解释：</p>
<h3 id="1-服务端的两个socket"><a href="#1-服务端的两个socket" class="headerlink" title="1. 服务端的两个socket"></a>1. 服务端的两个socket</h3><ul>
<li><p><strong>监听（Listen）Socket</strong>：<br>服务端在初始化时会首先创建一个用于监听的socket，通常称为监听socket（或称为被动socket）。它的主要职责是<strong>等待客户端连接请求</strong>。这个socket绑定到一个特定的IP地址和端口，并开始监听来自客户端的连接。这个socket不会直接参与数据传输，而是负责处理新的连接请求。</p>
<p>调用顺序通常是：</p>
<ul>
<li><code>socket()</code>: 创建socket。</li>
<li><code>bind()</code>: 绑定到一个特定的地址和端口。</li>
<li><code>listen()</code>: 开始监听连接请求。</li>
</ul>
</li>
<li><p><strong>连接（Connected）Socket</strong>：<br>当监听socket收到客户端的连接请求时，服务端会调用<code>accept()</code>，此时会产生一个新的socket，称为连接socket（或称为主动socket）。这个socket用于和特定客户端之间的通信。每当一个新的客户端连接到服务器时，服务器就会为这个客户端创建一个新的连接socket，用来专门处理该客户端的数据收发。</p>
<p>调用顺序通常是：</p>
<ul>
<li><code>accept()</code>: 从监听socket中提取客户端连接请求，返回一个新的连接socket，服务端可以通过该socket与客户端通信。</li>
</ul>
</li>
</ul>
<h3 id="2-客户端的一个socket"><a href="#2-客户端的一个socket" class="headerlink" title="2. 客户端的一个socket"></a>2. 客户端的一个socket</h3><p>客户端的操作要简单得多。客户端只需要一个socket，它通过这个socket向服务端发起连接请求并与服务端通信。</p>
<p>客户端的调用顺序通常是：</p>
<ul>
<li><code>socket()</code>: 创建一个socket。</li>
<li><code>connect()</code>: 通过这个socket向服务端发起连接请求。</li>
<li>当连接建立后，客户端通过这个唯一的socket与服务端通信。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>服务端的两个socket</strong>：一个是监听socket，负责监听新的连接请求；另一个是连接socket，负责与某个客户端通信。</li>
<li><strong>客户端的一个socket</strong>：客户端只需要一个socket，通过它向服务端发起连接并进行通信。</li>
</ul>
<p>这种设计的好处在于：服务端可以同时监听多个客户端的连接请求，并且通过多个连接socket与不同的客户端同时通信，而不会混淆不同客户端的数据。</p>
<h3 id="补充：man-2-listen-函数的描述翻译与讲解："><a href="#补充：man-2-listen-函数的描述翻译与讲解：" class="headerlink" title="补充：man 2 listen 函数的描述翻译与讲解："></a>补充：man 2 listen 函数的描述翻译与讲解：</h3><h4 id="翻译："><a href="#翻译：" class="headerlink" title="翻译："></a>翻译：</h4><p><strong>名称</strong></p>
<ul>
<li><code>listen</code> – 在一个套接字上监听连接</li>
</ul>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>描述</strong></p>
<ul>
<li><p>创建基于套接字的连接需要多个操作。首先，通过<code>socket(2)</code>创建一个套接字。接下来，通过<code>listen()</code>指定接受传入连接的意愿，以及传入连接队列的限制。最后，使用<code>accept(2)</code>来接受连接。<code>listen()</code>调用仅适用于<code>SOCK_STREAM</code>类型的套接字。</p>
</li>
<li><p><code>backlog</code> 参数定义了传入连接队列的最大长度。如果在连接请求到达时，队列已满，客户端可能会收到一个带有 <code>ECONNREFUSED</code> 错误的提示。或者，如果底层协议支持重传，请求可能会被忽略，以便重试可能成功。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>如果成功，<code>listen()</code> 函数返回值为 <code>0</code>；否则返回值为 <code>-1</code>，并且全局变量 <code>errno</code> 被设置为指示错误的值。</li>
</ul>
<h4 id="讲解："><a href="#讲解：" class="headerlink" title="讲解："></a>讲解：</h4><ol>
<li><p><strong>功能解释</strong>：</p>
<ul>
<li><code>listen()</code> 函数的作用是使套接字（socket）进入监听状态，准备接受客户端的连接请求。它是服务器端网络编程中的一个关键步骤。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>socket</code>：由 <code>socket(2)</code> 创建的套接字描述符，它指定了要监听的那个套接字。</li>
<li><code>backlog</code>：指定了传入连接的队列长度，即在服务器处理连接请求之前，最多可以有多少个等待处理的连接请求。如果连接请求的数量超过此限制，多余的请求将被拒绝或者忽略，等待重试。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><code>listen()</code> 只适用于 <code>SOCK_STREAM</code> 类型的套接字，通常用于基于 TCP 的连接，因为 <code>SOCK_STREAM</code> 代表流式数据传输协议（比如 TCP）。</li>
</ul>
</li>
<li><p><strong>backlog 参数的作用</strong>：</p>
<ul>
<li><code>backlog</code> 设置了等待处理的连接请求队列的最大长度。客户端尝试连接时，如果队列已满，有两种可能：<ul>
<li>客户端直接收到 <code>ECONNREFUSED</code> 错误。</li>
<li>如果底层的协议支持自动重试，连接请求可能被忽略，以等待后续重试成功。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>如果调用成功，<code>listen()</code> 返回 0；如果失败，返回 -1 并设置 <code>errno</code> 来指示具体错误原因。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：<br><code>listen()</code> 函数的主要功能是让服务端的套接字进入监听状态，并允许服务端设置一个队列长度来限制在处理连接之前，最多能积压多少个连接请求。</p>
<h3 id="追问："><a href="#追问：" class="headerlink" title="追问："></a>追问：</h3><p><strong>你说 listen() 函数的作用是使套接字（socket）进入监听状态，也有说法说 accept 函数才是使套接字（socket）进入监听状态，到底哪个说法正确？</strong></p>
<p>在网络编程中，**<code>listen()</code>** 函数和 <strong><code>accept()</code></strong> 函数的作用是不同的，它们在服务器套接字生命周期中的角色也不一样。让我们明确一下各自的职责和作用：</p>
<h3 id="listen-函数的作用"><a href="#listen-函数的作用" class="headerlink" title="listen() 函数的作用"></a><code>listen()</code> 函数的作用</h3><ul>
<li><strong><code>listen()</code> 是使套接字进入监听状态的函数</strong>。</li>
<li>它的作用是告诉操作系统，这个套接字将被用于监听传入的连接请求。</li>
<li>在调用 <code>listen()</code> 之前，套接字是处于非监听状态的（通常是刚通过 <code>socket()</code> 创建的普通套接字）。一旦调用了 <code>listen()</code>，这个套接字会被标记为“被动套接字”，也就是专门用于等待和接受客户端连接请求的套接字。</li>
<li><code>listen()</code> 函数<strong>并不会直接接收连接</strong>，它只是开启了一个“接受连接请求的准备状态”。</li>
</ul>
<h3 id="accept-函数的作用"><a href="#accept-函数的作用" class="headerlink" title="accept() 函数的作用"></a><code>accept()</code> 函数的作用</h3><ul>
<li><strong><code>accept()</code> 是用于接受连接的函数</strong>。</li>
<li>当一个客户端发出连接请求后，操作系统会将这个连接放入监听队列中（该队列的大小由 <code>listen()</code> 函数的 <code>backlog</code> 参数定义）。<code>accept()</code> 从这个队列中取出一个等待的连接，并为这个连接创建一个新的套接字（连接套接字），用于与该客户端进行数据通信。</li>
<li>这个新的套接字是与特定客户端的连接通道，而原来的监听套接字继续监听其他的连接请求。</li>
</ul>
<h3 id="正确说法："><a href="#正确说法：" class="headerlink" title="正确说法："></a>正确说法：</h3><ul>
<li><strong><code>listen()</code> 是让套接字进入监听状态的函数</strong>，它使套接字可以接受客户端的连接请求。</li>
<li><strong><code>accept()</code> 则是实际处理这些连接请求</strong>，从等待队列中取出一个连接，生成一个新的套接字，用于和客户端进行通信。</li>
</ul>
<p>所以，**<code>listen()</code> 函数才是使套接字进入监听状态的函数**。</p>
<h1 id="2-select-poll-epoll-待学习"><a href="#2-select-poll-epoll-待学习" class="headerlink" title="2. select poll epoll (待学习)"></a>2. select poll epoll (待学习)</h1><p><a href="https://www.bilibili.com/video/BV1gN411e7gd/?spm_id_from=333.788&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1gN411e7gd/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p><a href="https://mp.weixin.qq.com/s/GCoczkOzDA2xfp8Nzb04dw">https://mp.weixin.qq.com/s/GCoczkOzDA2xfp8Nzb04dw</a></p>
<h2 id="2-1-在io多路复用中，为什么select有文件描述符的限制，而poll-和-epoll-没有文件描述符的限制"><a href="#2-1-在io多路复用中，为什么select有文件描述符的限制，而poll-和-epoll-没有文件描述符的限制" class="headerlink" title="2.1 在io多路复用中，为什么select有文件描述符的限制，而poll 和 epoll 没有文件描述符的限制"></a>2.1 在io多路复用中，为什么select有文件描述符的限制，而poll 和 epoll 没有文件描述符的限制</h2><p> <a href="../../../Downloads/ChatGPT-0918.html">ChatGPT-0918.html</a> </p>
<p><img src="/2024/09/10/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20241003095559328.png" alt="image-20241003095559328"></p>
]]></content>
      <categories>
        <category>linux网络编程</category>
      </categories>
      <tags>
        <tag>linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>golang随想录</title>
    <url>/2024/08/24/golang%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<h1 id="1-关于make是否指定容量"><a href="#1-关于make是否指定容量" class="headerlink" title="1. 关于make是否指定容量"></a>1. 关于make是否指定容量</h1><p><strong>在 Go 语言中，make 函数用于创建通道（channel）、切片（slice）和映射（map）。 根据是否指定size，channel分为非缓冲通道 和 缓冲通道； 那么对于切片（slice）和映射（map）来说，make时是否指定size，有什么区别呢？</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建通道（channel）、切片（slice）和映射（map）。对于切片和映射，<code>make</code> 函数的行为在是否指定大小（size）时有所不同。下面分别讨论切片和映射在使用 <code>make</code> 函数时是否指定大小的区别。</p>
<h3 id="切片（Slice）"><a href="#切片（Slice）" class="headerlink" title="切片（Slice）"></a>切片（Slice）</h3><ul>
<li><p><strong>未指定大小</strong>：当你使用 <code>make([]T, len)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 的切片，并且容量（capacity）等于长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个长度和容量均为 5 的切片。切片的所有元素都会被初始化为类型 <code>T</code> 的零值（比如对于 <code>int</code> 类型，零值是 0）。</p>
</li>
<li><p><strong>指定容量</strong>：当你使用 <code>make([]T, len, cap)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 且容量为 <code>cap</code> 的切片。容量可以比长度大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个长度为 5、容量为 10 的切片。这意味着虽然切片的当前长度是 5，但它最多可以扩展到 10 个元素而无需重新分配内存。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会将容量设置为与长度相同。</li>
<li>如果指定了容量，Go 会为切片预留更多的空间。这在切片需要频繁追加元素的场景下非常有用，因为预先指定较大的容量可以减少在追加元素时的内存重新分配操作，提高性能。</li>
</ul>
<h3 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h3><ul>
<li><p><strong>未指定大小</strong>：当你使用 <code>make(map[T1]T2)</code> 创建映射时，Go 会创建一个初始大小适合较小规模使用的映射。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个空的映射。虽然初始容量是非零的，但如果往映射中插入了超出初始容量的元素，映射会自动扩展。</p>
</li>
<li><p><strong>指定大小</strong>：当你使用 <code>make(map[T1]T2, cap)</code> 创建映射时，<code>cap</code> 表示预估的元素数量。Go 会为映射预分配足够的空间来存储 <code>cap</code> 个元素，以减少在实际使用过程中发生的扩展操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个初始容量为 10 的映射。这意味着 Go 会为至少 10 个键值对分配内存，减少当实际插入元素数量接近或超过 10 时的内存重新分配次数。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会为映射分配一个默认的小容量，并在需要时自动扩展。</li>
<li>如果指定了容量，Go 会为映射预分配足够的内存以存储指定数量的元素，从而提高性能，尤其是在已知需要存储大量元素的场景下。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>切片</strong>：指定容量可以让切片在追加元素时减少内存重新分配，从而提高性能。未指定容量时，容量等于长度。</li>
<li><strong>映射</strong>：指定容量可以减少映射在插入大量元素时的扩展次数，从而提高性能。未指定容量时，映射的容量是初始的小值，并会根据需要自动扩展。</li>
</ul>
<h1 id="2-切片是否指定size有什么区别？"><a href="#2-切片是否指定size有什么区别？" class="headerlink" title="2. 切片是否指定size有什么区别？"></a>2. 切片是否指定size有什么区别？</h1><p><strong>切片是否指定size有什么区别呢？</strong><br><strong>例如：</strong><br><strong>slice :&#x3D; make([]int)</strong><br><strong>slice :&#x3D; make([]int, 5)</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建切片时，是否指定 <code>size</code>（即长度）会影响切片的初始状态。下面解释两种情况下的区别：</p>
<h3 id="1-不指定长度"><a href="#1-不指定长度" class="headerlink" title="1. 不指定长度"></a>1. 不指定长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：如果你这样创建切片，由于没有指定长度和容量，Go 将会报错，因为 <code>make([]int)</code> 语法是无效的。</li>
<li><strong>原因</strong>：<code>make</code> 函数在用于创建切片时至少需要一个参数（长度），你必须指定切片的初始长度。</li>
</ul>
<p>因此，你需要至少指定长度，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 0 的切片，其容量也为 0。这是一个空的切片，但仍然可以追加元素。</p>
<h3 id="2-指定长度"><a href="#2-指定长度" class="headerlink" title="2. 指定长度"></a>2. 指定长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：这段代码创建了一个长度为 5 的切片，其容量也为 5。切片中的 5 个元素会被初始化为类型 <code>int</code> 的零值（即 0）。切片的底层数组会包含 5 个元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(slice) <span class="comment">// 输出: [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 输出: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><p><strong>未指定长度（非法操作）</strong>：如果你不指定长度并直接调用 <code>make([]int)</code>，Go 编译器会报错，因为这种用法是不合法的。你至少需要指定长度。</p>
</li>
<li><p><strong>指定长度</strong>：当你指定长度时，切片会被创建并初始化为指定长度的切片。它的容量和长度都等于你指定的长度。如果你在创建切片时指定的长度为 5，那么切片将包含 5 个元素，所有元素的初始值为 0。</p>
</li>
<li><p><strong>创建空切片</strong>：如果你需要一个空切片（长度为 0），你可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这个切片的长度和容量都为 0，可以使用 <code>append</code> 函数向其中添加元素，容量会根据需要自动扩展。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在创建切片时，必须至少指定长度。指定长度的切片会分配一个具有该长度的底层数组，未指定长度（即长度为 0）时，你得到的是一个空切片。</p>
<h1 id="3-golang哈希表"><a href="#3-golang哈希表" class="headerlink" title="3. golang哈希表"></a>3. golang哈希表</h1><p><strong>golang 中的映射（map）是哈希表吗？</strong></p>
<p><a href="https://www.joxrays.com/go-map/">https://www.joxrays.com/go-map/</a></p>
]]></content>
      <categories>
        <category>golang</category>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>golang基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2024/09/23/mysql/</url>
    <content><![CDATA[<h1 id="1-为什么InnoDB存储引擎选择使用B-tree索引结构？"><a href="#1-为什么InnoDB存储引擎选择使用B-tree索引结构？" class="headerlink" title="1. 为什么InnoDB存储引擎选择使用B+tree索引结构？"></a>1. 为什么InnoDB存储引擎选择使用B+tree索引结构？</h1><ul>
<li><p>A. 相对于二叉树，层级更少，搜索效率高；</p>
</li>
<li><p>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</p>
</li>
</ul>
<p>的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>
<ul>
<li>C. 相对Hash索引，B+tree支持范围匹配及排序操作；</li>
</ul>
<p><img src="/2024/09/23/mysql/image-20240923040709070.png" alt="image-20240923040709070"></p>
<h1 id="2-sql优化"><a href="#2-sql优化" class="headerlink" title="2. sql优化"></a>2. sql优化</h1><p>MySQL-进阶篇（3. SQL优化）</p>
<p>首先可以查看mysql的慢查询日志，定位到需要优化的 sql 语句的范围</p>
<h2 id="2-1-插入数据"><a href="#2-1-插入数据" class="headerlink" title="2.1 插入数据"></a>2.1 插入数据</h2><ul>
<li><p>使用insert插入数据时，尽可能得选择批量插入，主键顺序插入，性能要高于乱序插入。</p>
</li>
<li><p>大批量插入数据时，比如几百万记录，使用insert插入性能较低，此时可以选择使用 load 命令进行插入。</p>
<p><img src="/2024/09/23/mysql/image-20241006164714937.png" alt="image-20241006164714937"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务器时，加上参数 --local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1, 开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-主键优化"><a href="#2-2-主键优化" class="headerlink" title="2.2 主键优化"></a>2.2 主键优化</h2><p><strong>主键设计原则：</strong></p>
<ul>
<li><p>满足业务需求的情况下，尽量降低主键的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储效率： 在InnoDB存储引擎中，主键会在每个索引（包括聚簇索引和二级索引）中被引用。也就是说，主键的长度越长，每个索引中的记录会占用更多的存储空间。这会导致数据量大的时候存储开销变高。</span><br><span class="line">索引性能： 较短的主键能够使B+树结构（MySQL中用于实现索引的数据结构）更加紧凑。较小的索引占用更少的内存，查询时内存访问也会更高效。索引越短，查询时能更快定位到具体的数据页，从而提升查询速度。</span><br><span class="line">I/O 负担： 较长的主键会导致磁盘I/O操作增多，因为数据页变大或更多的页需要被访问，这会降低性能。</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据时，尽量选择顺序插入，选择使用<code>AUTO_INCREMENT</code>自增主键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乱序插入容易导致页分裂</span><br><span class="line">减少磁盘碎片</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量不要使用<code>UUID</code>做主键或者是其他自然主键，如身份证号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID的无序性导致频繁的页分裂：</span><br><span class="line">UUID（通用唯一标识符）是一种无序的、128位的字符串，通常被用作唯一标识符。如果将UUID作为主键，每次插入的数据会是乱序的，B+树无法保证有序性，导致频繁的页分裂。每次插入时，系统都需要在B+树中找到合适的位置插入，重新调整索引结构，这会导致显著的性能下降。</span><br><span class="line"></span><br><span class="line">UUID的长度较大：</span><br><span class="line">UUID通常由16字节（128位）构成，相比自增整数主键（通常是4字节的整数），UUID的长度要大得多。这意味着不仅主键占用的存储空间更多，而且所有引用该主键的二级索引也会变得臃肿，进一步增加了存储和查询的成本。</span><br><span class="line"></span><br><span class="line">自然主键不适合做主键：</span><br><span class="line">例如身份证号或电话号码等自然主键虽然能保证唯一性，但它们通常存在以下问题：</span><br><span class="line"></span><br><span class="line">长度过长： 自然主键通常比自增ID长很多，增加了存储开销和索引的维护成本。</span><br><span class="line">业务变动风险： 自然主键有可能会因业务需求发生变化（如人换身份证号、电话号码等），这会导致主键变更带来的额外复杂性。而且，主键一旦改变，相关的二级索引和引用的表都会受到影响，导致复杂的数据维护工作。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-3-order-by-优化"><a href="#2-3-order-by-优化" class="headerlink" title="2.3 order by 优化"></a>2.3 order by 优化</h2><p>MySQL的排序，有两种方式：</p>
<p>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
<p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p>
<p><img src="/2024/09/23/mysql/image-20241006173741475.png" alt="image-20241006173741475"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_aa <span class="keyword">on</span> tb_user(age,phone);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/23/mysql/image-20241006174051145.png" alt="image-20241006174051145"></p>
<p><strong>order by优化原则：</strong></p>
<ul>
<li><p>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
</li>
<li><p>尽量使用覆盖索引，避免出现回表查询。（覆盖索引是指，查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。）</p>
</li>
<li><p>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span>,phone <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认256k）。</p>
</li>
</ul>
<p><img src="/2024/09/23/mysql/image-20241006175253654.png" alt="image-20241006175253654"></p>
<h2 id="2-4-group-by优化"><a href="#2-4-group-by优化" class="headerlink" title="2.4 group by优化"></a>2.4 group by优化</h2><ul>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ul>
<h2 id="2-5-limit优化"><a href="#2-5-limit优化" class="headerlink" title="2.5 limit优化"></a>2.5 limit优化</h2><p>在数据量较大时，如果进行limit分页查询，越往后，分页查询的效率越低。</p>
<p><img src="/2024/09/23/mysql/image-20241006180417124.png" alt="image-20241006180417124"></p>
<p>因为，当在进行分页查询时，如果执行 <code>limit 2000000,10</code>，此时需要MySQL排序前2000010记录，仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p>
<p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku limit <span class="number">2000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>





<h2 id="2-6-count优化"><a href="#2-6-count优化" class="headerlink" title="2.6 count优化"></a>2.6 count优化</h2><blockquote>
<p>按照效率排序的话，count(字段) &lt; count(主键 ID) &lt; count(1) ~ count(<em>), 所以尽量使用 count(</em>)。</p>
</blockquote>
<p><img src="/2024/09/23/mysql/image-20241006182020266.png" alt="image-20241006182020266"></p>
<h1 id="3-最左前缀法则易错点"><a href="#3-最左前缀法则易错点" class="headerlink" title="3. 最左前缀法则易错点"></a>3. 最左前缀法则易错点</h1><p>已知：</p>
<p><img src="/2024/09/23/mysql/image-20241006184656719.png" alt="image-20241006184656719"></p>
<p>当执行SQL语句： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where age = 31 and status = &#x27;0&#x27; and profession = &#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure>

<p>上述的联合索引，索引长度？</p>
<p><img src="/2024/09/23/mysql/image-20241006184419876.png" alt="image-20241006184419876"></p>
<p>可以看到，是完全满足是最左前缀法则的，索引长度54，联合索引是有效的。</p>
<p><strong>注意：最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段（即第一个字符）必须存在，与我们编写SQL时，条件编写的先后顺序无关。</strong></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>pprof使用指南</title>
    <url>/2024/08/23/pprof%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>golang</category>
        <category>golang调试</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>golang调试</tag>
      </tags>
  </entry>
  <entry>
    <title>编程基础随想录</title>
    <url>/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    <content><![CDATA[<h2 id="1-如何理解同步和异步？"><a href="#1-如何理解同步和异步？" class="headerlink" title="1. 如何理解同步和异步？"></a>1. 如何理解同步和异步？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1MC411a7rY/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/image-20240829012145437.png" alt="image-20240829012145437"></p>
<p><img src="/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/image-20240829012334628.png" alt="image-20240829012334628"></p>
<p><strong>追问：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么情况下用同步？</span><br><span class="line">什么情况下用异步？</span><br><span class="line">两者有什么差异？</span><br><span class="line">怎么在用户态层面实现异步？内核态又是怎么实现异步的？</span><br><span class="line">rpc接口是同步的还是异步的，为什么？该如何实现？</span><br></pre></td></tr></table></figure>



<h2 id="2-如何理解阻塞和非阻塞？"><a href="#2-如何理解阻塞和非阻塞？" class="headerlink" title="2. 如何理解阻塞和非阻塞？"></a>2. 如何理解阻塞和非阻塞？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1MK421x7Sa/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="3-什么是回调函数？"><a href="#3-什么是回调函数？" class="headerlink" title="3. 什么是回调函数？"></a>3. 什么是回调函数？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1cW421N7P2/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="4-什么是IO多路复用？"><a href="#4-什么是IO多路复用？" class="headerlink" title="4. 什么是IO多路复用？"></a>4. 什么是IO多路复用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1RJ4m1b7cy/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="5-如何理解并行和并发？"><a href="#5-如何理解并行和并发？" class="headerlink" title="5. 如何理解并行和并发？"></a>5. 如何理解并行和并发？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1fA4m1c7YT/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="6-什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？"><a href="#6-什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？" class="headerlink" title="6. 什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？"></a>6. 什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3</a></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/2024/10/07/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="简历怎么写"><a href="#简历怎么写" class="headerlink" title="简历怎么写"></a>简历怎么写</h1><p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008124907689.png" alt="image-20241008124907689"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008124622604.png" alt="image-20241008124622604"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008124953631.png" alt="image-20241008124953631"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008125206822.png" alt="image-20241008125206822"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008125320013.png" alt="image-20241008125320013"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008125355513.png" alt="image-20241008125355513"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008150436199.png" alt="image-20241008150436199"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008150834987.png" alt="image-20241008150834987"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008151324078.png" alt="image-20241008151324078"></p>
<p><img src="/2024/10/07/%E9%9D%A2%E7%BB%8F/image-20241008153143907.png" alt="image-20241008153143907"></p>
<p><strong>体现技术攻关</strong></p>
<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><p>来源：<a href="https://www.bilibili.com/video/BV1tF41147cK/?spm_id_from=333.999.0.0&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1tF41147cK/?spm_id_from=333.999.0.0&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p>mysql</p>
<ol>
<li>SQL 优化</li>
<li>针对 SQL 语句如何建立索引（最左原则）</li>
<li>索引数据结构（B+树）</li>
</ol>
<p>mq</p>
<ol>
<li>为什么选用 rocketMQ 进行日志采集</li>
<li>为什么需要队列进行日志采集？</li>
<li>日志采集的架构是怎样的？流程是怎样的？</li>
<li>rocketMQ 如何保证消息的顺序？</li>
</ol>
<p>redis</p>
<ol>
<li>redis 的使用场景？</li>
<li>内存不足有新数据缓存，redis 如何处理？</li>
<li>redis 的淘汰策略</li>
<li>redis 的缓存一致性</li>
</ol>
<p>go</p>
<ol>
<li>线上服务内存泄漏如何处理？</li>
<li>go 为啥使用 CSP 模型来实现并发？</li>
<li>channel 是线程安全的吗？</li>
<li>channel 怎么保证的线程安全？</li>
<li>channel 的底层数据结构</li>
<li>mutex 是悲观锁还是乐观锁？</li>
<li>rwmutex 的使用场景</li>
<li>map 是线程安全的吗</li>
<li>无锁，但是线程安全的 map 如何设计？（CAS）</li>
<li>结构体能否进行比较？</li>
<li>空结构体的使用场景</li>
<li>给 channel 用空结构体的好处是什么？</li>
<li>字符串转 byte 数组会发生内存拷贝吗？</li>
<li>字符串转 byte 数组，如何避免发送内存拷贝？</li>
<li>多核 CPU 如何保持 cache 一致？（MESI协议）</li>
<li>GMP 调度模型，GMP 中的抢占机制</li>
<li>GC 三色标记，stw 是什么意思？产生 stw 的原因是什么？小对象多了，为什么会造成 GC  压力？</li>
</ol>
<p>代码题</p>
<ol>
<li>go 函数中，返回值未命名，发生了 panic，但是在函数内 recover 了，函数返回什么值？怎么解决？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func test() error &#123;</span><br><span class="line">   var err error</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      if r := recover(); r != nil &#123;</span><br><span class="line">         err = errors.New(fmt.Sprintf(&quot;%s&quot;, r))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   raisePanic()</span><br><span class="line">   return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func raisePanic() &#123;</span><br><span class="line">   panic(&quot;发生了错误&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>打印值是多少？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a uint = 0</span><br><span class="line">   var b uint = 1</span><br><span class="line">   c := a - b</span><br><span class="line">   fmt.Println(reflect.TypeOf(c))</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   a := [3]int&#123;1, 2, 3&#125;  // 数组</span><br><span class="line">   for k, v := range a &#123;</span><br><span class="line">      if k == 0 &#123;</span><br><span class="line">         a[0], a[1] = 100, 200</span><br><span class="line">         fmt.Print(a)</span><br><span class="line">      &#125;</span><br><span class="line">      a[k] = 100 + v</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   a := []int&#123;1, 2, 3&#125;  // 切片</span><br><span class="line">   for k, v := range a &#123;</span><br><span class="line">      if k == 0 &#123;</span><br><span class="line">         a[0], a[1] = 100, 200</span><br><span class="line">         fmt.Print(a)</span><br><span class="line">      &#125;</span><br><span class="line">      a[k] = 100 + v</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>每个函数起一个 goroutine，轮流打印 cat、dog、fish 100 次</li>
<li>手写 LRU 算法</li>
</ol>
<p>网络编程</p>
<ol>
<li>tcp 三次握手，四次挥手，四次挥手中 time_wait 可怕还是 close_wait 可怕</li>
<li>用过哪些 Linux 命令</li>
<li>tcp 的流量控制</li>
<li>rpc 是什么？如何设计一个 rpc？</li>
<li>如何处理 tcp 粘包问题？</li>
<li>http1.1 和 http2 的区别</li>
</ol>
<h1 id="中移"><a href="#中移" class="headerlink" title="中移"></a>中移</h1><ul>
<li><input checked disabled type="checkbox"> 1.gpm调度模型原理</li>
<li><input checked disabled type="checkbox"> 2.map和sync.map应用场景</li>
<li><input checked disabled type="checkbox"> 3.chan作用 用法</li>
<li><input disabled type="checkbox"> 4.mysql的架构 binlog 和redolog的作用</li>
<li><input disabled type="checkbox"> 5.mysql主备复制是异步还是同步</li>
<li><input disabled type="checkbox"> 6.mysql索引的高度影响因素</li>
<li><input disabled type="checkbox"> 7.socket的最大连接数由那些来控制</li>
<li><input checked disabled type="checkbox"> 1: defer: 函数内部修改了变量值，并且defer也修改了值， 那么return的时候是否返回defer修改的值吗</li>
<li><input checked disabled type="checkbox"> 2: channel知识： 如何变成非阻塞方式读取&#x2F;。写一个值之后，多个携程读，是否只有一个协程读？channel的用途</li>
<li><input disabled type="checkbox"> 5: linux相关知识： cgroup和虚拟内存， 运行ls命令的流程（fork+exec），cgroup可以限制哪些资源（子系统）</li>
<li><input disabled type="checkbox"> 6:mysql: 隔离形有哪几种？</li>
<li><input disabled type="checkbox"> 1,go 锁，分布式锁，在项目中怎么使用的</li>
<li><input checked disabled type="checkbox"> 2,goroutine 介绍一下</li>
<li><input disabled type="checkbox"> 3,mysql相关的5-6道</li>
<li><input disabled type="checkbox"> 4.redis相关的5-6道</li>
<li><input checked disabled type="checkbox"> <ol start="7">
<li>go垃圾回收</li>
</ol>
</li>
<li><input checked disabled type="checkbox"> 1、map的扩容操作如何实现？可以并发吗？sync.map 适合什么操作，适合读少写多吗？如果设计为高并发的写操作，有什么思路？</li>
<li><input checked disabled type="checkbox"> 2、入参为指针类型，需要判断为空吗?</li>
<li><input checked disabled type="checkbox"> 3、for  a,b :&#x3D;  range slice, a代表什么，b代表什么</li>
<li><input checked disabled type="checkbox"> 4、一直要读取chanel，应该怎么办？</li>
<li><input checked disabled type="checkbox"> 5、linux ：<br>   有个文件很大，如何全部读取<br>   cat 读取大文件<br>   less 逐叶读取文件<br>   head -n 10 文件  读取文件的前10行<br>   如何看某个进程打开了多少个文件句柄<br>   lsof -p 1234 | wc -l</li>
<li><input disabled type="checkbox"> 6、b+树有什么好处？和二叉树比呢？</li>
<li><input disabled type="checkbox"> 7、redo log、undo log、bing log有什么作用？</li>
<li><input disabled type="checkbox"> b树 b+树 红黑树区别</li>
<li><input disabled type="checkbox"> redis的缓存淘汰策略</li>
<li><input disabled type="checkbox"> redis的big key说一下</li>
<li><input disabled type="checkbox"> redis的缓存击穿和雪崩，以及怎么解决，你项目里用的singleflight怎么实现的</li>
<li><input disabled type="checkbox"> 限流的漏桶算法说一下，你项目里是怎么基于redis实现的</li>
<li><input disabled type="checkbox"> 你项目里用的哈希取模来sharding 那么redis的slot有了解吗</li>
<li><input checked disabled type="checkbox"> golang main和init函数加载顺序和原因</li>
<li><input checked disabled type="checkbox"> 写程序 go 实现生产者生产，消费者非阻塞消费，然后退出。</li>
<li><input checked disabled type="checkbox"> 使用云数据库有什么优势和劣势</li>
</ul>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2024/09/29/redis/</url>
    <content><![CDATA[<h1 id="1-在你的项目中是如何使用redis的？"><a href="#1-在你的项目中是如何使用redis的？" class="headerlink" title="1. 在你的项目中是如何使用redis的？"></a>1. 在你的项目中是如何使用redis的？</h1><p>ew</p>
<h1 id="1-缓存穿透、缓存雪崩、缓存击穿"><a href="#1-缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="1. 缓存穿透、缓存雪崩、缓存击穿"></a>1. 缓存穿透、缓存雪崩、缓存击穿</h1><h2 id="1-1-缓存穿透"><a href="#1-1-缓存穿透" class="headerlink" title="1.1 缓存穿透"></a>1.1 缓存穿透</h2><p><img src="/2024/09/29/redis/image-20240929105434393.png" alt="image-20240929105434393"></p>
<p><img src="/2024/09/29/redis/image-20240929105507109.png" alt="image-20240929105507109"></p>
<p><img src="/2024/09/29/redis/image-20240929105531012.png" alt="image-20240929105531012"></p>
<h2 id="1-2-缓存雪崩"><a href="#1-2-缓存雪崩" class="headerlink" title="1.2 缓存雪崩"></a>1.2 缓存雪崩</h2><p><img src="/2024/09/29/redis/image-20240929105559263.png" alt="image-20240929105559263"></p>
<h2 id="1-3-缓存击穿"><a href="#1-3-缓存击穿" class="headerlink" title="1.3 缓存击穿"></a>1.3 缓存击穿</h2><p><img src="/2024/09/29/redis/image-20240929110956937.png" alt="image-20240929110956937"></p>
<p><img src="/2024/09/29/redis/image-20240929111026578.png" alt="image-20240929111026578"></p>
<p><img src="/2024/09/29/redis/image-20240929111046644.png" alt="image-20240929111046644"></p>
<h1 id="1-乐观锁与悲观锁"><a href="#1-乐观锁与悲观锁" class="headerlink" title="1. 乐观锁与悲观锁"></a>1. 乐观锁与悲观锁</h1><p><img src="/2024/09/29/redis/image-20240929215246188.png" alt="image-20240929215246188"></p>
<p><img src="/2024/09/29/redis/image-20240929215301769.png" alt="image-20240929215301769"></p>
<p><img src="/2024/09/29/redis/image-20240929215321940.png" alt="image-20240929215321940"></p>
<p><img src="/2024/09/29/redis/image-20240929215343463.png" alt="image-20240929215343463"></p>
<p><img src="/2024/09/29/redis/image-20240929215357585.png" alt="image-20240929215357585"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在电商秒杀系统中，为了解决超卖问题（售出商品数量大于库存），我使用了乐观锁的方案，核心代码如下：</span><br><span class="line"></span><br><span class="line">boolean success = seckillVoucherService.update()</span><br><span class="line">    .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1</span><br><span class="line">    .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0</span><br><span class="line">    .update();</span><br><span class="line"></span><br><span class="line">乐观锁的核心在于将 stock &gt; 0 作为 where 条件的一部分</span><br><span class="line"></span><br><span class="line">这样确实解决了超卖问题，但是我不理解的是：如果有多个线程并发执行，且他们都符合 where id = ? and stock &gt; 0，那是不是还是会出现超卖问题？</span><br><span class="line"></span><br><span class="line">在你的电商秒杀系统中使用乐观锁的方式确实可以有效地解决超卖问题。你的担心是有道理的，但让我们详细分析一下这个实现的工作机制和其对并发情况的处理。</span><br><span class="line"></span><br><span class="line">乐观锁的核心思想是在更新时检查记录是否在读取数据后被其他事务修改过。如果是，那么更新操作将失败。这是通过在更新条件中加入一些检查来实现的，比如检查库存数量是否符合预期。在你的代码中，这种机制通过SQL条件 `stock &gt; 0` 实现。</span><br><span class="line"></span><br><span class="line">具体到你的SQL更新操作：</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">.update().setSql(&quot;stock = stock - 1&quot;).eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这段代码的执行逻辑如下：</span><br><span class="line"></span><br><span class="line">1. 检查商品库存（stock）是否大于0。</span><br><span class="line">2. 如果库存大于0，那么减少1（`stock = stock - 1`）。</span><br><span class="line">3. 更新操作是原子性的，即它在单个、不可分割的步骤中完成检查和更新。</span><br><span class="line"></span><br><span class="line">当多个线程（或多个请求）同时尝试执行这个更新操作时，数据库管理系统（DBMS）会确保每个更新操作都是独立执行的。假设现在有两个并发请求试图更新同一记录，并且当前`stock`的值为1。两个请求都会试图将`stock`从1减到0。但是，由于更新操作中包含了条件`stock &gt; 0`，因此只有第一个到达数据库并被处理的请求能够成功执行更新（将`stock`减到0）。第二个请求在尝试执行相同操作时，条件`stock &gt; 0`将不再为真（因为`stock`已经是0了），因此这个请求的更新操作将失败，不会进行任何更改。</span><br><span class="line"></span><br><span class="line">这意味着即使多个请求符合条件`id = ? AND stock &gt; 0`，数据库在实际执行更新前都会再次检查这个条件。由于这个检查-更新操作是原子性的，它确保了不会有两个请求同时减少库存，导致超卖。</span><br><span class="line"></span><br><span class="line">所以，你的实现方法有效地利用了乐观锁的特性来防止超卖问题。这种策略特别适用于库存数量不是非常大，而并发请求量也适中的场景。如果预计极高的并发量，可能还需要考虑其他策略（比如分布式锁或进一步优化事务控制）来确保系统的稳定性和性能。</span><br></pre></td></tr></table></figure>







<h1 id="3-参考-redisson，总结虚拟IP项目"><a href="#3-参考-redisson，总结虚拟IP项目" class="headerlink" title="3. 参考 redisson，总结虚拟IP项目"></a>3. 参考 redisson，总结虚拟IP项目</h1><p>秒杀场景和虚拟IP的申请场景实际上的高度相似的</p>
<p>解决什么问题？同一个用户只能获取一个虚拟IP，类比一人一单和超卖问题</p>
<p>下面的这些原理可以映射到虚拟IP的golang的业务逻辑（即虚拟IP的申请，释放，续租逻辑）</p>
<p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=67&spm_id_from=pageDriver&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1cr4y1671t?p=67&amp;spm_id_from=pageDriver&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p><img src="/2024/09/29/redis/image-20240930101029204.png" alt="image-20240930101029204"></p>
<p>golang 分布式锁</p>
<p><a href="https://www.bilibili.com/video/BV1Pm4y1b76u/?spm_id_from=333.337.search-card.all.click&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1Pm4y1b76u/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p><a href="https://www.bilibili.com/video/BV1wP411X7sc/?spm_id_from=333.337.search-card.all.click&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1wP411X7sc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p>项目有哪些可优化点，遇到了什么难点。。。</p>
<p>回答思路：</p>
<p><img src="/2024/09/29/redis/image-20240930110640799.png" alt="image-20240930110640799"></p>
<p>multiLock 还有不理解的地方，如果一个 redis 节点挂了，那就不满足在所有节点获取到锁了，那和单个节点有什么区别？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`Redisson` 的 `multiLock` 是一个分布式锁实现，使用了多个 Redis 实例来提升锁的可靠性。你提到的情况涉及到在多个 Redis 节点上尝试获取锁时，某些节点不可用的情形。这实际上涉及到分布式系统中的可用性和一致性之间的权衡。</span><br><span class="line"></span><br><span class="line">首先，`multiLock` 的核心思想是通过同时在多个 Redis 节点上获取锁来增加锁的安全性，防止某个单节点故障导致锁失效或错误释放锁。在具体实现中，`multiLock` 要求在**所有节点**上都成功获取锁，才算整个锁获取成功，这种严格模式下保证了高一致性。</span><br><span class="line"></span><br><span class="line">### 关于节点挂掉的情况：</span><br><span class="line">- **如果一个节点挂了**，根据 `multiLock` 的机制，无法在所有节点上获取锁，所以这次锁获取会失败。这种设计的初衷是防止部分节点失效时锁状态的不一致性，确保只有在所有参与节点上都获得了锁的情况下，才能认为锁是成功获取的。</span><br><span class="line">- **和单节点的区别**：虽然一个节点挂了会导致锁获取失败，但在正常情况下，多个节点提高了锁的可靠性。例如，单节点 Redis 如果宕机，锁会直接失效，所有依赖这个锁的操作可能会出错或进入竞争状态。而通过多个节点获取锁，除非有多个节点宕机，系统依然能够正常运行。</span><br><span class="line"></span><br><span class="line">### 如何处理 Redis 节点故障：</span><br><span class="line">如果你的系统要求在部分 Redis 节点挂掉的情况下仍然能够获取锁，可以考虑使用 Redisson 提供的 `RedLock` 算法。`RedLock` 允许在大多数节点（通常是超过一半的节点）上获取锁，而不是要求所有节点。这在某些场景下可以提供更好的容错能力。</span><br><span class="line"></span><br><span class="line">简单总结：</span><br><span class="line">- **multiLock** 提供更高的锁一致性，但在任何一个节点不可用时，锁获取会失败。</span><br><span class="line">- **RedLock** 则是通过在大多数节点上获取锁来增加容错性，适合 Redis 节点可能不稳定的场景。</span><br><span class="line"></span><br><span class="line">因此，`multiLock` 和单节点的区别在于，`multiLock` 强调多个节点间的一致性，而不是依赖于单个节点来决定锁的状态。</span><br></pre></td></tr></table></figure>





<h1 id="4-《面试八股文》之-Redis-16问"><a href="#4-《面试八股文》之-Redis-16问" class="headerlink" title="4. 《面试八股文》之 Redis 16问"></a>4. 《面试八股文》之 Redis 16问</h1><p><a href="https://blog.51cto.com/u_15714244/5461657">https://blog.51cto.com/u_15714244/5461657</a></p>
]]></content>
      <categories>
        <category>redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-选择排序与冒泡排序"><a href="#1-选择排序与冒泡排序" class="headerlink" title="1. 选择排序与冒泡排序"></a>1. 选择排序与冒泡排序</h1><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240826170655954.png" alt="image-20240826170655954"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240826170729362.png" alt="image-20240826170729362"></p>
<h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h1><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<p>最好情况：O(N)，最坏情况：O(N^2)</p>
<p>算法流程按照最差情况来估计时间复杂度</p>
<p>类似于打扑克牌抓牌时的插入</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240829164912630.png" alt="image-20240829164912630"></p>
<h1 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h1><p><a href="https://leetcode.cn/problems/sort-an-array/submissions/">https://leetcode.cn/problems/sort-an-array/submissions/</a></p>
<p><strong>使用「快速排序」解决的经典问题（非常重要）：</strong></p>
<ul>
<li>TopK 问题：「力扣」第 215 题：数组中的第 K 个最大元素</li>
</ul>
<p>​		<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">https://leetcode.cn/problems/kth-largest-element-in-an-array/description/</a></p>
<ul>
<li>荷兰国旗问题：「力扣」第 75 题：颜色分类</li>
</ul>
<p>​		<a href="https://leetcode.cn/problems/sort-colors/description/">https://leetcode.cn/problems/sort-colors/description/</a></p>
<h1 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h1><p>堆排序的细节和复杂度分析</p>
<p>时间复杂度O(N*logN)，额外空间复杂度O(1) </p>
<p>堆结构非常重要</p>
<p>1，堆结构的heapInsert与heapify </p>
<p>2，堆结构的增大和减少 </p>
<p>3，如果只是建立堆的过程，时间复杂度为O(N) </p>
<p>4，优先级队列结构，就是堆结构</p>
<p>使用堆排序解决的经典问题：</p>
<ul>
<li><p>TopK 问题：「力扣」第 215 题：数组中的第 K 个最大元素</p>
<p><a href="https://leetcode.cn/problems/sort-an-array/submissions/560152694/">https://leetcode.cn/problems/sort-an-array/submissions/560152694/</a></p>
</li>
<li><p>排序几乎有序的数组</p>
</li>
</ul>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240831184709207.png" alt="image-20240831184709207"></p>
<p>假设要求升序排列，由题意，数组最小的数一定在下标。0–k 的范围内，所以将 0–k 范围内的数建立成小根堆，则下标0的数即为数组最小值，然后 k 窗口依次往右移动</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240831185648360.png" alt="image-20240831185648360"></p>
<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902160735736.png" alt="image-20240902160735736"></p>
<p><a href="https://leetcode.cn/problems/sort-an-array/submissions/560674602/">https://leetcode.cn/problems/sort-an-array/submissions/560674602/</a>. – 用归并排序解决数组排序问题题解</p>
<ul>
<li><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a></li>
</ul>
<p>​		<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/submissions/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/submissions/</a></p>
<ul>
<li><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></p>
<p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/submissions/">https://leetcode.cn/problems/count-of-smaller-numbers-after-self/submissions/</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240830152141731.png" alt="image-20240830152141731"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240830152152732.png" alt="image-20240830152152732"></p>
<h1 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6. 哈希表"></a>6. 哈希表</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902191649354.png" alt="image-20240902191649354"></p>
<h1 id="7-有序表"><a href="#7-有序表" class="headerlink" title="7. 有序表"></a>7. 有序表</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902191719761.png" alt="image-20240902191719761"></p>
<h1 id="8-链表"><a href="#8-链表" class="headerlink" title="8. 链表"></a>8. 链表</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240907221407142.png" alt="image-20240907221407142"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240907221424840.png" alt="image-20240907221424840"></p>
<h2 id="8-1-反转单向链表"><a href="#8-1-反转单向链表" class="headerlink" title="8.1 反转单向链表"></a>8.1 反转单向链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/?envType=problem-list-v2&envId=linked-list">https://leetcode.cn/problems/reverse-linked-list/?envType=problem-list-v2&amp;envId=linked-list</a></p>
<h2 id="8-2-反转单向链表进阶"><a href="#8-2-反转单向链表进阶" class="headerlink" title="8.2 反转单向链表进阶"></a>8.2 反转单向链表进阶</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/submissions/562860540/?envType=problem-list-v2&envId=linked-list">https://leetcode.cn/problems/reverse-linked-list-ii/submissions/562860540/?envType=problem-list-v2&amp;envId=linked-list</a></p>
<p><a href="https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240908155521318.png" alt="image-20240908155521318"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240908162630023.png" alt="image-20240908162630023"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240908162707744.png" alt="image-20240908162707744"></p>
<h2 id="8-3-反转单向链表hard"><a href="#8-3-反转单向链表hard" class="headerlink" title="8.3 反转单向链表hard"></a>8.3 反转单向链表hard</h2><p><a href="https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/submissions/562862051/">https://leetcode.cn/problems/reverse-nodes-in-k-group/submissions/562862051/</a></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240909021915991.png" alt="image-20240909021915991"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240909021945636.png" alt="image-20240909021945636"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240909022011490.png" alt="image-20240909022011490"></p>
<h2 id="8-4-反转双向链表"><a href="#8-4-反转双向链表" class="headerlink" title="8.4 反转双向链表"></a>8.4 反转双向链表</h2><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240910150436745.png" alt="image-20240910150436745"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="type">int</span></span><br><span class="line">	Next *DoubleListNode</span><br><span class="line">	Last *DoubleListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *DoubleListNode)</span></span> *DoubleListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> pre, next *DoubleListNode = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		next = head.Next</span><br><span class="line">		head.Next = pre</span><br><span class="line">		head.Last = next</span><br><span class="line">		pre = head</span><br><span class="line">		head = next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printList</span><span class="params">(head *DoubleListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(head.Val)</span><br><span class="line">		head = head.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	node1 := &amp;DoubleListNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">	node2 := &amp;DoubleListNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">	node3 := &amp;DoubleListNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">	node4 := &amp;DoubleListNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">	node1.Next = node2</span><br><span class="line">	node1.Last = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	node2.Next = node3</span><br><span class="line">	node2.Last = node1</span><br><span class="line"></span><br><span class="line">	node3.Next = node4</span><br><span class="line">	node3.Last = node2</span><br><span class="line"></span><br><span class="line">	node4.Next = <span class="literal">nil</span></span><br><span class="line">	node4.Last = node3</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;原始链表：&quot;</span>)</span><br><span class="line">	printList(node1)</span><br><span class="line"></span><br><span class="line">	head := reverseList(node1)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;翻转后：&quot;</span>)</span><br><span class="line">	printList(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-5-打印两个有序链表的公共部分"><a href="#8-5-打印两个有序链表的公共部分" class="headerlink" title="8.5 打印两个有序链表的公共部分"></a>8.5 打印两个有序链表的公共部分</h2><p>【题目】 给定两个有序链表的头指针head1和head2， 打印两个链表的公共部分。<br>【要求】 如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复</p>
<p>题目解析</p>
<p>因为是有序链表，所以从两个链表的头结点开始判断：</p>
<ul>
<li>如果head1的值小于head2，那么head1下移</li>
<li>如果head2的值小于head1，那么head2下移</li>
<li>如果两者相同，那么打印这个值，然后head1和head2均下移</li>
<li>head1或者head2中只要有一个移动到null，那么整个过程停止</li>
</ul>
<p>为什么不是谁大谁移动，而是谁小谁移动，因为链表有序，先移动大的话，大的更大，两个链表无法相等了，所以应该移动小的，让小的追赶大的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void printCommon(ListNode* head1, ListNode *head2) &#123;</span><br><span class="line">        ListNode *curr1 = head1, *curr2 = head2;</span><br><span class="line">        while (curr1 != nullptr &amp;&amp; curr2 != nullptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr1 == curr2)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%d\t&quot;</span>, curr1-&gt;val);</span><br><span class="line">                curr1 = curr1-&gt;next;</span><br><span class="line">                curr2 = curr2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr1-&gt;val &lt; curr2-&gt;val)&#123;</span><br><span class="line">                curr1 = curr1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr2 = curr2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="8-6-LCR-027-回文链表"><a href="#8-6-LCR-027-回文链表" class="headerlink" title="8.6 LCR 027. 回文链表"></a>8.6 <a href="https://leetcode.cn/problems/aMhZSa/">LCR 027. 回文链表</a></h2><p><a href="https://leetcode.cn/problems/aMhZSa/submissions/563379831/">https://leetcode.cn/problems/aMhZSa/submissions/563379831/</a></p>
<h2 id="8-7-86-分隔链表"><a href="#8-7-86-分隔链表" class="headerlink" title="8.7 86. 分隔链表"></a>8.7 <a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h2><p><a href="https://leetcode.cn/problems/partition-list/submissions/563427899/?envType=problem-list-v2&envId=linked-list">https://leetcode.cn/problems/partition-list/submissions/563427899/?envType=problem-list-v2&amp;envId=linked-list</a></p>
<h3 id="进阶：左边小、中间相等、右边大"><a href="#进阶：左边小、中间相等、右边大" class="headerlink" title="进阶：左边小、中间相等、右边大"></a>进阶：左边小、中间相等、右边大</h3><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240907223456704.png" alt="image-20240907223456704"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240910183333054.png" alt="image-20240910183333054"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240910183410063.png" alt="image-20240910183410063"></p>
<h2 id="8-8-138-随机链表的复制"><a href="#8-8-138-随机链表的复制" class="headerlink" title="8.8 138. 随机链表的复制"></a>8.8 <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/submissions/564207757/">https://leetcode.cn/problems/copy-list-with-random-pointer/submissions/564207757/</a></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240910183452486.png" alt="image-20240910183452486"></p>
<h2 id="8-9-相交链表-环形链表问题"><a href="#8-9-相交链表-环形链表问题" class="headerlink" title="8.9 相交链表&amp;环形链表问题"></a>8.9 相交链表&amp;环形链表问题</h2><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/submissions/564431481/">https://leetcode.cn/problems/intersection-of-two-linked-lists/submissions/564431481/</a></p>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/submissions/564467475/">https://leetcode.cn/problems/linked-list-cycle/submissions/564467475/</a></p>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/564464002/">https://leetcode.cn/problems/linked-list-cycle-ii/submissions/564464002/</a></p>
<h4 id="快慢指针解法证明"><a href="#快慢指针解法证明" class="headerlink" title="快慢指针解法证明"></a>快慢指针解法证明</h4><p>重画链表如下所示，线上有若干个节点。记蓝色慢指针为 slow，红色快指针为 fast。初始时 slow 和 fast 均在头节点处。<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1715514553-RxQrzr-0208_2.png" alt="0208_2.png">使 slow 和 fast 同时前进，fast 的速度是 slow 的两倍。当 slow 抵达环的入口处时，fast 一定在环上，如下所示。<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1715514558-mCJsmw-0208_3.png" alt="0208_3.png">其中：</p>
<ul>
<li>head 和 A 的距离为 <em>z</em></li>
<li>弧 AB (沿箭头方向) 的长度为 <em>x</em></li>
<li>同理，弧 BA 的长度为 <em>y</em></li>
</ul>
<p>可得：</p>
<ul>
<li>slow 走过的步数为 <em>z</em></li>
<li>设 fast 已经走过了 <em>k</em> 个环，<em>k</em>≥0，对应的步数为 <em>z</em>+<em>k</em>(<em>x</em>+<em>y</em>)+<em>x</em></li>
</ul>
<p>以上两个步数中，后者为前者的两倍，即 2<em>z</em>&#x3D;<em>z</em>+<em>k</em>(<em>x</em>+<em>y</em>)+<em>x</em> 化简可得 <em>z</em>&#x3D;<em>x</em>+<em>k</em>(<em>x</em>+<em>y</em>)，替换如下所示。</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1715514562-KmTrNr-0208_4.png" alt="0208_4.png">此时因为 fast 比 slow 快 1 个单位的速度，且<em>y</em> 为整数，所以再经过 <em>y</em> 个单位的时间即可追上 slow。</p>
<p>即 slow 再走 <em>y</em> 步，fast 再走 2<em>y</em> 步。设相遇在 C 点，位置如下所示，可得弧 AC 长度为 <em>y</em>。<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1715514566-cEsEBC-0208_5.png" alt="0208_5.png">因为此前<em>x</em>+<em>y</em> 为环长，所以弧 CA 的长度为 <em>x</em>。 此时我们另用一橙色指针 ptr (pointer) 指向 head，如下所示。并使 ptr 和 slow 保持 1 个单位的速度前进，在经过 <em>z</em>&#x3D;<em>x</em>+<em>k</em>(<em>x</em>+<em>y</em>) 步后，可在 A 处相遇。<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1715514569-ATwmZT-0208_6.png" alt="0208_6.png">再考虑链表无环的情况，fast 在追到 slow 之前就会指向空节点，退出循环即可。</p>
<h3 id="进阶：链表可能有环也可能无环"><a href="#进阶：链表可能有环也可能无环" class="headerlink" title="进阶：链表可能有环也可能无环"></a>进阶：链表可能有环也可能无环</h3><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240911184007261.png" alt="image-20240911184007261"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_14_FindFirstIntersectNode</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">		<span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.value = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">loop1</span> <span class="operator">=</span> getLoopNode(head1);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">loop2</span> <span class="operator">=</span> getLoopNode(head2);</span><br><span class="line">		<span class="keyword">if</span> (loop1 == <span class="literal">null</span> &amp;&amp; loop2 == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (loop1 != <span class="literal">null</span> &amp;&amp; loop2 != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">		<span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n2.next == <span class="literal">null</span> || n2.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			n2 = n2.next.next;</span><br><span class="line">			n1 = n1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">		<span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">			n1 = n1.next;</span><br><span class="line">			n2 = n2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">			n++;</span><br><span class="line">			cur1 = cur1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">			n--;</span><br><span class="line">			cur2 = cur2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">		cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">		n = Math.abs(n);</span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">			n--;</span><br><span class="line">			cur1 = cur1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">			cur1 = cur1.next;</span><br><span class="line">			cur2 = cur2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">			cur1 = head1;</span><br><span class="line">			cur2 = head2;</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">				n++;</span><br><span class="line">				cur1 = cur1.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">				n--;</span><br><span class="line">				cur2 = cur2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">			cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">			n = Math.abs(n);</span><br><span class="line">			<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">				n--;</span><br><span class="line">				cur1 = cur1.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">				cur1 = cur1.next;</span><br><span class="line">				cur2 = cur2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cur1;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur1 = loop1.next;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">					<span class="keyword">return</span> loop1;</span><br><span class="line">				&#125;</span><br><span class="line">				cur1 = cur1.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">		head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">		head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">		head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">		head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">		head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">		head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">head2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">		head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">		head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">		head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">		System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">		head1 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">		head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">		head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">		head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">		head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">		head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">		head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">		head1.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">		head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">		head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">		head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">		head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">		System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">		head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">		head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">		head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">		head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">		System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="9-二叉树"><a href="#9-二叉树" class="headerlink" title="9. 二叉树"></a>9. 二叉树</h1><h2 id="9-1-144-二叉树的前序遍历"><a href="#9-1-144-二叉树的前序遍历" class="headerlink" title="9.1 144. 二叉树的前序遍历"></a>9.1 <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/566221642/">https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/566221642/</a></p>
<h2 id="9-2-94-二叉树的中序遍历"><a href="#9-2-94-二叉树的中序遍历" class="headerlink" title="9.2 94. 二叉树的中序遍历"></a>9.2 <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/566260507/">https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/566260507/</a></p>
<h2 id="9-3-145-二叉树的后序遍历"><a href="#9-3-145-二叉树的后序遍历" class="headerlink" title="9.3 145. 二叉树的后序遍历"></a>9.3 <a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><p>每棵子树，整棵树左边界进栈，依次弹出的过程中，打印，对弹出节点的右树重复上述操作</p>
<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/566248493/">https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/566248493/</a></p>
<h2 id="9-4-102-二叉树的层序遍历"><a href="#9-4-102-二叉树的层序遍历" class="headerlink" title="9.4 102. 二叉树的层序遍历"></a>9.4 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/566466618/">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/566466618/</a></p>
<h2 id="9-5-662-二叉树最大宽度"><a href="#9-5-662-二叉树最大宽度" class="headerlink" title="9.5 662. 二叉树最大宽度"></a>9.5 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/submissions/566748187/">https://leetcode.cn/problems/maximum-width-of-binary-tree/submissions/566748187/</a></p>
<h2 id="9-6-104-二叉树的最大深度"><a href="#9-6-104-二叉树的最大深度" class="headerlink" title="9.6 104. 二叉树的最大深度"></a>9.6 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p>非递归的解法，思路类似上面两题，此处不再赘述</p>
<h2 id="9-7-98-验证二叉搜索树"><a href="#9-7-98-验证二叉搜索树" class="headerlink" title="9.7 98. 验证二叉搜索树"></a>9.7 <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/submissions/568133510/">https://leetcode.cn/problems/validate-binary-search-tree/submissions/568133510/</a></p>
<h2 id="9-8-958-二叉树的完全性检验"><a href="#9-8-958-二叉树的完全性检验" class="headerlink" title="9.8 958. 二叉树的完全性检验"></a>9.8 <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h2><p><strong>思路：</strong></p>
<p>按照层序遍历</p>
<ol>
<li>任一节点，有右无左，返回false</li>
<li>在满足条件1的情况下，如果遇到了第一个左右子不全的节点，那么后续节点皆为叶节点</li>
</ol>
<p><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/submissions/568132810/">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/submissions/568132810/</a></p>
<h2 id="9-9-判断一颗二叉树是否是满二叉树"><a href="#9-9-判断一颗二叉树是否是满二叉树" class="headerlink" title="9.9 判断一颗二叉树是否是满二叉树"></a>9.9 判断一颗二叉树是否是满二叉树</h2><p>思路：</p>
<p>满二叉树满足 n &#x3D; 2^h - 1，其中n为节点个数，h为树的高度</p>
<p><strong>二叉树题目套路：</strong></p>
<p>递归，</p>
<p>找左树要信息（高度，节点个数），找右树也要同样的信息</p>
<p>在当前递归中也得出上述同样的信息</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240926082313050.png" alt="image-20240926082313050"></p>
<h2 id="9-10-110-平衡二叉树"><a href="#9-10-110-平衡二叉树" class="headerlink" title="9.10 110. 平衡二叉树"></a>9.10 <a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p>
<p><strong>二叉树题目套路：</strong></p>
<p>递归，</p>
<p>找左树要信息（是否为平衡二叉树，高度），找右树也要同样的信息</p>
<p>最后判断 左平衡 &amp; 右平衡 &amp; ｜左高度 - 右高度｜&lt;&#x3D; 1</p>
<p>在当前递归中也得出上述同样的信息</p>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/submissions/568138327/">https://leetcode.cn/problems/balanced-binary-tree/submissions/568138327/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    height <span class="type">int</span></span><br><span class="line">    isBalance <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    info := process(root)</span><br><span class="line">    <span class="keyword">return</span> info.isBalance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(root *TreeNode)</span></span> *nodeInfo &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;nodeInfo&#123;<span class="number">0</span>, <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lInfo := process(root.Left)</span><br><span class="line">    rInfo := process(root.Right)</span><br><span class="line"></span><br><span class="line">    height := max(lInfo.height, rInfo.height) + <span class="number">1</span></span><br><span class="line">    isBalance := lInfo.isBalance &amp;&amp; rInfo.isBalance &amp;&amp; absSub(lInfo.height, rInfo.height) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;nodeInfo&#123;height, isBalance&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">absSub</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b - a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="10-贪心算法"><a href="#10-贪心算法" class="headerlink" title="10. 贪心算法"></a>10. 贪心算法</h1><h2 id="10-1-646-最长数对链"><a href="#10-1-646-最长数对链" class="headerlink" title="10.1 646. 最长数对链"></a>10.1 <a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h2><p><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/submissions/569941794/">https://leetcode.cn/problems/maximum-length-of-pair-chain/submissions/569941794/</a></p>
<h2 id="10-2-435-无重叠区间"><a href="#10-2-435-无重叠区间" class="headerlink" title="10.2 435. 无重叠区间"></a>10.2 <a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/submissions/569955403/">https://leetcode.cn/problems/non-overlapping-intervals/submissions/569955403/</a></p>
<h1 id="11-设计"><a href="#11-设计" class="headerlink" title="11. 设计"></a>11. 设计</h1><h2 id="11-1-LRU缓存"><a href="#11-1-LRU缓存" class="headerlink" title="11.1 LRU缓存"></a>11.1 LRU缓存</h2><p><a href="https://leetcode.cn/problems/lru-cache/submissions/571650143/">https://leetcode.cn/problems/lru-cache/submissions/571650143/</a></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241010003130387.png" alt="image-20241010003130387"></p>
<p>1.为什么用双向链表而不是单向链表？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将某个节点移动到链表头部或者将链表尾部节点删去，都要用到删除链表中某个节点这个操作。你想要删除链表中的某个节点，需要找到该节点的前驱节点和后继节点。对于寻找后继节点，单向链表和双向链表都能通过 next 指针在O(1)时间内完成；对于寻找前驱节点，单向链表需要从头开始找，也就是要O(n)时间，双向链表可以通过前向指针直接找到，需要O(1)时间。综上，要想在O(1)时间内完成该操作，当然需要双向链表，实际上就是用双向链表空间换时间了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上单向链表也是可以的，代码会变得很恶心，链表头部存最少访问的元素，在map里存储对应结点的上一个结点，访问、删除时都要多更新当前元素的下一个元素</span><br></pre></td></tr></table></figure>



<p> 2.为什么链表节点需要同时存储 key 和 value，而不是仅仅只存储 value？ </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为删去最近最少使用的键值对时，要删除链表的尾节点，如果节点中没有存储 key，那么怎么知道是哪个 key 被删除，进而在 map 中删去该 key 对应的 key-value 呢？</span><br><span class="line">因为删去最近最少使用的键值对时，要删除链表的尾节点并且要删除map中的key-value，而如果尾节点没有存储key，那么就找不到要在map中删除哪个key，因此节点必须存储key。</span><br></pre></td></tr></table></figure>





<h2 id="11-2-LFU缓存"><a href="#11-2-LFU缓存" class="headerlink" title="11.2 LFU缓存"></a>11.2 LFU缓存</h2><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103141873.png" alt="image-20241011103141873" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103202673.png" alt="image-20241011103202673" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103214976.png" alt="image-20241011103214976" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103233386.png" alt="image-20241011103233386" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103243480.png" alt="image-20241011103243480" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103253836.png" alt="image-20241011103253836" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103307468.png" alt="image-20241011103307468" style="zoom:50%;">

<img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20241011103317548.png" alt="image-20241011103317548" style="zoom:50%;">

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="type">int</span></span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    freq  <span class="type">int</span></span><br><span class="line">    pre   *Node</span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    head *Node</span><br><span class="line">    tail *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size     <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    min      <span class="type">int</span></span><br><span class="line">    freqMap  <span class="keyword">map</span>[<span class="type">int</span>]*DoubleLinkedList</span><br><span class="line">    nodeMap  <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initLinkedList</span><span class="params">()</span></span> *DoubleLinkedList &#123;</span><br><span class="line">    head, tail := &amp;Node&#123;&#125;, &amp;Node&#123;&#125;</span><br><span class="line">    head.next = tail</span><br><span class="line">    tail.pre = head</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleLinkedList&#123;</span><br><span class="line">        size: <span class="number">0</span>,</span><br><span class="line">        head: head,</span><br><span class="line">        tail: tail,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LFUCache &#123;</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        size:     <span class="number">0</span>,</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        freqMap:  <span class="keyword">map</span>[<span class="type">int</span>]*DoubleLinkedList&#123;&#125;,</span><br><span class="line">        nodeMap:  <span class="keyword">map</span>[<span class="type">int</span>]*Node&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比LRU复杂的地方，在于多了freq，同freq里依然是LRU =&gt; freq map（双向链表） + 节点map</span></span><br><span class="line"><span class="comment">// GET：</span></span><br><span class="line"><span class="comment">//      1、使用节点 map 在 O(1) 取 node</span></span><br><span class="line"><span class="comment">//        2、更新 freq map，从原freq链表中删除，插入到 freq+1 的链表中</span></span><br><span class="line"><span class="comment">//        3、原 freq 变空的话，是否要更新 min freq</span></span><br><span class="line"><span class="comment">// PUT：</span></span><br><span class="line"><span class="comment">//        1、添加到节点 map、freq[1] 链表中</span></span><br><span class="line"><span class="comment">//        2、更新 min freq 为 1</span></span><br><span class="line"><span class="comment">//        3、容量满了后，删去 min freq 链表中的尾部节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, ok := this.nodeMap[key]; ok &#123;</span><br><span class="line">        this.update(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span></span> update(node *Node) &#123;</span><br><span class="line">    freq := node.freq</span><br><span class="line">    this.remove(freq, node)</span><br><span class="line">    <span class="keyword">if</span> this.min == freq &amp;&amp; this.freqMap[freq].size == <span class="number">0</span> &#123;</span><br><span class="line">        this.min += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.freq += <span class="number">1</span></span><br><span class="line">    this.insert(freq+<span class="number">1</span>, node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span></span> remove(freq <span class="type">int</span>, node *Node) &#123;</span><br><span class="line">    <span class="keyword">if</span> list, ok := this.freqMap[freq]; ok &#123;</span><br><span class="line">        <span class="comment">//    pre &lt;=&gt; node &lt;=&gt; next</span></span><br><span class="line">      	<span class="comment">//    pre &lt;=&gt; next</span></span><br><span class="line">        node.pre.next = node.next</span><br><span class="line">        node.next.pre = node.pre</span><br><span class="line">        list.size--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span></span> insert(freq <span class="type">int</span>, node *Node) &#123;</span><br><span class="line">    <span class="keyword">var</span> list *DoubleLinkedList</span><br><span class="line">    <span class="keyword">if</span> l, ok := this.freqMap[freq]; ok &#123;</span><br><span class="line">        list = l</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = initLinkedList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    head &lt;=&gt; next</span></span><br><span class="line">  	<span class="comment">//    head &lt;=&gt; node &lt;=&gt; next</span></span><br><span class="line">    head := list.head</span><br><span class="line">    next := head.next</span><br><span class="line">    node.next = next</span><br><span class="line">    next.pre = node</span><br><span class="line">    head.next = node</span><br><span class="line">    node.pre = head</span><br><span class="line">    list.size += <span class="number">1</span></span><br><span class="line">    this.freqMap[freq] = list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> this.capacity == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> node, ok := this.nodeMap[key]; ok &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">        this.update(node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(this.nodeMap) == this.capacity &#123;</span><br><span class="line">            <span class="keyword">if</span> minList, ok := this.freqMap[this.min]; ok &#123;</span><br><span class="line">                last := minList.tail.pre</span><br><span class="line">                this.remove(this.min, last)</span><br><span class="line">                <span class="built_in">delete</span>(this.nodeMap, last.key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node := &amp;Node&#123;</span><br><span class="line">            key:   key,</span><br><span class="line">            value: value,</span><br><span class="line">            freq:  <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        this.insert(<span class="number">1</span>, node)</span><br><span class="line">        this.nodeMap[key] = node</span><br><span class="line">        this.min = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>golang面试</title>
    <url>/2024/08/29/golang%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://www.golangroadmap.com/docs/books/interviewPresentation.html">https://www.golangroadmap.com/docs/books/interviewPresentation.html</a></p>
<h1 id="第一章：Go基础"><a href="#第一章：Go基础" class="headerlink" title="第一章：Go基础"></a>第一章：Go基础</h1><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20240806153214592.png" alt="image-20240806153214592"></p>
<h2 id="1-Golang-面向对象"><a href="#1-Golang-面向对象" class="headerlink" title="1. Golang 面向对象"></a>1. Golang 面向对象</h2><h3 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h3><h4 id="1-1-1-封装的好处"><a href="#1-1-1-封装的好处" class="headerlink" title="1.1.1 封装的好处"></a>1.1.1 封装的好处</h4><ol>
<li>隐藏实现细节</li>
<li>可以对输入的数据进行验证，保证数据的安全性和合理性。例如通过 SetAge(age int) 方法实现对 age 的封装，在修改age属性前加上数据类型判断，范围合理性判断等，可以防止直接修改结构体的 age 属性。</li>
</ol>
<h4 id="1-1-2-封装的实现步骤"><a href="#1-1-2-封装的实现步骤" class="headerlink" title="1.1.2 封装的实现步骤"></a>1.1.2 封装的实现步骤</h4><ol>
<li>将结构体、字段(属性)的首字母小写(不能导出了，其他包不能使用，类似 private)</li>
<li>给结构体所在包提供一个首字母大写的函数。类似一个构造函数</li>
<li>提供一个首字母大写的 Set 方法(类似其他语言的 public)，用于对属性进行判断并赋值<br>func (var 结构体类型名) SetXxx(参数列表)(返回值列表) {<br>    <strong>&#x2F;&#x2F;加入数据验证的业务逻辑</strong><br>    var.字段 &#x3D; 参数<br>}</li>
<li>提供一个首字母大写的 Get 方法(类似其他语言的 public)，用于获取属性的值<br>func (var 结构体类型名) GetXxx() {<br>    return var.age;<br>}</li>
</ol>
<h4 id="1-1-3-示例"><a href="#1-1-3-示例" class="headerlink" title="1.1.3 示例"></a>1.1.3 示例</h4><p>model&#x2F;person.go</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241004231449196.png" alt="image-20241004231449196"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241004231516951.png" alt="image-20241004231516951"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241004231539036.png" alt="image-20241004231539036"></p>
<h3 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2 继承"></a>1.2 继承</h3><h4 id="1-2-1-继承的好处"><a href="#1-2-1-继承的好处" class="headerlink" title="1.2.1 继承的好处"></a>1.2.1 继承的好处</h4><p>解决代码冗余的问题，提高代码的可复用性和可拓展性以及可维护性。</p>
<h4 id="1-2-2-继承的实现步骤"><a href="#1-2-2-继承的实现步骤" class="headerlink" title="1.2.2 继承的实现步骤"></a>1.2.2 继承的实现步骤</h4><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241004232933259.png" alt="image-20241004232933259"></p>
<h4 id="1-2-3-继承的深入讨论"><a href="#1-2-3-继承的深入讨论" class="headerlink" title="1.2.3 继承的深入讨论"></a>1.2.3 继承的深入讨论</h4><p> <a href="../../../Desktop/golang/%E7%AC%94%E8%AE%B0/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E9%9F%A9%E9%A1%BA%E5%B9%B3_Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.pdf">尚硅谷_韩顺平_Go语言核心编程.pdf</a>   见 315 页</p>
<h3 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Camera start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Camera stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">	price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Phone start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Phone stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口类型 USB 作为参数，不需要指针（写成 *USB 会报错），因为接口类型本身就是引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span></span> Working(usb USB) &#123;</span><br><span class="line">	usb.Start()</span><br><span class="line">	usb.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	camera := &amp;Camera&#123;&#125;</span><br><span class="line">	phone := &amp;Phone&#123;&#125;</span><br><span class="line">	computer := &amp;Computer&#123;&#125;</span><br><span class="line"></span><br><span class="line">	computer.Working(camera)</span><br><span class="line">	computer.Working(phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="2-go方法与函数的区别"><a href="#2-go方法与函数的区别" class="headerlink" title="2. go方法与函数的区别"></a>2. go方法与函数的区别</h2><ul>
<li>函数是指不属于任何结构体、类型的方法，也就是说函数是没有接收者的</li>
<li>方法是有接收者的。</li>
<li>方法只能通过指定的接受者的类型来调用，不能直接调用方法，也不能通过其他类型来调用方法。</li>
<li>接受者调用方法时，接受者本身也会作为参数传递到方法，在方法内部可以使用接受者。</li>
</ul>
<h2 id="3-Go-方法值接收者和指针接收者的区别"><a href="#3-Go-方法值接收者和指针接收者的区别" class="headerlink" title="3. Go 方法值接收者和指针接收者的区别?"></a>3. Go 方法值接收者和指针接收者的区别?</h2><p>如果方法的接收者是指针类型，无论调用者是对象还是对象指针，修改的都是对象本身，会影响调用者；</p>
<p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了接收者是指针类型的方法，会隐含地也实现了接收者是值类型的IncrAge1方法。</span></span><br><span class="line"><span class="comment">// 会修改age的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> IncrAge1() &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的IncrAge2方法。</span></span><br><span class="line"><span class="comment">// 不会修改age的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> IncrAge2() &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的GetAge方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// p1 是值类型</span></span><br><span class="line">	p := Person&#123;age: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">	p.IncrAge1()</span><br><span class="line">	fmt.Println(p.GetAge())</span><br><span class="line">	<span class="comment">// 值类型 调用接收者是值类型的方法</span></span><br><span class="line">	p.IncrAge2()</span><br><span class="line">	fmt.Println(p.GetAge())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// p2 是指针类型</span></span><br><span class="line">	p2 := &amp;Person&#123;age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用接收者是指针类型的方法</span></span><br><span class="line">	p2.IncrAge1()</span><br><span class="line">	fmt.Println(p2.GetAge())</span><br><span class="line">	<span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">	p2.IncrAge2()</span><br><span class="line">	fmt.Println(p2.GetAge())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中：</p>
<p>实现了接收者是指针类型的 IncrAge1 函数，不管调用者是值类型还是指针类型，都可以调用IncrAge1方法，并且它的 age 值都改变了。</p>
<p>实现了接收者是指针类型的 IncrAge2 函数，不管调用者是值类型还是指针类型，都可以调用IncrAge2方法，并且它的 age 值都没有被改变。</p>
<p>通常我们使用<strong>指针类型作为方法的接收者的理由</strong>：</p>
<ul>
<li>使用指针类型能够修改调用者的值。</li>
<li>使用指针类型可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<h2 id="4-Go-函数返回局部变量的指针是否安全"><a href="#4-Go-函数返回局部变量的指针是否安全" class="headerlink" title="4. Go 函数返回局部变量的指针是否安全?"></a>4. Go 函数返回局部变量的指针是否安全?</h2><p>一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p>
<p>但这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">res = x + y</span><br><span class="line"><span class="keyword">return</span> &amp;res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中，函数 <code>add</code> 局部变量 <code>res</code> 发生了逃逸。res作为返回值，在 main 函数中继续使用，因此 res 指向的内存不能够分配在栈上，随着函数结束而回收，只能分配在堆上。</p>
<p>编译时可以借助选项 <code>-gcflags=-m</code>，查看变量逃逸的情况</p>
<p><code>go run -gcflags=&quot;-m -m -l&quot; hello.go </code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./main.go:6:2: res escapes to heap:</span><br><span class="line">./main.go:6:2:   flow: ~r2 = &amp;res:</span><br><span class="line">./main.go:6:2:     from &amp;res (address-of) at ./main.go:8:9</span><br><span class="line">./main.go:6:2:     from return &amp;res (return) at ./main.go:8:2</span><br><span class="line">./main.go:6:2: moved to heap: res</span><br><span class="line">./main.go:12:13: ... argument does not escape</span><br><span class="line">0xc0000ae008</span><br></pre></td></tr></table></figure>

<p><code>res escapes to heap</code> 即表示 <code>res</code> 逃逸到堆上了。</p>
<h2 id="5-Go-函数参数传递到底是值传递还是引用传递？"><a href="#5-Go-函数参数传递到底是值传递还是引用传递？" class="headerlink" title="5. Go 函数参数传递到底是值传递还是引用传递？"></a>5. Go 函数参数传递到底是值传递还是引用传递？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、go只有值传递，没有引用传递</span><br><span class="line">2、如果参数是引用类型的话，比如slice,map,chan等函数内部对形参的修改会影响到外部的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go都是值传递；也就是实参赋值给形参，都是复制一份；</span><br><span class="line">引用类型和引用传递是2个概念；go没有引用传递；</span><br><span class="line">引用类型仅复制元数据，没有复制底层数据；</span><br><span class="line">所以在函数内，修改切片的内容（也就是修改底层数据），实参也跟着修改；</span><br><span class="line">若在函数内部使用append可能导致实参和形参事两个不同的底层数组；</span><br><span class="line">Go语言是没有引用传递的，在C++中，函数参数的传递方式有引用传递。</span><br></pre></td></tr></table></figure>



<h2 id="6-Go-defer关键字的实现原理？"><a href="#6-Go-defer关键字的实现原理？" class="headerlink" title="6. Go defer关键字的实现原理？"></a>6. Go defer关键字的实现原理？</h2><p><strong>定义</strong>：</p>
<p>1、defer是一种延迟处理机制，是在函数进行return之前进行执行。</p>
<p>2、defer是采用栈的方式执行，也就是说先定义的defer后执行，后定义的defer最先被执行。</p>
<p>3、defer 能够让我们推迟执行某些函数调用，推迟到当前函数<strong>返回前</strong>才实际执行。defer与panic和recover结合，形成了Go语言风格的异常与捕获机制。</p>
<p><strong>使用场景</strong>：</p>
<p>defer 语句经常被用于处理成对的操作，如文件句柄关闭、连接关闭、释放锁</p>
<p><strong>优点：</strong></p>
<p>方便开发者使用</p>
<p><strong>缺点：</strong></p>
<p>有性能损耗</p>
<p><strong>实现原理</strong>：</p>
<p>Go1.14中编译器会将defer函数直接插入到函数的尾部，无需链表和栈上参数拷贝，性能大幅提升。把defer函数在当前函数内展开并直接调用，这种方式被称为open coded defer</p>
<p>源代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">defer</span> A2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m,n <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后（伪代码）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// code to do something</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       A2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    A1(i, <span class="number">2</span>*i)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<ol>
<li>函数退出前，按照先进后出的顺序，执行defer函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// defer：延迟函数执行，先进后出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer3&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer4&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;11111&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11111</span></span><br><span class="line"><span class="comment">// defer4</span></span><br><span class="line"><span class="comment">// defer3</span></span><br><span class="line"><span class="comment">// defer2</span></span><br><span class="line"><span class="comment">// defer1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>panic后的defer函数不会被执行（遇到panic，如果没有捕获错误，函数会立刻终止）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// panic后的defer函数不会被执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;panic before&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;发生panic&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;panic after&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic before</span></span><br><span class="line"><span class="comment">// panic: 发生panic</span></span><br></pre></td></tr></table></figure>

<ol>
<li>panic没有被recover时，抛出的panic到当前goroutine最上层函数时，最上层程序直接异常终止</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子函数抛出的panic没有recover时，上层函数时，程序直接异常终止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    F()</span><br><span class="line">    fmt.Println(<span class="string">&quot;继续执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// panic: a</span></span><br></pre></td></tr></table></figure>

<ol>
<li>panic有被recover时，当前goroutine最上层函数正常执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;捕获异常:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    F()</span><br><span class="line">    fmt.Println(<span class="string">&quot;继续执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获异常: a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// 继续执行</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p><a href="https://www.cnblogs.com/welan/p/16330678.html">https://www.cnblogs.com/welan/p/16330678.html</a></p>
<h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包&#x3D;函数+引用环境)。</p>
<h3 id="Go中的闭包"><a href="#Go中的闭包" class="headerlink" title="Go中的闭包"></a>Go中的闭包</h3><p>闭包是函数式语言中的概念，没有研究过函数式语言的用户可能很难理解闭包的强大，相关的概念超出了本书的范围。Go语言是支持闭包的，这里只是简单地讲一下在Go语言中闭包是如何实现的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数f返回了一个函数，返回的这个函数，返回的这个函数就是一个闭包。这个函数中本身是没有定义变量i的，而是引用了它所在的环境（函数f）中的变量i。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := f(<span class="number">0</span>)</span><br><span class="line">c2 := f(<span class="number">0</span>)</span><br><span class="line">c1()    <span class="comment">// reference to i, i = 0, return 1</span></span><br><span class="line">c2()    <span class="comment">// reference to another i, i = 0, return 1</span></span><br></pre></td></tr></table></figure>

<p>c1跟c2引用的是不同的环境，在调用i++时修改的不是同一个i，因此两次的输出都是1。函数f每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。</p>
<p>变量i是函数f中的局部变量，假设这个变量是在函数f的栈中分配的，是不可以的。因为函数f返回以后，对应的栈就失效了，f返回的那个函数中变量i就引用一个失效的位置了。所以闭包的环境中引用的变量不能够在栈上分配。</p>
<h3 id="escape-analyze"><a href="#escape-analyze" class="headerlink" title="escape analyze"></a>escape analyze</h3><p>在继续研究闭包的实现之前，先看一看Go的一个语言特性：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> *Cursor &#123;</span><br><span class="line">    <span class="keyword">var</span> c Cursor</span><br><span class="line">    c.X = <span class="number">500</span></span><br><span class="line">    noinline()</span><br><span class="line">    <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cursor是一个结构体，这种写法在C语言中是不允许的，因为变量c是在栈上分配的，当函数f返回后c的空间就失效了。但是，在Go语言规范中有说明，这种写法在Go语言中合法的。语言会自动地识别出这种情况并在堆上分配c的内存，而不是函数f的栈上。</p>
<p>为了验证这一点，可以观察函数f生成的汇编代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVQ    <span class="variable">$type</span>.<span class="string">&quot;&quot;</span>.Cursor+0(SB),(SP)    // 取变量c的类型，也就是Cursor</span><br><span class="line">PCDATA    <span class="variable">$0</span>,<span class="variable">$16</span></span><br><span class="line">PCDATA    <span class="variable">$1</span>,<span class="variable">$0</span></span><br><span class="line">CALL    ,runtime.new(SB)    // 调用new函数，相当于new(Cursor)</span><br><span class="line">PCDATA    <span class="variable">$0</span>,$-1</span><br><span class="line">MOVQ    8(SP),AX    // 取c.X的地址放到AX寄存器</span><br><span class="line">MOVQ    <span class="variable">$500</span>,(AX)    // 将AX存放的内存地址的值赋为500</span><br><span class="line">MOVQ    AX,<span class="string">&quot;&quot;</span>.~r0+24(FP)</span><br><span class="line">ADDQ    <span class="variable">$16</span>,SP</span><br></pre></td></tr></table></figure>

<p>识别出变量需要在堆上分配，是由编译器的一种叫escape analyze的技术实现的。如果输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go build --gcflags=-m main.go</span><br></pre></td></tr></table></figure>

<p>可以看到输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./main.go:20: moved to heap: c</span><br><span class="line">./main.go:23: &amp;c escapes to heap</span><br></pre></td></tr></table></figure>

<p>表示c逃逸了，被移到堆中。escape analyze可以分析出变量的作用范围，这是对垃圾回收很重要的一项技术。</p>
<h3 id="闭包结构体"><a href="#闭包结构体" class="headerlink" title="闭包结构体"></a>闭包结构体</h3><p>回到闭包的实现来，前面说过，闭包是函数和它所引用的环境。那么是不是可以表示为一个结构体呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Closure struct &#123;</span><br><span class="line">    F func()() </span><br><span class="line">    i *int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，Go在底层确实就是这样表示一个闭包的。让我们看一下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func f(i int) func() int &#123;</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i++</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MOVQ    $type.int+0(SB),(SP)</span><br><span class="line">PCDATA    $0,$16</span><br><span class="line">PCDATA    $1,$0</span><br><span class="line">CALL    ,runtime.new(SB)    // 是不是很熟悉，这一段就是i = new(int)    </span><br><span class="line">...    </span><br><span class="line">MOVQ    $type.struct &#123; F uintptr; A0 *int &#125;+0(SB),(SP)    // 这个结构体就是闭包的类型</span><br><span class="line">...</span><br><span class="line">CALL    ,runtime.new(SB)    // 接下来相当于 new(Closure)</span><br><span class="line">PCDATA    $0,$-1</span><br><span class="line">MOVQ    8(SP),AX</span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    $&quot;&quot;.func·001+0(SB),BP</span><br><span class="line">MOVQ    BP,(AX)                // 函数地址赋值给Closure的F部分</span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    &quot;&quot;.&amp;i+16(SP),BP        // 将堆中new的变量i的地址赋值给Closure的值部分</span><br><span class="line">MOVQ    BP,8(AX)</span><br><span class="line">MOVQ    AX,&quot;&quot;.~r1+40(FP)</span><br><span class="line">ADDQ    $24,SP</span><br><span class="line">RET    ,</span><br></pre></td></tr></table></figure>

<p>其中func·001是另一个函数的函数地址，也就是f返回的那个函数。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>Go语言支持闭包</li>
<li>Go语言能通过escape analyze识别出变量的作用域，自动将变量在堆上分配。将闭包环境变量在堆上分配是Go实现闭包的基础。</li>
<li>返回闭包时并不是单纯返回一个函数，而是返回了一个结构体，记录下函数返回地址和引用的环境中的变量地址。</li>
</ol>
<h2 id="8-golang空结构体的使用场景"><a href="#8-golang空结构体的使用场景" class="headerlink" title="8. golang空结构体的使用场景"></a>8. golang空结构体的使用场景</h2><p><a href="https://geektutu.com/post/hpg-empty-struct.html">https://geektutu.com/post/hpg-empty-struct.html</a></p>
<h2 id="9-golang中空接口的使用场景"><a href="#9-golang中空接口的使用场景" class="headerlink" title="9. golang中空接口的使用场景"></a>9. golang中空接口的使用场景</h2><p><a href="https://cloud.tencent.com/developer/article/1482645">https://cloud.tencent.com/developer/article/1482645</a></p>
<h1 id="第二章：Slice"><a href="#第二章：Slice" class="headerlink" title="第二章：Slice"></a>第二章：Slice</h1><h2 id="1-Go-slice的底层实现原理"><a href="#1-Go-slice的底层实现原理" class="headerlink" title="1.Go slice的底层实现原理?"></a>1.Go slice的底层实现原理?</h2><p>切片是基于数组实现的，它的底层是数组，可以理解为对 底层数组的抽象。</p>
<p>源码包中src&#x2F;runtime&#x2F;slice.go 定义了slice的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice占用24个字节</p>
<p>array: 指向底层数组的指针，占用8个字节</p>
<p>len: 切片的长度，占用8个字节</p>
<p>cap: 切片的容量，cap 总是大于等于 len 的，占用8个字节</p>
<p>slice有4种初始化方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化方式1：直接声明</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2：使用字面量</span></span><br><span class="line">slice2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式3：使用make创建slice</span></span><br><span class="line">slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式4: 从切片或数组“截取”</span></span><br><span class="line">slcie4 := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>通过一个简单程序，看下slice初始化调用的底层函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>go tool compile -S test.go | grep CALL</code> 得到汇编代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)</span><br><span class="line">0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)</span><br><span class="line">0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)</span><br><span class="line">0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)</span><br><span class="line">0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)</span><br><span class="line">0x0166 00358 (<span class="variable">$GOROOT</span>/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)</span><br><span class="line">0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x0079 00121 (&lt;autogenerated&gt;:1)        CALL    runtime.efaceeq(SB)</span><br><span class="line">0x00a0 00160 (&lt;autogenerated&gt;:1)        CALL    runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure>

<p>初始化slice调用的是runtime.makeslice，makeslice函数的工作主要就是计算slice所需内存大小，然后调用mallocgc进行内存的分配</p>
<p>所需内存大小 &#x3D; 切片中元素大小 * 切片的容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line">        <span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line">        <span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line">        <span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">        <span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">        mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Go-array和slice的区别？"><a href="#2-Go-array和slice的区别？" class="headerlink" title="2.Go array和slice的区别？"></a>2.Go array和slice的区别？</h2><p><a href="https://golang.design/go-questions/slice/vs-array/">https://golang.design/go-questions/slice/vs-array/</a></p>
<h2 id="3-Go-slice深拷贝和浅拷贝"><a href="#3-Go-slice深拷贝和浅拷贝" class="headerlink" title="3.Go slice深拷贝和浅拷贝"></a>3.Go slice深拷贝和浅拷贝</h2><hr>
<p>深拷贝：拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值</p>
<p>实现深拷贝的方式：</p>
<ol>
<li>copy(slice2, slice1)</li>
<li>遍历append赋值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice1: %v, %p\n&quot;</span>, slice1, slice1)</span><br><span class="line">    <span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice2: %v, %p\n&quot;</span>, slice2, slice2)</span><br><span class="line">    slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">        slice3 = <span class="built_in">append</span>(slice3, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice3: %v, %p\n&quot;</span>, slice3, slice3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice1: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0030</span></span><br><span class="line">slice2: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0060</span></span><br><span class="line">slice3: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0090</span></span><br></pre></td></tr></table></figure>

<p>浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化</p>
<p>实现浅拷贝的方式：</p>
<p>引用类型的变量，默认赋值操作就是浅拷贝</p>
<ol>
<li>slice2 :&#x3D; slice1</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice1: %v, %p\n&quot;</span>, slice1, slice1)</span><br><span class="line">    slice2 := slice1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice2: %v, %p\n&quot;</span>, slice2, slice2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice1: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc00001a120</span></span><br><span class="line">slice2: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc00001a120</span></span><br></pre></td></tr></table></figure>



<h2 id="4-Go-slice扩容机制？"><a href="#4-Go-slice扩容机制？" class="headerlink" title="4.Go slice扩容机制？"></a>4.Go slice扩容机制？</h2><p>扩容会发生在slice append的时候，当slice的cap不足以容纳新元素，就会进行扩容，扩容规则如下</p>
<ul>
<li>如果新申请容量比两倍原有容量大，那么扩容后容量大小 为 新申请容量</li>
<li>如果原有 slice 长度小于 1024， 那么每次就扩容为原来的 2 倍</li>
<li>如果原 slice 长度大于等于 1024， 那么每次扩容就扩为原来的 1.25 倍</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">        slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;addr: %p, len: %v, cap: %v\n&quot;</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addr: 0xc00001a120, len: 4, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc00001a120, len: 5, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc00001a120, len: 6, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc000060060, len: 7, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 8, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 9, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 10, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 11, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 12, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc00007c000, len: 13, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 14, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 15, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 16, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 17, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 18, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 19, <span class="built_in">cap</span>: 24</span><br></pre></td></tr></table></figure>

<h2 id="5-Go-slice为什么不是线程安全的？"><a href="#5-Go-slice为什么不是线程安全的？" class="headerlink" title="5.Go slice为什么不是线程安全的？"></a>5.Go slice为什么不是线程安全的？</h2><p><strong>先看下线程安全的定义</strong>：</p>
<p>多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>再看Go语言实现线程安全常用的几种方式</strong>：</p>
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>原子操作</li>
<li>sync.once</li>
<li>sync.atomic</li>
<li>channel</li>
</ol>
<p>slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 切片非并发安全</span></span><br><span class="line"><span class="comment">* 多次执行，每次得到的结果都不一样</span></span><br><span class="line"><span class="comment">* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSliceConcurrencySafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   a = <span class="built_in">append</span>(a, i)</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> t.Log(<span class="built_in">len</span>(a)) </span><br><span class="line"> <span class="comment">// not equal 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-几道题"><a href="#6-几道题" class="headerlink" title="6. 几道题"></a>6. 几道题</h2><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241013205616402.png" alt="image-20241013205616402"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241013205650430.png" alt="image-20241013205650430"></p>
<img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241013210124956.png" alt="image-20241013210124956" style="zoom: 25%;">

<img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241013210150686.png" alt="image-20241013210150686" style="zoom:25%;">

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicePrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">3</span>)</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	sliceRise(s1)</span><br><span class="line">	sliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slicePrint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicePrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">//s1 = append(s1, 3)   注释掉这行，输出什么？</span></span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	sliceRise(s1)</span><br><span class="line">	sliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slicePrint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第三章：Map"><a href="#第三章：Map" class="headerlink" title="第三章：Map"></a>第三章：Map</h1><h2 id="1-Go-map的底层实现原理？"><a href="#1-Go-map的底层实现原理？" class="headerlink" title="1.Go map的底层实现原理？"></a>1.Go map的底层实现原理？</h2><p>Go中的map是一个指针，占用8个字节，指向hmap结构体</p>
<p>源码包中<code>src/runtime/map.go</code>定义了hmap的数据结构：</p>
<p>hmap包含若干个结构为bmap的数组，每个bmap底层都采用链表结构，bmap通常叫其bucket</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640.png" alt="图片"></p>
<p><strong>hmap结构体</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int </span><br><span class="line">    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。</span><br><span class="line">    flags     uint8 </span><br><span class="line">    // 状态标志（是否处于正在写入的状态等）</span><br><span class="line">    B         uint8  </span><br><span class="line">    // buckets（桶）的对数</span><br><span class="line">    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶</span><br><span class="line">    noverflow uint16 </span><br><span class="line">    // 溢出桶的数量</span><br><span class="line">    hash0     uint32 </span><br><span class="line">    // 生成hash的随机数种子</span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。</span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。</span><br><span class="line">    nevacuate  uintptr        </span><br><span class="line">    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。</span><br><span class="line">    extra *mapextra </span><br><span class="line">    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>bmap结构体</strong></p>
<p><code>bmap</code> 就是我们常说的“桶”，一个桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果的低B位是相同的，关于key的定位我们在map的查询中详细说明。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置)。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [bucketCnt]uint8        </span><br><span class="line">    // len为8的数组</span><br><span class="line">    // 用来快速定位key是否在这个bmap中</span><br><span class="line">    // 一个桶最多8个槽位，如果key所在的tophash值在tophash中，则代表该key在这个桶中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面bmap结构是静态结构，在编译过程中<code>runtime.bmap</code>会拓展成以下结构体：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type bmap struct&#123;</span><br><span class="line">    tophash [8]uint8</span><br><span class="line">    keys [8]keytype </span><br><span class="line">    // keytype 由编译器编译时候确定</span><br><span class="line">    values [8]elemtype </span><br><span class="line">    // elemtype 由编译器编译时候确定</span><br><span class="line">    overflow uintptr </span><br><span class="line">    // overflow指向下一个bmap，overflow是uintptr而不是*bmap类型，保证bmap完全不含指针，是为了减少gc，溢出桶存储到extra字段中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tophash就是用于实现快速定位key的位置，在实现过程中会使用key的hash值的高8位作为tophash值，存放在bmap的tophash字段中</p>
<p>tophash字段不仅存储key哈希值的高8位，还会存储一些状态值，用来表明当前桶单元状态，这些状态值都是小于minTopHash的</p>
<p>为了避免key哈希值的高8位值和这些状态值相等，产生混淆情况，所以当key哈希值高8位若小于minTopHash时候，自动将其值加上minTopHash作为该key的tophash。桶单元的状态值如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">emptyRest      = 0 // 表明此桶单元为空，且更高索引的单元也是空</span><br><span class="line">emptyOne       = 1 // 表明此桶单元为空</span><br><span class="line">evacuatedX     = 2 // 用于表示扩容迁移到新桶前半段区间</span><br><span class="line">evacuatedY     = 3 // 用于表示扩容迁移到新桶后半段区间</span><br><span class="line">evacuatedEmpty = 4 // 用于表示此单元已迁移</span><br><span class="line">minTopHash     = 5 // key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值</span><br><span class="line"></span><br><span class="line">func tophash(hash uintptr) uint8 &#123;</span><br><span class="line">    top := uint8(hash &gt;&gt; (goarch.PtrSize*8 - 8))</span><br><span class="line">    if top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    return top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mapextra结构体</strong></p>
<p>当map的key和value都不是指针类型时候，bmap将完全不包含指针，那么gc时候就不用扫描bmap。bmap指向溢出桶的字段overflow是uintptr类型，为了防止这些overflow桶被gc掉，所以需要mapextra.overflow将它保存起来。如果bmap的overflow是*bmap类型，那么gc扫描的是一个个拉链表，效率明显不如直接扫描一段内存(hmap.mapextra.overflow)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type mapextra struct &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets</span><br><span class="line">    oldoverflow *[]*bma</span><br><span class="line">   // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket</span><br><span class="line">    nextOverflow *bmap </span><br><span class="line">     // 指向空闲的 overflow bucket 的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>bmap（bucket）内存数据结构可视化如下:</p>
<p>注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式，当key和value类型不一样的时候，key和value占用字节大小不一样，使用key&#x2F;value这种形式可能会因为内存对齐导致内存空间浪费，所以Go采用key和value分开存储的设计，更节省内存空间</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640-20220309173633627.png" alt="图片"></p>
<h2 id="2-Go-map遍历为什么是无序的？"><a href="#2-Go-map遍历为什么是无序的？" class="headerlink" title="2.Go map遍历为什么是无序的？"></a>2.Go map遍历为什么是无序的？</h2><p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序</p>
<p>主要原因有2点：</p>
<ul>
<li>map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个<strong>随机值序号的bucket</strong>，再从其中<strong>随机的cell</strong>开始遍历</li>
<li>map遍历时，是按序遍历bucket，同时按需遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个bucket中的key，搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了</li>
</ul>
<p>map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMapRange</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    t.Log(<span class="string">&quot;first range:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        t.Logf(<span class="string">&quot;m[%v]=%v &quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Log(<span class="string">&quot;\nsecond range:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        t.Logf(<span class="string">&quot;m[%v]=%v &quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现有序遍历</span></span><br><span class="line">    <span class="keyword">var</span> sl []<span class="type">int</span></span><br><span class="line">    <span class="comment">// 把 key 单独取出放到切片</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        sl = <span class="built_in">append</span>(sl, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序切片</span></span><br><span class="line">    sort.Ints(sl)</span><br><span class="line">    <span class="comment">// 以切片中的 key 顺序遍历 map 就是有序的了</span></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> sl &#123;</span><br><span class="line">        t.Log(k, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Go-map为什么是非线程安全的？"><a href="#3-Go-map为什么是非线程安全的？" class="headerlink" title="3.Go map为什么是非线程安全的？"></a>3.Go map为什么是非线程安全的？</h2><p>map默认是并发不安全的，同时对map进行并发读写时，程序会panic，原因如下：</p>
<p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p>
<p>场景: 2个协程同时读和写，以下程序会出现致命错误：fatal error: concurrent map writes</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            s[i] = i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;map第%d个元素值是%d\n&quot;</span>, i, s[i])</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想实现map线程安全，有两种方式：</p>
<p>方式一：使用读写锁 <code>map</code> + <code>sync.RWMutex</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line">    s := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.Lock()</span><br><span class="line">            s[i] = i</span><br><span class="line">            lock.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.RLock()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;map第%d个元素值是%d\n&quot;</span>, i, s[i])</span><br><span class="line">            lock.RUnlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：使用Go提供的 <code>sync.Map</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Map</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            m.Store(i, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            v, ok := m.Load(i)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Load: %v, %v\n&quot;</span>, v, ok)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Go-map如何查找？"><a href="#4-Go-map如何查找？" class="headerlink" title="4.Go map如何查找？"></a>4.Go map如何查找？</h2><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带 comma 用法</span></span><br><span class="line">value := m<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span></span><br><span class="line">fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value:%s&quot;</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 comma 用法</span></span><br><span class="line">value, ok := m<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value:%s&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map的查找通过生成汇编码可以知道，根据 key 的不同类型&#x2F;返回参数，编译器会将查找函数用更具体的函数替换，以优化效率：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">查找</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapaccess1_fast32(t <em>maptype, h</em> hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">mapaccess2_fast32(t <em>maptype, h</em> hmap, key uint32) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapaccess1_fast64(t <em>maptype, h</em> hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapaccess2_fast64(t <em>maptype, h</em> hmap, key uint64) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapaccess1_faststr(t <em>maptype, h</em> hmap, ky string) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapaccess2_faststr(t <em>maptype, h</em> hmap, ky string) (unsafe.Pointer, bool)</td>
</tr>
</tbody></table>
<h3 id="查找流程"><a href="#查找流程" class="headerlink" title="#查找流程"></a><a href="https://vip.golangroadmap.com/class/gointerview/3-4.html#%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B">#</a><strong>查找流程</strong></h3><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220117201006909.png" alt="img"></p>
<ol>
<li><strong>写保护监测</strong></li>
</ol>
<p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic，这也说明了 map 不是线程安全的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>计算hash值</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br></pre></td></tr></table></figure>



<p>key经过哈希函数计算后，得到的哈希值如下（主流64位机下共 64 个 bit 位）， 不同类型的key会有不同的hash函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>找到hash对应的bucket</strong></li>
</ol>
<p>bucket定位：<strong>哈希值的低B个bit 位</strong>，用来定位key所存放的bucket</p>
<p>如果当前正在扩容中，并且定位到的旧bucket数据还未完成迁移，则使用旧的bucket（扩容前的bucket）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"><span class="comment">// 桶的个数m-1，即 1&lt;&lt;B-1,B=5时，则有0~31号桶</span></span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line"><span class="comment">// 计算哈希值对应的bucket</span></span><br><span class="line"><span class="comment">// t.bucketsize为一个bmap的大小，通过对哈希值和桶个数取模得到桶编号，通过对桶编号和buckets起始地址进行运算，获取哈希值对应的bucket</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">// 是否在扩容</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 桶个数已经发生增长一倍，则旧bucket的桶个数为当前桶个数的一半</span></span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值对应的旧bucket</span></span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 如果旧bucket的数据没有完成迁移，则使用旧bucket查找</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">        b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 遍历bucket查找</strong></p>
<p>tophash值定位：<strong>哈希值的高8个bit 位</strong>，用来快速判断key是否已在当前bucket中（如果不在的话，需要去bucket的overflow中查找）</p>
<p>用步骤2中的hash值，得到高8个bit位，也就是<code>10010111</code>，转化为十进制，也就是<strong>151</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">top := tophash(hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数中hash是64位的，sys.PtrSize值是8，所以<code>top := uint8(hash &gt;&gt; (sys.PtrSize*8 - 8))</code>等效<code>top = uint8(hash &gt;&gt; 56)</code>，最后top取出来的值就是hash的高8位值</p>
<p>在 bucket 及bucket的overflow中寻找<strong>tophash 值（HOB hash）为 151* 的 槽位</strong>，即为key所在位置，找到了空槽位或者 2 号槽位，这样整个查找过程就结束了，其中找到空槽位代表没找到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">              <span class="comment">// 未被使用的槽位，插入</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到tophash值对应的的key</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/f39e10e1474fda593cbca86eb0c517e2.png" alt="img"></p>
<p><strong>5. 返回key对应的指针</strong></p>
<p>如果通过上面的步骤找到了key对应的槽位下标 i，我们再详细分析下key&#x2F;value值是如何获取的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keys的偏移量</span></span><br><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span>&#123;</span><br><span class="line">  b bmap</span><br><span class="line">  v <span class="type">int64</span></span><br><span class="line">&#125;&#123;&#125;.v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个bucket的元素个数</span></span><br><span class="line">bucketCnt = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 定位公式</span></span><br><span class="line">k :=add(unsafe.Pointer(b),dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 定位公式</span></span><br><span class="line">v:= add(unsafe.Pointer(b),dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br></pre></td></tr></table></figure>

<p>bucket 里 keys 的起始地址就是 unsafe.Pointer(b)+dataOffset</p>
<p>第 i 个下标 key 的地址就要在此基础上跨过 i 个 key 的大小；</p>
<p>而我们又知道，value 的地址是在所有 key 之后，因此第 i 个下标 value 的地址还需要加上所有 key 的偏移。</p>
<h2 id="5-Go-map冲突的解决方式？"><a href="#5-Go-map冲突的解决方式？" class="headerlink" title="5.Go map冲突的解决方式？"></a>5.Go map冲突的解决方式？</h2><p>比较常用的Hash冲突解决方案有链地址法和开放寻址法：</p>
<p><strong>链地址法</strong></p>
<p>当哈希冲突发生时，创建新<strong>单元</strong>，并将新单元添加到冲突单元所在链表的尾部。</p>
<p><strong>开放寻址法</strong></p>
<p>当哈希冲突发生时，从发生冲突的那个<strong>单元</strong>起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。<strong>开放寻址法需要的表长度要大于等于所需要存放的元素数量</strong></p>
<p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。这里以线性探测法来帮助读者理解开放寻址法思想</p>
<p><strong>线性探测法</strong></p>
<p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值， 表示哈希表的槽位数（哈希表的大小）。</p>
<p>线性探测法则可以表示为：</p>
<p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p>
<p><strong>两种解决方案比较</strong></p>
<p>对于链地址法，基于数组 + 链表进行存储，链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。</p>
<p>对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。<strong>当数据量明确、装载因子小，适合采用开放寻址法。</strong></p>
<p><strong>总结</strong></p>
<p>在发生哈希冲突时，Python中dict采用的开放寻址法，Java的HashMap采用的是链地址法，而Go map也采用链地址法解决冲突，具体就是<strong>插入key到map中时</strong>，当key定位的桶<strong>填满8个元素后</strong>（这里的单元就是桶，不是元素），将会创建一个溢出桶，并且将溢出桶插入当前桶所在链表尾部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// 创建一个新的溢出桶</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-Go-map-的负载因子为什么是-6-5？"><a href="#6-Go-map-的负载因子为什么是-6-5？" class="headerlink" title="6.Go map 的负载因子为什么是 6.5？"></a>6.Go map 的负载因子为什么是 6.5？</h2><p><strong>什么是负载因子?</strong></p>
<p><strong>负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标</strong>，也就是每个 bucket 桶存储的平均元素个数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">负载因子 = 哈希表存储的元素个数/桶个数</span><br></pre></td></tr></table></figure>

<p>另外负载因子<strong>与扩容、迁移</strong>等重新散列（rehash）行为有直接关系：</p>
<ul>
<li>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。</li>
<li>在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。</li>
</ul>
<p>负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是<strong>为了平衡 buckets 的存储空间大小和查找元素时的性能高低</strong>。</p>
<p>在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。</p>
<p><strong>为什么是 6.5?</strong></p>
<p>为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？</p>
<p><strong>测试报告</strong></p>
<p>实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。</p>
<p>报告中共包含 4 个关键指标，如下：</p>
<table>
<thead>
<tr>
<th align="left">loadFactor</th>
<th align="left">%overflow</th>
<th align="left">bytes&#x2F;entry</th>
<th align="left">hitprobe</th>
<th align="left">missprobe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">4.00</td>
<td align="left">2.13</td>
<td align="left">20.77</td>
<td align="left">3.00</td>
<td align="left">4.00</td>
</tr>
<tr>
<td align="left">4.50</td>
<td align="left">4.05</td>
<td align="left">17.30</td>
<td align="left">3.25</td>
<td align="left">4.50</td>
</tr>
<tr>
<td align="left">5.00</td>
<td align="left">6.85</td>
<td align="left">14.77</td>
<td align="left">3.50</td>
<td align="left">5.00</td>
</tr>
<tr>
<td align="left">5.50</td>
<td align="left">10.55</td>
<td align="left">12.94</td>
<td align="left">3.75</td>
<td align="left">5.50</td>
</tr>
<tr>
<td align="left">6.00</td>
<td align="left">15.27</td>
<td align="left">11.67</td>
<td align="left">4.00</td>
<td align="left">6.00</td>
</tr>
<tr>
<td align="left">6.50</td>
<td align="left">20.90</td>
<td align="left">10.79</td>
<td align="left">4.25</td>
<td align="left">6.50</td>
</tr>
<tr>
<td align="left">7.00</td>
<td align="left">27.14</td>
<td align="left">10.15</td>
<td align="left">4.50</td>
<td align="left">7.00</td>
</tr>
<tr>
<td align="left">7.50</td>
<td align="left">34.03</td>
<td align="left">9.73</td>
<td align="left">4.75</td>
<td align="left">7.50</td>
</tr>
<tr>
<td align="left">8.00</td>
<td align="left">41.10</td>
<td align="left">9.40</td>
<td align="left">5.00</td>
<td align="left">8.00</td>
</tr>
</tbody></table>
<ul>
<li>loadFactor：负载因子，也有叫装载因子。</li>
<li>%overflow：溢出率，有溢出 bukcet 的百分比。</li>
<li>bytes&#x2F;entry：平均每对 key&#x2F;value 的开销字节数.</li>
<li>hitprobe：查找一个存在的 key 时，要查找的平均个数。</li>
<li>missprobe：查找一个不存在的 key 时，要查找的平均个数。</li>
</ul>
<p><strong>选择数值</strong></p>
<p>Go 官方发现：<strong>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong></p>
<p>根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>
<p>这意味着在 Go 语言中，<strong>当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为</strong>。</p>
<h2 id="7-Go-map如何扩容"><a href="#7-Go-map如何扩容" class="headerlink" title="7.Go map如何扩容?"></a>7.Go map如何扩容?</h2><p><strong>扩容时机：</strong></p>
<p>在<strong>向 map 插入新 key</strong> 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">  hashGrow(t, h)</span><br><span class="line">  <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在扩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> growing() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容条件：</strong></p>
<p>条件1：超过负载</p>
<p>map元素个数 &gt; 6.5 * 桶个数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactor*bucketShift(B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中 </span><br><span class="line"></span><br><span class="line">bucketCnt = <span class="number">8</span>，一个桶可以装的最大元素个数</span><br><span class="line">loadFactor = <span class="number">6.5</span>，负载因子，平均每个桶的元素个数</span><br><span class="line">bucketShift(B): 桶的个数</span><br></pre></td></tr></table></figure>

<p>条件2：溢出桶太多</p>
<p>当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多。</p>
<p>当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line">    <span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line">    <span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line">    <span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line">    <span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">        B = <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line">    <span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于条件2，其实算是对条件1的补充。因为在负载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。</p>
<p>表面现象就是负载因子比较小比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。比如不断的增删，这样会造成overflow的bucket数量增多，但负载因子又不高，达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 扩容条件。</p>
<p><strong>扩容机制：</strong></p>
<p><strong>双倍扩容</strong>：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。该方法我们称之为<strong>双倍扩容</strong></p>
<p>**等量扩容：**针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。该方法我们称之为**等量扩容**。</p>
<p><strong>扩容函数：</strong></p>
<p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是<strong>插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作</strong>。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>  <span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line"> <span class="number">2</span>  <span class="comment">// 如果达到条件 1，那么将B值加1，相当于是原来的2倍</span></span><br><span class="line"> <span class="number">3</span>  <span class="comment">// 否则对应条件 2，进行等量扩容，所以 B 不变</span></span><br><span class="line"> <span class="number">4</span>    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line"> <span class="number">6</span>        bigger = <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>        h.flags |= sameSizeGrow</span><br><span class="line"> <span class="number">8</span>    &#125;</span><br><span class="line"> <span class="number">9</span>  <span class="comment">// 记录老的buckets</span></span><br><span class="line"><span class="number">10</span>    oldbuckets := h.buckets</span><br><span class="line"><span class="number">11</span>  <span class="comment">// 申请新的buckets空间</span></span><br><span class="line"><span class="number">12</span>    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"><span class="number">13</span>  <span class="comment">// 注意&amp;^ 运算符，这块代码的逻辑是转移标志位</span></span><br><span class="line"><span class="number">14</span>    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line"><span class="number">15</span>    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line"><span class="number">16</span>        flags |= oldIterator</span><br><span class="line"><span class="number">17</span>    &#125;</span><br><span class="line"><span class="number">18</span>    <span class="comment">// 提交grow (atomic wrt gc)</span></span><br><span class="line"><span class="number">19</span>    h.B += bigger</span><br><span class="line"><span class="number">20</span>    h.flags = flags</span><br><span class="line"><span class="number">21</span>    h.oldbuckets = oldbuckets</span><br><span class="line"><span class="number">22</span>    h.buckets = newbuckets</span><br><span class="line"><span class="number">23</span>  <span class="comment">// 搬迁进度为0</span></span><br><span class="line"><span class="number">24</span>    h.nevacuate = <span class="number">0</span></span><br><span class="line"><span class="number">25</span>  <span class="comment">// overflow buckets 数为0</span></span><br><span class="line"><span class="number">26</span>    h.noverflow = <span class="number">0</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>  <span class="comment">// 如果发现hmap是通过extra字段 来存储 overflow buckets时</span></span><br><span class="line"><span class="number">29</span>    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">30</span>        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">31</span>            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line"><span class="number">32</span>        &#125;</span><br><span class="line"><span class="number">33</span>        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line"><span class="number">34</span>        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line"><span class="number">35</span>    &#125;</span><br><span class="line"><span class="number">36</span>    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">37</span>        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">38</span>            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line"><span class="number">39</span>        &#125;</span><br><span class="line"><span class="number">40</span>        h.extra.nextOverflow = nextOverflow</span><br><span class="line"><span class="number">41</span>    &#125;</span><br><span class="line"><span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>

<p>由于 map 扩容需要将原有的 key&#x2F;value 重新搬迁到新的内存地址，如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，因此 Go map 的扩容采取了一种称为<strong>“渐进式”</strong>的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为了确认搬迁的 bucket 是我们正在使用的 bucket</span></span><br><span class="line">    <span class="comment">// 即如果当前key映射到老的bucket1，那么就搬迁该bucket1。</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">    <span class="comment">// 如果还未完成扩容工作，则再搬迁一个bucket。</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Go-map和sync-Map谁的性能好，为什么？"><a href="#8-Go-map和sync-Map谁的性能好，为什么？" class="headerlink" title="8.Go map和sync.Map谁的性能好，为什么？"></a>8.Go map和sync.Map谁的性能好，为什么？</h2><p>Go 语言的 <code>sync.Map</code> 支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu Mutex</span><br><span class="line">   read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">   dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">   misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比原始map：</strong></p>
<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>
<p><strong>优点：</strong></p>
<p>适合读多写少的场景</p>
<p><strong>缺点：</strong></p>
<p>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p>
<p><strong>结论：</strong></p>
<p>sync.Map的性能高体现在读操作远多于写操作的时候。 极端情况下，只有读操作时，是普通map的性能的44.3倍。<br>反过来，如果是全写，没有读，那么sync.Map还不如加普通map+mutex锁呢。只有普通map性能的一半。<br>建议使用sync.Map时一定要考虑读写比例。当写操作只占总操作的&lt;&#x3D;1&#x2F;10的时候，使用sync.Map性能会明显高很多。</p>
<h2 id="9-golang-中的map为什么能实现时间复杂度-O-1-的查询？"><a href="#9-golang-中的map为什么能实现时间复杂度-O-1-的查询？" class="headerlink" title="9. golang 中的map为什么能实现时间复杂度 O(1) 的查询？"></a>9. golang 中的map为什么能实现时间复杂度 O(1) 的查询？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Go 语言中，`map` 实现了平均时间复杂度为 O(1) 的查询，这是通过哈希表（Hash Table）的结构实现的。下面是一些关键的原因：</span><br><span class="line"></span><br><span class="line">### 1. **哈希表的基本原理**</span><br><span class="line">`map` 在 Go 语言底层是通过哈希表来实现的。在哈希表中，每个键（key）通过一个哈希函数计算出对应的哈希值，然后通过该哈希值定位到一个桶（bucket），桶中存储着键值对。通过这个过程，可以快速找到对应的值，因此查询的平均时间复杂度是 O(1)。</span><br><span class="line"></span><br><span class="line">### 2. **哈希函数的作用**</span><br><span class="line">哈希函数将键（key）映射为一个整数（哈希值），这个哈希值用于确定该键应该存储在哪个桶中。理想情况下，不同的键会被哈希函数均匀分布到不同的桶中，因此只需要一次哈希计算和一次桶内搜索就能找到值。</span><br><span class="line"></span><br><span class="line">### 3. **解决哈希冲突**</span><br><span class="line">由于哈希函数可能将不同的键映射到同一个桶中（称为哈希冲突），Go 的 `map` 使用了 **开放寻址** 和 **链地址法**（即在桶中存储链表或其他数据结构）来解决冲突。虽然冲突会影响性能，但哈希表设计良好时，冲突的概率相对较低，因此查询的平均时间复杂度仍然是 O(1)。</span><br><span class="line"></span><br><span class="line">### 4. **负载因子与扩容**</span><br><span class="line">当哈希表中的元素数量增长到一定程度（即负载因子达到某个阈值时），Go 语言的 `map` 会自动进行 **扩容**，即增加桶的数量并重新分配所有键值对到新的桶中。扩容保证了哈希表的性能不会随着数据量增大而显著下降，仍然可以维持平均 O(1) 的查询时间。</span><br><span class="line"></span><br><span class="line">### 5. **查找过程总结**</span><br><span class="line">- 使用哈希函数计算键的哈希值，定位到具体的桶。</span><br><span class="line">- 在桶中查找对应的键值对。如果没有哈希冲突，查询操作只需一次即可完成。</span><br><span class="line">- 如果有冲突，则在冲突的桶中进一步查找。冲突发生率较低，且桶内链表或其他数据结构的查找速度也较快。</span><br><span class="line"></span><br><span class="line">### 小结</span><br><span class="line">- 由于哈希函数能够将键映射到不同的桶中，且桶内数据量通常较小，因此查询的平均时间复杂度是 O(1)。</span><br><span class="line">- 哈希冲突会影响性能，但只要哈希函数设计得当，冲突较少，查找依然可以接近 O(1) 的复杂度。</span><br><span class="line">- 通过自动扩容机制，`map` 可以维持较高的查询性能。</span><br><span class="line"></span><br><span class="line">因此，Go 语言中的 `map` 利用哈希表这一数据结构，实现了快速的键值对查询，并能保持 O(1) 的平均时间复杂度。</span><br></pre></td></tr></table></figure>



<h1 id="第四章：Channel"><a href="#第四章：Channel" class="headerlink" title="第四章：Channel"></a>第四章：Channel</h1><h2 id="1-for-select-时，如果通道已经关闭会怎么样？如果select中只有一个case呢？"><a href="#1-for-select-时，如果通道已经关闭会怎么样？如果select中只有一个case呢？" class="headerlink" title="1. for select 时，如果通道已经关闭会怎么样？如果select中只有一个case呢？"></a>1. for select 时，如果通道已经关闭会怎么样？如果select中只有一个case呢？</h2><p><a href="https://blog.csdn.net/ilini/article/details/107330173">https://blog.csdn.net/ilini/article/details/107330173</a></p>
<h2 id="1-Go-channel的底层实现原理？"><a href="#1-Go-channel的底层实现原理？" class="headerlink" title="1.Go channel的底层实现原理？"></a>1.Go channel的底层实现原理？</h2><p><strong>概念：</strong></p>
<p>Go中的channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的）</p>
<p><strong>使用场景：</strong></p>
<p>停止信号监听</p>
<p>定时任务</p>
<p>生产方和消费方解耦</p>
<p>控制并发数</p>
<p><strong>底层数据结构：</strong></p>
<p>通过var声明或者make函数创建的channel变量是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>
<p>源码包中<code>src/runtime/chan.go</code>定义了hchan的数据结构：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/hchan.png" alt="hchan"></p>
<p>hchan结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"> closed   <span class="type">uint32</span>   <span class="comment">// channel是否关闭的标志</span></span><br><span class="line"> elemtype *_type   <span class="comment">// channel中的元素类型</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// channel分为无缓冲和有缓冲两种。</span></span><br><span class="line"> <span class="comment">// 对于有缓冲的channel存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组</span></span><br><span class="line"> <span class="comment">// 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移</span></span><br><span class="line"> <span class="comment">// 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</span></span><br><span class="line"> buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针（环形缓冲区）</span></span><br><span class="line"> qcount   <span class="type">uint</span>           <span class="comment">// 循环数组中的元素数量</span></span><br><span class="line"> dataqsiz <span class="type">uint</span>           <span class="comment">// 循环数组的长度</span></span><br><span class="line"> elemsize <span class="type">uint16</span>                 <span class="comment">// 元素的大小</span></span><br><span class="line"> sendx    <span class="type">uint</span>           <span class="comment">// 下一次写下标的位置</span></span><br><span class="line"> recvx    <span class="type">uint</span>           <span class="comment">// 下一次读下标的位置</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 尝试读取channel或向channel写入数据而被阻塞的goroutine</span></span><br><span class="line"> recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line"> sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line"></span><br><span class="line"> lock mutex <span class="comment">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待队列：</p>
<p>双向链表，包含一个头结点和一个尾结点</p>
<p>每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送&#x2F;接收的数据在哪里</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">   first *sudog</span><br><span class="line">   last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer </span><br><span class="line">    c        *hchan </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作</strong>：</p>
<p><strong>创建</strong></p>
<p>使用 <code>make(chan T, cap)</code> 来创建 channel，make 语法会在编译时，转换为 <code>makechan64</code> 和 <code>makechan</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建channel 有两种，一种是带缓冲的channel，一种是不带缓冲的channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 不带缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>创建时会做一些检查:</p>
<ul>
<li>元素大小不能超过 64K</li>
<li>元素的对齐大小不能超过 maxAlign 也就是 8 字节</li>
<li>计算出来的内存是否超过限制</li>
</ul>
<p>创建时的策略:</p>
<ul>
<li>如果是无缓冲的 channel，会直接给 hchan 分配内存</li>
<li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</li>
<li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</li>
</ul>
<p><strong>发送</strong></p>
<p>发送操作，编译时转换为<code>runtime.chansend</code>函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> </span><br></pre></td></tr></table></figure>

<p>阻塞式：</p>
<p>调用chansend函数，并且block&#x3D;true</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>非阻塞式：</p>
<p>调用chansend函数，并且block&#x3D;false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">10</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向 channel 中发送数据时大概分为两大块：检查和数据发送，数据发送流程如下：</p>
<ul>
<li>如果 channel 的读等待队列存在接收者goroutine<ul>
<li>将数据<strong>直接发送</strong>给第一个等待的 goroutine， <strong>唤醒接收的 goroutine</strong></li>
</ul>
</li>
<li>如果 channel 的读等待队列不存在接收者goroutine<ul>
<li>如果循环数组buf未满，那么将会把数据发送到循环数组buf的队尾</li>
<li>如果循环数组buf已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并<strong>挂起等待唤醒</strong></li>
</ul>
</li>
</ul>
<p><strong>接收</strong></p>
<p>发送操作，编译时转换为<code>runtime.chanrecv</code>函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) </span><br></pre></td></tr></table></figure>

<p>阻塞式：</p>
<p>调用chanrecv函数，并且block&#x3D;true</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;ch</span><br><span class="line"></span><br><span class="line">v := &lt;ch</span><br><span class="line"></span><br><span class="line">v, ok := &lt;ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel,造成读到数据为通道所存储的数据类型的零值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非阻塞式：</p>
<p>调用chanrecv函数，并且block&#x3D;false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向 channel 中接收数据时大概分为两大块，检查和数据发送，而数据接收流程如下：</p>
<ul>
<li>如果 channel 的写等待队列存在发送者goroutine<ul>
<li>如果是无缓冲 channel，<strong>直接</strong>从第一个发送者goroutine那里把数据拷贝给接收变量，<strong>唤醒发送的 goroutine</strong></li>
<li>如果是有缓冲 channel（已满），将循环数组buf的队首元素拷贝给接收变量，将第一个发送者goroutine的数据拷贝到 buf循环数组队尾，<strong>唤醒发送的 goroutine</strong></li>
</ul>
</li>
<li>如果 channel 的写等待队列不存在发送者goroutine<ul>
<li>如果循环数组buf非空，将循环数组buf的队首元素拷贝给接收变量</li>
<li>如果循环数组buf为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>
</ul>
</li>
</ul>
<p><strong>关闭</strong></p>
<p>关闭操作，调用close函数，编译时转换为<code>runtime.closechan</code>函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> </span><br></pre></td></tr></table></figure>

<p><strong>案例分析：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// ch是长度为4的带缓冲的channel</span></span><br><span class="line">  <span class="comment">// 初始hchan结构体重的buf为空，sendx和recvx均为0</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(ch, unsafe.Sizeof(ch))</span><br><span class="line">    <span class="keyword">go</span> sendTask(ch)</span><br><span class="line">    <span class="keyword">go</span> receiveTask(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G1是发送者</span></span><br><span class="line"><span class="comment">// 当G1向ch里发送数据时，首先会对buf加锁，然后将task存储的数据copy到buf中，然后sendx++，然后释放对buf的锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTask</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    taskList := []<span class="type">string</span>&#123;<span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;demo&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> taskList &#123;</span><br><span class="line">        ch &lt;- task <span class="comment">//发送任务到channel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G2是接收者</span></span><br><span class="line"><span class="comment">// 当G2消费ch的时候，会首先对buf加锁，然后将buf中的数据copy到task变量对应的内存里，然后recvx++,并释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveTask</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task := &lt;-ch                  <span class="comment">//接收任务</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;received&quot;</span>, task) <span class="comment">//处理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结hchan结构体的主要组成部分有四个：</p>
<ul>
<li>用来保存goroutine之间传递数据的循环数组：buf</li>
<li>用来记录此循环数组当前发送或接收数据的下标值：sendx和recvx</li>
<li>用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq</li>
<li>保证channel写入和读取数据时线程安全的锁：lock</li>
</ul>
<h2 id="2-Go-channel有什么特点？"><a href="#2-Go-channel有什么特点？" class="headerlink" title="2.Go channel有什么特点？"></a>2.Go channel有什么特点？</h2><p>channel有2种类型：无缓冲、有缓冲</p>
<p>channel有3种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>
<table>
<thead>
<tr>
<th></th>
<th>写操作模式</th>
<th>读操作模式</th>
<th>读写操作模式</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>make(chan&lt;- int)</td>
<td>make(&lt;-chan int)</td>
<td>make(chan int)</td>
</tr>
</tbody></table>
<p>channel有3种状态：未初始化、正常、关闭</p>
<table>
<thead>
<tr>
<th></th>
<th>未初始化</th>
<th>关闭</th>
<th>正常</th>
</tr>
</thead>
<tbody><tr>
<td>关闭</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>发送</td>
<td>永远阻塞导致死锁</td>
<td>panic</td>
<td>阻塞或者成功发送</td>
</tr>
<tr>
<td>接收</td>
<td>永远阻塞导致死锁</td>
<td>缓冲区为空则为零值, 否则可以继续读</td>
<td>阻塞或者成功接收</td>
</tr>
</tbody></table>
<p><strong>注意点</strong>：</p>
<ol>
<li>一个 channel不能多次关闭，会导致painc</li>
<li>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></li>
<li>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></li>
</ol>
<h2 id="3-Go-channel有无缓冲的区别？"><a href="#3-Go-channel有无缓冲的区别？" class="headerlink" title="3.Go channel有无缓冲的区别？"></a>3.Go channel有无缓冲的区别？</h2><p>无缓冲：一个送信人去你家送信，你不在家他不走，你一定要接下信，他才会走。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无缓冲的channel是默认的channel类型。当一个数据被发送到无缓冲的channel时，发送操作会阻塞，直到有另一个goroutine从这个channel中接收这个数据。同样地，当试图从一个无缓冲的channel接收数据时，如果没有数据可供接收，接收操作也会阻塞，直到有另一个goroutine发送数据到这个channel。因此，无缓冲的channel提供了一种强同步的通信机制，发送和接收操作在完成数据交换时都会阻塞，确保了数据在不同的goroutines之间精确地同步。</span><br></pre></td></tr></table></figure>

<p>有缓冲：一个送信人去你家送信，扔到你家的信箱转身就走，除非你的信箱满了，他必须等信箱有多余空间才会走。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有缓冲的channel具有一个固定大小的缓冲区。当数据被发送到有缓冲的channel时，如果缓冲区未满，发送操作就会立即返回，否则发送操作会阻塞，直到有另一个goroutine从channel中接收数据并空出空间。当从一个有缓冲的channel接收数据时，如果缓冲区中有数据，接收操作就会立即返回，否则接收操作会阻塞，直到有另一个goroutine发送数据到channel。因此，有缓冲的channel提供了一种弱同步的通信机制，发送和接收操作可能不会阻塞，使得goroutines可以继续执行其他的操作。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th>无缓冲</th>
<th>有缓冲</th>
</tr>
</thead>
<tbody><tr>
<td>创建方式</td>
<td>make(chan TYPE)</td>
<td>make(chan TYPE, SIZE)</td>
</tr>
<tr>
<td>发送阻塞</td>
<td>数据接收前发送阻塞</td>
<td>缓冲满时发送阻塞</td>
</tr>
<tr>
<td>接收阻塞</td>
<td>数据发送前接收阻塞</td>
<td>缓冲空时接收阻塞</td>
</tr>
</tbody></table>
<p><strong>非缓冲</strong> <code>channel</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">&quot;this  value of unbuffer channel&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">go</span> loop(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会报错 <code>fatal error: all goroutines are asleep - deadlock!</code> 就是因为 <code>ch&lt;-1</code> 发送了，但是同时没有接收者，所以就发生了阻塞</p>
<p>但如果我们把 <code>ch &lt;- 1</code> 放到 <code>go loop(ch)</code> 下面，程序就会正常运行</p>
<p><strong>缓冲</strong> <code>channel</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">&quot;this  value of unbuffer channel&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    <span class="keyword">go</span> loop(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也会报 fatal error: all goroutines are asleep - deadlock! ，这是因为 channel 的大小为 3 ，而我们要往里面塞 4 个数据，所以就会阻塞住，解决的办法有两个:</p>
<ol>
<li>把 channel 长度调大一点</li>
<li>把 channel 的信息发送者 ch &lt;- 1 这些代码移动到 go loop(ch) 下面 ，让 channel 实时消费就不会导致阻塞了</li>
</ol>
<h2 id="4-Go-channel为什么是线程安全的？"><a href="#4-Go-channel为什么是线程安全的？" class="headerlink" title="4.Go channel为什么是线程安全的？"></a>4.Go channel为什么是线程安全的？</h2><p><strong>为什么设计成线程安全？</strong></p>
<p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>
<p><strong>如何实现线程安全的？</strong></p>
<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>
<h2 id="5-Go-channel如何控制goroutine并发执行顺序？"><a href="#5-Go-channel如何控制goroutine并发执行顺序？" class="headerlink" title="5.Go channel如何控制goroutine并发执行顺序？"></a>5.Go channel如何控制goroutine并发执行顺序？</h2><h3 id="5-1-三个协程顺序执行"><a href="#5-1-三个协程顺序执行" class="headerlink" title="5.1 三个协程顺序执行"></a>5.1 三个协程顺序执行</h3><p><strong>多个goroutine并发执行时，每一个goroutine抢到处理器的时间点不一致，gorouine的执行本身不能保证顺序</strong>。即代码中先写的gorouine并不能保证先执行</p>
<p>思路：使用channel进行通信通知，用channel去传递信息，从而控制并发执行顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch2 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch3 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch1 <span class="operator">&lt;</span><span class="operator">-</span> struct&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">start</span> :<span class="operator">=</span> time.Now().Unix()</span><br><span class="line">    go print(&quot;gorouine1&quot;, ch1, ch2)</span><br><span class="line">    go print(&quot;gorouine2&quot;, ch2, ch3)</span><br><span class="line">    go print(&quot;gorouine3&quot;, ch3, ch1)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">end</span> :<span class="operator">=</span> time.Now().Unix()</span><br><span class="line">    fmt.Printf(&quot;duration:%d\n&quot;, <span class="keyword">end</span><span class="operator">-</span><span class="keyword">start</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func print(gorouine string, inputchan chan struct&#123;&#125;, outchan chan struct&#123;&#125;) &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 模拟内部操作耗时</span><br><span class="line">    time.Sleep(<span class="number">1</span> <span class="operator">*</span> time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span><span class="operator">-</span>inputchan:</span><br><span class="line">        fmt.Printf(&quot;%s\n&quot;, gorouine)</span><br><span class="line">        outchan <span class="operator">&lt;</span><span class="operator">-</span> struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gorouine1</span><br><span class="line">gorouine2</span><br><span class="line">gorouine3</span><br><span class="line">duration:1</span><br></pre></td></tr></table></figure>



<h3 id="5-2-两个协程交替打印"><a href="#5-2-两个协程交替打印" class="headerlink" title="5.2 两个协程交替打印"></a>5.2 两个协程交替打印</h3><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241014000309434.png" alt="image-20241014000309434"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>) <span class="comment">// 增加两个协程的计数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// 协程完成时，减少 WaitGroup 计数</span></span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-ch1:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123; <span class="comment">// 检测通道是否关闭</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				fmt.Print(i)</span><br><span class="line">				i++</span><br><span class="line">				fmt.Print(i)</span><br><span class="line">				i++</span><br><span class="line">				ch2 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// 协程完成时，减少 WaitGroup 计数</span></span><br><span class="line">		j := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-ch2:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123; <span class="comment">// 检测通道是否关闭</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//if j &gt; &#x27;Z&#x27; &#123; // 当 j 超过 &#x27;Z&#x27; 时，关闭通道，结束循环</span></span><br><span class="line">				<span class="comment">//	close(ch1) // 关闭 ch1 通知第一个协程退出</span></span><br><span class="line">				<span class="comment">//	close(ch2)</span></span><br><span class="line">				<span class="comment">//	return</span></span><br><span class="line">				<span class="comment">//&#125;</span></span><br><span class="line">				fmt.Print(<span class="type">string</span>(j))</span><br><span class="line">				j++</span><br><span class="line">				fmt.Print(<span class="type">string</span>(j))</span><br><span class="line">				j++</span><br><span class="line">				<span class="comment">// 如果想打印到z的时候立马结束</span></span><br><span class="line">				<span class="keyword">if</span> j &gt; <span class="string">&#x27;Z&#x27;</span> &#123; <span class="comment">// 当 j 超过 &#x27;Z&#x27; 时，关闭通道，结束循环</span></span><br><span class="line">					<span class="built_in">close</span>(ch1) <span class="comment">// 关闭 ch1 通知第一个协程退出</span></span><br><span class="line">					<span class="built_in">close</span>(ch2)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				ch1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 启动第一个协程</span></span><br><span class="line">	wg.Wait()         <span class="comment">// 等待两个协程完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-3-两个协程交替打印字符串"><a href="#5-3-两个协程交替打印字符串" class="headerlink" title="5.3 两个协程交替打印字符串"></a>5.3 两个协程交替打印字符串</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gp := sync.WaitGroup&#123;&#125;</span><br><span class="line">	gp.Add(<span class="number">2</span>)</span><br><span class="line">	str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	strchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="built_in">len</span>(str))</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> str &#123;</span><br><span class="line">		strchan &lt;- <span class="type">string</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wait1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	wait2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> gp.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-wait1:</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					a := &lt;-strchan</span><br><span class="line">					fmt.Println(<span class="string">&quot;g2&quot;</span>, a)</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(strchan) != <span class="number">0</span> &#123;</span><br><span class="line">						wait2 &lt;- <span class="number">1</span></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">close</span>(wait2)</span><br><span class="line">						<span class="built_in">close</span>(wait1)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> gp.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-wait2:</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					a := &lt;-strchan</span><br><span class="line">					fmt.Println(<span class="string">&quot;g1&quot;</span>, a)</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(strchan) != <span class="number">0</span> &#123;</span><br><span class="line">						wait1 &lt;- <span class="number">1</span></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">close</span>(wait1)</span><br><span class="line">						<span class="built_in">close</span>(wait2)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//gp.Done()</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line">	wait1 &lt;- <span class="number">1</span></span><br><span class="line">	gp.Wait()</span><br><span class="line">	<span class="built_in">close</span>(strchan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-4-两个协程交替打印奇偶数"><a href="#5-4-两个协程交替打印奇偶数" class="headerlink" title="5.4 两个协程交替打印奇偶数"></a>5.4 两个协程交替打印奇偶数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 定义为无缓冲channel导致死锁</span></span><br><span class="line">	<span class="comment">//ch1 := make(chan int)</span></span><br><span class="line">	<span class="comment">//ch2 := make(chan int)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch1)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> PrintA(ch1, ch2, &amp;wg)</span><br><span class="line">	<span class="keyword">go</span> PrintB(ch1, ch2, &amp;wg)</span><br><span class="line"></span><br><span class="line">	ch1 &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;finished!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintA</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">		&lt;-ch1</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ch2 &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintB</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">		&lt;-ch2</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;B &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ch1 &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的写法不好，基于5.2的写法修改后的版本更好：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 通道用于第一个协程（打印奇数）</span></span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 通道用于第二个协程（打印偶数）</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>) <span class="comment">// 增加两个协程的计数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// 协程完成时，减少 WaitGroup 计数</span></span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-ch1:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;A &quot;</span>, i) <span class="comment">// 打印奇数并加空格</span></span><br><span class="line">				&#125;</span><br><span class="line">				i++</span><br><span class="line">				ch2 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 通知另一个协程</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// 协程完成时，减少 WaitGroup 计数</span></span><br><span class="line">		j := <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-ch2:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> j%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;B &quot;</span>, j) <span class="comment">// 打印偶数并换行</span></span><br><span class="line">				&#125;</span><br><span class="line">				j++</span><br><span class="line">				<span class="keyword">if</span> j &gt; <span class="number">10</span> &#123; <span class="comment">// 打印到 10 后，关闭通道</span></span><br><span class="line">					<span class="built_in">close</span>(ch1) <span class="comment">// 关闭 ch1，通知第一个协程退出</span></span><br><span class="line">					<span class="built_in">close</span>(ch2)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				ch1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 通知第一个协程继续</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 启动第一个协程</span></span><br><span class="line">	wg.Wait()         <span class="comment">// 等待两个协程完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-5-三个协程交替打印-cat-dog-fish"><a href="#5-5-三个协程交替打印-cat-dog-fish" class="headerlink" title="5.5 三个协程交替打印 cat, dog, fish"></a>5.5 三个协程交替打印 cat, dog, fish</h3><p>使用三个协程，每秒钟打印cat, dog, fish，顺序不能变化（协程一打印cat，协程二打印dog，协程三打印fish），无限循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(catCH, fishCH <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">			catCH &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&lt;-fishCH</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dog</span><span class="params">(dogCH, catCH <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-catCH</span><br><span class="line">			fmt.Println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">			dogCH &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fish</span><span class="params">(fishCH, dogCH <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-dogCH</span><br><span class="line">			fmt.Println(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">			fishCH &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	catCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	dogCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	fishCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	cat(catCH, fishCH, &amp;wg)</span><br><span class="line">	dog(dogCH, catCH, &amp;wg)</span><br><span class="line">	fish(fishCH, dogCH, &amp;wg)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-Go-channel共享内存有什么优劣势？"><a href="#6-Go-channel共享内存有什么优劣势？" class="headerlink" title="6.Go channel共享内存有什么优劣势？"></a>6.Go channel共享内存有什么优劣势？</h2><p><strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 这句话想必大家已经非常熟悉了，在官方的博客，初学时的教程，甚至是在 Go 的源码中都能看到</p>
<p>无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP(Communication Sequential Process) 模型以及 Erlang 采用的 Actor 模型，这两种方式都是通过通信来共享内存。</p>
<p><img src="https://img.lailin.xyz/image/1610460699237-f6400aaa-34d5-4c8d-b323-27683704abd2.png" alt="02_Go进阶03_blog_channel.png"></p>
<p>大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。而 Actor 模型和 CSP 模型都是通过发送消息来共享内存，但是它们之间最大的区别就是 Actor 模型当中并没有一个独立的 Channel 组件，而是 Actor 与 Actor 之间直接进行消息的发送与接收，每个 Actor 都有一个本地的“信箱”消息都会先发送到这个“信箱当中”。</p>
<p><strong>优点</strong></p>
<ul>
<li>使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>容易出现死锁的情况</li>
</ul>
<h2 id="7-Go-channel发送和接收什么情况下会死锁？"><a href="#7-Go-channel发送和接收什么情况下会死锁？" class="headerlink" title="7.Go channel发送和接收什么情况下会死锁？"></a>7.Go channel发送和接收什么情况下会死锁？</h2><p><strong>死锁：</strong></p>
<ul>
<li>单个协程永久阻塞</li>
<li>两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</li>
</ul>
<p><strong>channel死锁场景：</strong></p>
<ul>
<li>非缓存channel只写不读</li>
<li>非缓存channel读在写后面</li>
<li>缓存channel写入超过缓冲区数量</li>
<li>空读</li>
<li>多个协程互相等待</li>
</ul>
<ol>
<li>非缓存channel只写不读</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line">    ch &lt;- <span class="number">3</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>非缓存channel读在写后面</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span>  <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    num := &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">100</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        num := &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>缓存channel写入超过缓冲区数量</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">    ch &lt;- <span class="number">6</span>  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>空读</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// ch := make(chan int, 1)</span></span><br><span class="line">    fmt.Println(&lt;-ch)  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>多个协程互相等待</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 互相等对方造成死锁</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">                fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">                ch2 &lt;- <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">            ch1 &lt;- <span class="number">300</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案一：使用带缓冲的 <code>channel</code></p>
<p>可以为 <code>ch1</code> 和 <code>ch2</code> 添加缓冲区，避免两个 goroutine 之间因为同步写入和读取而阻塞。</p>
<p>ch1 :&#x3D; make(chan int, 1) &#x2F;&#x2F; 带1个缓冲的channel ch2 :&#x3D; make(chan int, 1)</p>
<p>解决方案二：使用单独的 Goroutine 管理发送</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">				fmt.Println(<span class="string">&quot;num from ch1=&quot;</span>, num)</span><br><span class="line">				ch2 &lt;- <span class="number">100</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">				fmt.Println(<span class="string">&quot;num from ch2=&quot;</span>, num)</span><br><span class="line">				ch1 &lt;- <span class="number">300</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch2 &lt;- <span class="number">2</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="8-对已经关闭的的chan进行读写，会怎么样？为什么？"><a href="#8-对已经关闭的的chan进行读写，会怎么样？为什么？" class="headerlink" title="8. 对已经关闭的的chan进行读写，会怎么样？为什么？"></a>8. 对已经关闭的的chan进行读写，会怎么样？为什么？</h2><p><a href="https://cloud.tencent.com/developer/article/1796707">https://cloud.tencent.com/developer/article/1796707</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Go 语言中，读取已经关闭的无缓冲和有缓冲的 channel 会出现不同的行为。具体行为和原因如下：</span><br><span class="line"></span><br><span class="line">### 1. 无缓冲 Channel（Unbuffered Channel）</span><br><span class="line">如果读取一个已经关闭的 **无缓冲 channel**，会得到该 channel 的 **零值**，同时读取操作会立即完成，而不会发生阻塞。</span><br><span class="line"></span><br><span class="line">#### 现象：</span><br><span class="line">- **值类型 channel**：读取到的是该类型的零值。例如，`int` 类型的 channel 读取到 `0`，`bool` 类型的 channel 读取到 `false`。</span><br><span class="line">- **第二个返回值**：如果使用双返回值（即 `v, ok := &lt;-ch`），那么 `ok` 值为 `false`，表示 channel 已经关闭。</span><br><span class="line"></span><br><span class="line">#### 原因：</span><br><span class="line">Go 设计中，关闭一个 channel 后，所有读取操作都会立即返回，不会再发生阻塞，且返回的值是该类型的零值。关闭无缓冲 channel 后，它不再能传递值，所以只能返回零值，同时告诉程序该 channel 已经关闭。</span><br><span class="line"></span><br><span class="line">### 2. 有缓冲 Channel（Buffered Channel）</span><br><span class="line">对于 **有缓冲 channel**，读取一个关闭的 channel 的行为取决于缓冲区是否有剩余的数据。</span><br><span class="line"></span><br><span class="line">#### 现象：</span><br><span class="line">- **如果缓冲区还有未读取的值**：读取操作会返回缓冲区中的值，并且 `ok` 为 `true`。只有在缓冲区被清空后，后续读取操作才会返回零值，且 `ok` 为 `false`。</span><br><span class="line">- **如果缓冲区已经空了**：读取操作会直接返回该类型的零值，`ok` 为 `false`，表示 channel 已经关闭且没有剩余数据。</span><br><span class="line"></span><br><span class="line">#### 原因：</span><br><span class="line">有缓冲 channel 的设计允许在 channel 关闭后，继续读取缓冲区中剩余的数据。只有当缓冲区被完全清空后，才会返回该类型的零值，并指示 channel 已经关闭。这种设计使得缓冲区能够完全释放其存储的值。</span><br><span class="line"></span><br><span class="line">### 例子：</span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 无缓冲 channel</span><br><span class="line">    ch1 := make(chan int)</span><br><span class="line">    close(ch1)</span><br><span class="line">    v, ok := &lt;-ch1</span><br><span class="line">    fmt.Println(v, ok) // 输出：0 false</span><br><span class="line"></span><br><span class="line">    // 有缓冲 channel</span><br><span class="line">    ch2 := make(chan int, 2)</span><br><span class="line">    ch2 &lt;- 1</span><br><span class="line">    ch2 &lt;- 2</span><br><span class="line">    close(ch2)</span><br><span class="line"></span><br><span class="line">    v1, ok1 := &lt;-ch2</span><br><span class="line">    fmt.Println(v1, ok1) // 输出：1 true</span><br><span class="line"></span><br><span class="line">    v2, ok2 := &lt;-ch2</span><br><span class="line">    fmt.Println(v2, ok2) // 输出：2 true</span><br><span class="line"></span><br><span class="line">    v3, ok3 := &lt;-ch2</span><br><span class="line">    fmt.Println(v3, ok3) // 输出：0 false</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">- **无缓冲 channel**：关闭后立即返回零值，`ok` 为 `false`。</span><br><span class="line">- **有缓冲 channel**：关闭后会继续读取缓冲区中的值，直到缓冲区清空，再返回零值，`ok` 为 `false`。</span><br><span class="line"></span><br><span class="line">这种行为是 Go channel 的设计，确保了程序能优雅地处理 channel 关闭后的读取操作，并避免出现死锁或不必要的阻塞。</span><br></pre></td></tr></table></figure>





<h2 id="9-对未初始化的的chan进行读写，会怎么样？为什么？"><a href="#9-对未初始化的的chan进行读写，会怎么样？为什么？" class="headerlink" title="9. 对未初始化的的chan进行读写，会怎么样？为什么？"></a>9. 对未初始化的的chan进行读写，会怎么样？为什么？</h2><p><a href="https://juejin.cn/post/6844904196181852173">https://juejin.cn/post/6844904196181852173</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Go 语言中，对 **未初始化的有缓冲 channel** 和 **无缓冲 channel** 进行读写会导致 **死锁**，具体原因如下：</span><br><span class="line"></span><br><span class="line">### 1. 未初始化的 Channel</span><br><span class="line">无论是 **有缓冲 channel** 还是 **无缓冲 channel**，如果 channel 没有通过 `make` 初始化，那么它的值是 `nil`。对 **nil channel** 的读写操作都会 **永久阻塞**，导致程序死锁。</span><br><span class="line"></span><br><span class="line">#### 现象：</span><br><span class="line">- **写入 nil channel**：写入操作会永久阻塞，程序卡住，不会继续执行其他操作。</span><br><span class="line">- **读取 nil channel**：读取操作同样会永久阻塞，程序卡住。</span><br><span class="line"></span><br><span class="line">#### 原因：</span><br><span class="line">在 Go 中，未初始化的 channel 其实是一个 `nil` 指针，Go 语言的设计规定对 `nil` channel 的所有读写操作都会阻塞，不会返回任何数据或错误，也不会 panic。这是为了防止意外地向 `nil` channel 发送数据或接收数据，避免不明确的行为。</span><br><span class="line"></span><br><span class="line">### 示例代码：</span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var ch chan int  // nil channel</span><br><span class="line"></span><br><span class="line">    // 写入 nil channel，将会导致死锁</span><br><span class="line">    ch &lt;- 1  // 这里会永久阻塞</span><br><span class="line"></span><br><span class="line">    // 读取 nil channel，也会导致永久阻塞</span><br><span class="line">    val := &lt;-ch  // 这里会永久阻塞</span><br><span class="line">    _ = val</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 2. 无缓冲 vs 有缓冲 Channel 的特性</span><br><span class="line">#### 无缓冲 channel：</span><br><span class="line">- **读写需要同步**：无缓冲 channel 的读写必须同时进行。也就是说，当发送方发送数据时，接收方必须同时准备好接收，否则发送方会阻塞。</span><br><span class="line">- **nil 无缓冲 channel** 的读写操作没有任何缓冲，同样会阻塞，因为根本没有可供交互的空间。</span><br><span class="line"></span><br><span class="line">#### 有缓冲 channel：</span><br><span class="line">- **读写异步**：有缓冲 channel 可以在缓冲区未满时发送数据，而接收方可以在缓冲区非空时接收数据。</span><br><span class="line">- **nil 有缓冲 channel** 的读写操作也会永久阻塞，因为实际上没有缓冲区存在。</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">- 对 **未初始化的 channel（nil channel）** 进行读写操作，无论是否有缓冲，都会导致永久阻塞，程序陷入死锁状态。</span><br><span class="line">- **原因** 是 `nil` channel 在 Go 中无法进行正常的消息传递操作，任何对 `nil` channel 的操作都会阻塞，以防止意外的使用导致程序不稳定。</span><br><span class="line"></span><br><span class="line">因此，在使用 channel 前，必须通过 `make` 来显式地初始化它。</span><br></pre></td></tr></table></figure>

<p>那下面的代码为什么没死锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;before goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	block1()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			&lt;-ch</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中没有出现死锁，因为主协程没有被阻塞，它仍然能够继续执行。</p>
<p>但是，<strong>10 个 goroutine 永远阻塞</strong>，因为它们在等待从 <code>nil</code> channel 读取数据，这会导致这些 goroutine 处于 “僵尸” 状态（阻塞状态）。</p>
<p>如果主协程要等到子协程退出，则会造成死锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;before goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	block1(&amp;wg)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block1</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			&lt;-ch</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何解决上述代码的死锁问题，使用带缓冲的channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;before goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	block1(&amp;wg)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有的 goroutine 结束</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;All goroutines finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block1</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 带缓冲的 channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			&lt;-ch <span class="comment">// 读取 channel 的值</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟发送数据</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i <span class="comment">// 向缓冲区写入数据</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭 channel</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-golang中的channel如何由阻塞方式读变成非阻塞方式读，请给出代码示例"><a href="#10-golang中的channel如何由阻塞方式读变成非阻塞方式读，请给出代码示例" class="headerlink" title="10. golang中的channel如何由阻塞方式读变成非阻塞方式读，请给出代码示例"></a>10. golang中的channel如何由阻塞方式读变成非阻塞方式读，请给出代码示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Go语言中，默认情况下，读取一个channel是阻塞的，直到channel中有数据为止。要将其转换为非阻塞读取，可以使用一个非阻塞的模式：结合`select`语句和`default`分支来实现。如果channel中没有数据，`select`的`default`分支会立即执行，从而避免阻塞。</span><br><span class="line"></span><br><span class="line">以下是一个将channel从阻塞读变成非阻塞读的代码示例：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 创建一个无缓冲的channel</span><br><span class="line">	ch := make(chan int)</span><br><span class="line"></span><br><span class="line">	// 尝试非阻塞读取</span><br><span class="line">	select &#123;</span><br><span class="line">	case val := &lt;-ch: // 从channel中读取数据</span><br><span class="line">		fmt.Println(&quot;Received:&quot;, val)</span><br><span class="line">	default: // 如果没有数据可读，则执行此分支</span><br><span class="line">		fmt.Println(&quot;No data received, non-blocking&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 向channel发送数据并读取</span><br><span class="line">	go func() &#123;</span><br><span class="line">		ch &lt;- 42 // 向channel中发送数据</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 再次尝试读取channel，等待一会儿，确保有数据发送到channel</span><br><span class="line">	select &#123;</span><br><span class="line">	case val := &lt;-ch:</span><br><span class="line">		fmt.Println(&quot;Received after sending:&quot;, val)</span><br><span class="line">	default:</span><br><span class="line">		fmt.Println(&quot;No data received, non-blocking&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 代码解释：</span><br><span class="line">1. 第一次使用`select`时，`ch`中没有数据，因此执行`default`分支，不会阻塞。</span><br><span class="line">2. 在goroutine中向`ch`发送数据，第二次尝试读取时，数据已经发送，`select`的`case`分支成功读取数据。</span><br><span class="line"></span><br><span class="line">这种方式通过`select`和`default`分支的组合，可以避免channel阻塞，达到非阻塞读取的效果。</span><br></pre></td></tr></table></figure>



<h2 id="11-golang中，一直要读取chanel，应该怎么实现？"><a href="#11-golang中，一直要读取chanel，应该怎么实现？" class="headerlink" title="11. golang中，一直要读取chanel，应该怎么实现？"></a>11. golang中，一直要读取chanel，应该怎么实现？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Go语言中，如果你需要持续读取一个channel，可以使用一个`for`循环来读取channel的值。当需要停止读取时，可以通过关闭channel或通过某种外部条件来控制循环的退出。</span><br><span class="line"></span><br><span class="line">有两种常见的模式可以实现持续读取channel的逻辑：</span><br><span class="line"></span><br><span class="line">### 1. 使用`for range`持续读取</span><br><span class="line">当你想持续读取channel中的值时，可以使用`for range`循环，这个循环会持续读取channel，直到channel被关闭。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line"></span><br><span class="line">	// 启动一个goroutine持续向channel发送数据</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			time.Sleep(500 * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">		close(ch) // 关闭channel，结束for range循环</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 使用for range持续读取channel，直到channel关闭</span><br><span class="line">	for val := range ch &#123;</span><br><span class="line">		fmt.Println(&quot;Received:&quot;, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Channel closed, stop receiving.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 解释：</span><br><span class="line">- 在此示例中，`for range`会一直读取`ch`中的数据，直到channel被关闭。</span><br><span class="line">- 当`close(ch)`被调用时，`for range`会自动结束循环。</span><br><span class="line"></span><br><span class="line">### 2. 使用`for` + `ok`判断持续读取</span><br><span class="line">如果你不想关闭channel，但希望手动控制循环，可以使用一个`for`循环并结合`ok`来判断channel是否还能接收数据。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line"></span><br><span class="line">	// 启动一个goroutine持续向channel发送数据</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			time.Sleep(500 * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">		// 不关闭channel，模拟持续发送场景</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 使用for和ok判断持续读取channel</span><br><span class="line">	for &#123;</span><br><span class="line">		val, ok := &lt;-ch</span><br><span class="line">		if ok &#123;</span><br><span class="line">			fmt.Println(&quot;Received:&quot;, val)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			fmt.Println(&quot;Channel closed, stop receiving.&quot;)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 等待一会儿，观察程序行为</span><br><span class="line">	time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 解释：</span><br><span class="line">- `val, ok := &lt;-ch`：`ok`的值为`true`表示从channel成功接收到了数据，为`false`表示channel已关闭。</span><br><span class="line">- 使用`ok`判断可以手动控制何时退出循环。</span><br><span class="line">- 在这个例子中，如果channel未关闭，循环将一直运行，直到某个条件中断它。</span><br><span class="line"></span><br><span class="line">### 3. 无限读取且不关闭channel</span><br><span class="line">如果你需要持续读取一个不关闭的channel，通常会结合外部的信号或条件来停止循环（如通过控制goroutine或者使用`context`来管理协程的生命周期）。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	// 启动一个goroutine持续向channel发送数据</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			time.Sleep(500 * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 启动一个goroutine持续读取channel，直到外部条件触发退出</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case val := &lt;-ch:</span><br><span class="line">				fmt.Println(&quot;Received:&quot;, val)</span><br><span class="line">			case &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(&quot;Stopping receiving due to cancel signal&quot;)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 模拟一段时间后停止读取</span><br><span class="line">	time.Sleep(5 * time.Second)</span><br><span class="line">	cancel() // 发出取消信号</span><br><span class="line"></span><br><span class="line">	// 等待一会儿观察停止效果</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 解释：</span><br><span class="line">- 这里使用了`context`来控制读取channel的停止。</span><br><span class="line">- 当调用`cancel()`时，`ctx.Done()`会接收到信号，读取循环会停止。</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">1. **`for range`循环**：适用于当channel会被关闭的场景，它会自动退出循环。</span><br><span class="line">2. **`for` + `ok`判断**：适用于需要手动控制channel读取的场景，可以根据`ok`来判断channel是否已关闭。</span><br><span class="line">3. **`for + select`结合外部信号或条件**：适用于不关闭channel，但需要通过外部信号来控制读取的场景。</span><br><span class="line"></span><br><span class="line">根据实际需求选择合适的方式来实现一直读取channel的逻辑。</span><br></pre></td></tr></table></figure>



<h2 id="12-实现生产者生产，消费者非阻塞消费，然后退出。"><a href="#12-实现生产者生产，消费者非阻塞消费，然后退出。" class="headerlink" title="12. 实现生产者生产，消费者非阻塞消费，然后退出。"></a>12. 实现生产者生产，消费者非阻塞消费，然后退出。</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义生产者函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 在函数退出时减少 WaitGroup 计数</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Producer exiting...&quot;</span>)</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			i++</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Produced: %d\n&quot;</span>, i)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消费者函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 在函数退出时减少 WaitGroup 计数</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v, ok := &lt;-ch:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Consumer exiting...&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Consumed: %d\n&quot;</span>, v)</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;No more data to consume, exiting...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动生产者</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> producer(ch, quit, &amp;wg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动消费者</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> consumer(ch, quit, &amp;wg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主程序等待一段时间，然后通知生产者和消费者退出</span></span><br><span class="line">	<span class="comment">// 这里模拟一个退出信号，假设运行一段时间后程序结束</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;Running... Press enter to stop.&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Scanln()</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知生产者和消费者退出</span></span><br><span class="line">	<span class="built_in">close</span>(quit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待生产者和消费者都退出</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main function exiting...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第五章：Mutex"><a href="#第五章：Mutex" class="headerlink" title="第五章：Mutex"></a>第五章：Mutex</h1><h2 id="1-Go-互斥锁的实现原理？"><a href="#1-Go-互斥锁的实现原理？" class="headerlink" title="1.Go 互斥锁的实现原理？"></a>1.Go 互斥锁的实现原理？</h2><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于悲观锁。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>Mutex是互斥锁，当一个 goroutine 获得了锁后，其他 goroutine 不能获取锁（只能存在一个写者或读者，不能同时读和写）</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="#使用场景"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h3><p>多个线程同时访问临界区，为保证数据的安全，锁住一些共享资源， 以防止并发访问这些共享数据时可能导致的数据不一致问题。</p>
<p>获取锁的线程可以正常访问临界区，未获取到锁的线程等待锁释放后可以尝试获取锁</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/thread_safe.png" alt="img"></p>
<h3 id="底层实现结构"><a href="#底层实现结构" class="headerlink" title="#底层实现结构"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84">#</a>底层实现结构</h3><p>互斥锁对应的是底层结构是sync.Mutex结构体，，位于 src&#x2F;sync&#x2F;mutex.go中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type Mutex struct &#123;  </span><br><span class="line">     state int32  </span><br><span class="line">     sema  uint32</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>state表示锁的状态，有锁定、被唤醒、饥饿模式等，并且是用state的二进制位来标识的，不同模式下会有不同的处理方式</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_state.png" alt="mutex_state"></p>
<p>sema表示信号量，mutex阻塞队列的定位是通过这个变量来实现的，从而实现goroutine的阻塞和唤醒</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_sema.png" alt="mutex_sema"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">addr = &amp;sema</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semroot</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> *semaRoot &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;semtable[(<span class="type">uintptr</span>(unsafe.Pointer(addr))&gt;&gt;<span class="number">3</span>)%semTabSize].root  </span><br><span class="line">&#125;</span><br><span class="line">root := semroot(addr)</span><br><span class="line">root.queue(addr, s, lifo)</span><br><span class="line">root.dequeue(addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> semtable [<span class="number">251</span>]<span class="keyword">struct</span> &#123;  </span><br><span class="line">   root semaRoot  </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;  </span><br><span class="line">  lock  mutex  </span><br><span class="line">  treap *sudog <span class="comment">// root of balanced tree of unique waiters.  </span></span><br><span class="line">  nwait <span class="type">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g  </span><br><span class="line">    next *sudog  </span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// 指向sema变量</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot  </span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="#操作"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%93%8D%E4%BD%9C">#</a>操作</h3><p>锁的实现一般会依赖于原子操作、信号量，通过atomic 包中的一些原子操作来实现锁的锁定，通过信号量来实现线程的阻塞与唤醒</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="#加锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E5%8A%A0%E9%94%81">#</a><strong>加锁</strong></h4><p>通过原子操作cas加锁，如果加锁不成功，根据不同的场景选择自旋重试加锁或者阻塞等待被唤醒后加锁</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_lock.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">func (m *Mutex) Lock() &#123;</span><br><span class="line">    // Fast path: 幸运之路，一下就获取到了锁</span><br><span class="line">    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Slow path：缓慢之路，尝试自旋或阻塞获取锁</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解锁"><a href="#解锁" class="headerlink" title="#解锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E8%A7%A3%E9%94%81">#</a><strong>解锁</strong></h4><p>通过原子操作add解锁，如果仍有goroutine在等待，唤醒等待的goroutine</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_unlock.png" alt="mutex_unlock"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">func (m *Mutex) Unlock() &#123;  </span><br><span class="line">   // Fast path: 幸运之路，解锁</span><br><span class="line">   new := atomic.AddInt32(&amp;m.state, -mutexLocked)  </span><br><span class="line">   if new != 0 &#123;  </span><br><span class="line">            // Slow path：如果有等待的goroutine，唤醒等待的goroutine</span><br><span class="line">            m.unlockSlow()</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意点："><a href="#注意点：" class="headerlink" title="#注意点："></a><a href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%B3%A8%E6%84%8F%E7%82%B9">#</a><strong>注意点：</strong></h4><ul>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁</li>
<li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 Lock，另一个 goroutine 可以 Unlock</li>
</ul>
<h2 id="2-Go-互斥锁正常模式和饥饿模式的区别？"><a href="#2-Go-互斥锁正常模式和饥饿模式的区别？" class="headerlink" title="2.Go 互斥锁正常模式和饥饿模式的区别？"></a>2.Go 互斥锁正常模式和饥饿模式的区别？</h2><p>在Go一共可以分为两种抢锁的模式，一种是<strong>正常模式</strong>，另外一种是<strong>饥饿模式</strong>。</p>
<h3 id="正常模式-非公平锁"><a href="#正常模式-非公平锁" class="headerlink" title="#正常模式(非公平锁)"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">#</a>正常模式(非公平锁)</h3><p>在刚开始的时候，是处于正常模式（Barging），也就是，当一个G1持有着一个锁的时候，G2会自旋的去尝试获取这个锁</p>
<p>当<strong>自旋超过4次</strong>还没有能获取到锁的时候，这个G2就会被加入到获取锁的等待队列里面，并阻塞等待唤醒</p>
<p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式</p>
<h3 id="饥饿模式-公平锁"><a href="#饥饿模式-公平锁" class="headerlink" title="#饥饿模式(公平锁)"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E9%A5%A5%E9%A5%BF%E6%A8%A1%E5%BC%8F-%E5%85%AC%E5%B9%B3%E9%94%81">#</a>饥饿模式(公平锁)</h3><p>当一个 goroutine 等待锁时间超过 1 毫秒时，它可能会遇到饥饿问题。 在版本1.9中，这种场景下Go Mutex 切换到饥饿模式（handoff），解决饥饿问题。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">starving = runtime_nanotime()-waitStartTime &gt; 1e6</span><br></pre></td></tr></table></figure>

<p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式</p>
<p>那么也不可能说永远的保持一个饥饿的状态，总归会有吃饱的时候，也就是总有那么一刻Mutex会回归到正常模式，那么回归正常模式必须具备的条件有以下几种：</p>
<ol>
<li>G的执行时间小于1ms</li>
<li>等待队列已经全部清空了</li>
</ol>
<p>当满足上述两个条件的任意一个的时候，Mutex会切换回正常模式，而Go的抢锁的过程，就是在这个正常模式和饥饿模式中来回切换进行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)  </span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;  </span><br><span class="line">    delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E6%80%BB%E7%BB%93">#</a>总结</h3><p>对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。</p>
<h2 id="3-Go-互斥锁允许自旋的条件？"><a href="#3-Go-互斥锁允许自旋的条件？" class="headerlink" title="3.Go 互斥锁允许自旋的条件？"></a>3.Go 互斥锁允许自旋的条件？</h2><p>线程没有获取到锁时常见有2种处理方式：</p>
<ul>
<li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁也叫做<strong>自旋锁</strong>，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>
<li>另外一种处理方式就是把自己阻塞起来，会<strong>释放CPU给其他线程</strong>，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销</li>
</ul>
<p>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞</p>
<p><strong>允许自旋的条件：</strong></p>
<ol>
<li>锁已被占用，并且锁不处于饥饿模式。</li>
<li>积累的自旋次数小于最大自旋次数（active_spin&#x3D;4）。</li>
<li>cpu 核数大于 1。</li>
<li>有空闲的 P。</li>
<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;  </span><br><span class="line">    ...</span><br><span class="line">    runtime_doSpin()   </span><br><span class="line">    <span class="keyword">continue</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin </span><br><span class="line">    || ncpu &lt;= <span class="number">1</span> </span><br><span class="line">    || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">   <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自旋：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    procyield(active_spin_cnt)</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>如果可以进入自旋状态之后就会调用 <code>runtime_doSpin</code> 方法进入自旋， <code>doSpin</code> 方法会调用 <code>procyield(30)</code> 执行30次 <code>PAUSE</code> 指令，什么都不做，但是会消耗CPU时间</p>
<h2 id="4-Go-读写锁的实现原理？"><a href="#4-Go-读写锁的实现原理？" class="headerlink" title="4.Go 读写锁的实现原理？"></a>4.Go 读写锁的实现原理？</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>读写互斥锁RWMutex，是对Mutex的一个扩展，当一个 goroutine 获得了读锁后，其他 goroutine可以获取读锁，但不能获取写锁；当一个 goroutine 获得了写锁后，其他 goroutine既不能获取读锁也不能获取写锁（只能存在一个写者或多个读者，可以同时读）</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="#使用场景"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h3><p><strong>读</strong>多于<strong>写</strong>的情况（既保证线程安全，又保证性能不太差）</p>
<h3 id="底层实现结构-1"><a href="#底层实现结构-1" class="headerlink" title="#底层实现结构"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84">#</a>底层实现结构</h3><p>互斥锁对应的是底层结构是sync.RWMutex结构体，，位于 src&#x2F;sync&#x2F;rwmutex.go中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 复用互斥锁</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 信号量，用于写等待读</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 信号量，用于读等待写</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 当前执行读的 goroutine 数量</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 被阻塞的准备读的 goroutine 的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="#操作:"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%93%8D%E4%BD%9C">#</a><strong>操作:</strong></h4><p>读锁的加锁与释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() <span class="comment">// 加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() <span class="comment">// 释放读锁</span></span><br></pre></td></tr></table></figure>

<h4 id="加读锁"><a href="#加读锁" class="headerlink" title="#加读锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%8A%A0%E8%AF%BB%E9%94%81">#</a><strong>加读锁</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line"><span class="comment">// 为什么readerCount会小于0呢？往下看发现writer的Lock()会对readerCount做减法操作（原子操作）</span></span><br><span class="line">  <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">    runtime_Semacquire(&amp;rw.readerSem)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>atomic.AddInt32(&amp;rw.readerCount, 1)</code> 调用这个原子方法，对当前在读的数量加1，如果返回负数，那么说明当前有其他写锁，这时候就调用 <code>runtime_SemacquireMutex</code> 休眠当前goroutine 等待被唤醒</p>
<h4 id="释放读锁"><a href="#释放读锁" class="headerlink" title="#释放读锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E9%87%8A%E6%94%BE%E8%AF%BB%E9%94%81">#</a><strong>释放读锁</strong></h4><p>解锁的时候对正在读的操作减1，如果返回值小于 0 那么说明当前有在写的操作，这个时候调用 <code>rUnlockSlow</code> 进入慢速通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被阻塞的准备读的 goroutine 的数量减1，readerWait 为 0，就表示当前没有正在准备读的 goroutine 这时候调用 <code>runtime_Semrelease</code> 唤醒写操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的加锁与释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() <span class="comment">// 加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() <span class="comment">// 释放写锁</span></span><br></pre></td></tr></table></figure>

<h4 id="加写锁"><a href="#加写锁" class="headerlink" title="#加写锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%8A%A0%E5%86%99%E9%94%81">#</a><strong>加写锁</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// Wait for active readers.</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        runtime_Semacquire(&amp;rw.writerSem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用互斥锁的 lock，获取到互斥锁之后，如果计算之后当前仍然有其他 goroutine 持有读锁，那么就调用 <code>runtime_SemacquireMutex</code> 休眠当前的 goroutine 等待所有的读操作完成</p>
<p>这里readerCount 原子性加上一个很大的负数，是防止后面的协程能拿到读锁，阻塞读</p>
<h4 id="释放写锁"><a href="#释放写锁" class="headerlink" title="#释放写锁"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E9%87%8A%E6%94%BE%E5%86%99%E9%94%81">#</a><strong>释放写锁</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁的操作，会先调用 <code>atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</code> 将恢复之前写入的负数，然后根据当前有多少个读操作在等待，循环唤醒</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="#注意点"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%B3%A8%E6%84%8F%E7%82%B9">#</a>注意点</h3><ul>
<li>读锁或写锁在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁</li>
<li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）</li>
</ul>
<h3 id="互斥锁和读写锁的区别"><a href="#互斥锁和读写锁的区别" class="headerlink" title="#互斥锁和读写锁的区别"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>互斥锁和读写锁的区别</h3><ul>
<li>读写锁区分读者和写者，而互斥锁不区分</li>
<li>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
<h2 id="5-Go-可重入锁如何实现？"><a href="#5-Go-可重入锁如何实现？" class="headerlink" title="5.Go 可重入锁如何实现？"></a>5.Go 可重入锁如何实现？</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法时会自动获取锁，不会因为之前已经获取过还没释放再次加锁导致死锁</p>
<h3 id="为什么Go语言中没有可重入锁？"><a href="#为什么Go语言中没有可重入锁？" class="headerlink" title="#为什么Go语言中没有可重入锁？"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E4%B8%BA%E4%BB%80%E4%B9%88go%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">#</a>为什么Go语言中没有可重入锁？</h3><p>Mutex 不是可重入的锁。Mutex 的实现中没有记录哪个 goroutine 拥有这把锁。理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件，并且Mutex 重复Lock会导致死锁。</p>
<h3 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="#如何实现可重入锁？"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">#</a>如何实现可重入锁？</h3><p>实现一个可重入锁需要这两点：</p>
<ul>
<li>记住持有锁的线程</li>
<li>统计重入的次数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReentrantLock <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    recursion <span class="type">int32</span> <span class="comment">// 这个goroutine 重入的次数</span></span><br><span class="line">    owner     <span class="type">int64</span> <span class="comment">// 当前持有锁的goroutine id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the id of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGoroutineID</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">64</span>]<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> s = buf[:runtime.Stack(buf[:], <span class="literal">false</span>)]</span><br><span class="line">    s = s[<span class="built_in">len</span>(<span class="string">&quot;goroutine &quot;</span>):]</span><br><span class="line">    s = s[:bytes.IndexByte(s, <span class="string">&#x27; &#x27;</span>)]</span><br><span class="line">    gid, _ := strconv.ParseInt(<span class="type">string</span>(s), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">return</span> gid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReentrantLock</span><span class="params">()</span></span> sync.Locker &#123;</span><br><span class="line">    res := &amp;ReentrantLock&#123;</span><br><span class="line">        Mutex:     sync.Mutex&#123;&#125;,</span><br><span class="line">        recursion: <span class="number">0</span>,</span><br><span class="line">        owner:     <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantMutex 包装一个Mutex,实现可重入</span></span><br><span class="line"><span class="keyword">type</span> ReentrantMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    owner     <span class="type">int64</span> <span class="comment">// 当前持有锁的goroutine id</span></span><br><span class="line">    recursion <span class="type">int32</span> <span class="comment">// 这个goroutine 重入的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ReentrantMutex)</span></span> Lock() &#123;</span><br><span class="line">    gid := GetGoroutineID()</span><br><span class="line">    <span class="comment">// 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;m.owner) == gid &#123;</span><br><span class="line">        m.recursion++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.Mutex.Lock()</span><br><span class="line">    <span class="comment">// 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1</span></span><br><span class="line">    atomic.StoreInt64(&amp;m.owner, gid)</span><br><span class="line">    m.recursion = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ReentrantMutex)</span></span> Unlock() &#123;</span><br><span class="line">    gid := GetGoroutineID()</span><br><span class="line">    <span class="comment">// 非持有锁的goroutine尝试释放锁，错误的使用</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;m.owner) != gid &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;wrong the owner(%d): %d!&quot;</span>, m.owner, gid))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用次数减1</span></span><br><span class="line">    m.recursion--</span><br><span class="line">    <span class="keyword">if</span> m.recursion != <span class="number">0</span> &#123; <span class="comment">// 如果这个goroutine还没有完全释放，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此goroutine最后一次调用，需要释放锁</span></span><br><span class="line">    atomic.StoreInt64(&amp;m.owner, <span class="number">-1</span>)</span><br><span class="line">    m.Mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mutex = &amp;ReentrantMutex&#123;&#125;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Println(<span class="number">111</span>)</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-Go-原子操作有哪些？"><a href="#6-Go-原子操作有哪些？" class="headerlink" title="6.Go 原子操作有哪些？"></a>6.Go 原子操作有哪些？</h2><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32&#x2F;int64&#x2F;uint32&#x2F;uint64&#x2F;uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）</p>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="#使用场景"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h3><p>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync&#x2F;atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。</p>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="#常见操作"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">#</a>常见操作</h3><ul>
<li>增减Add</li>
<li>载入Load</li>
<li>比较并交换CompareAndSwap</li>
<li>交换Swap</li>
<li>存储Store</li>
</ul>
<p>atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</p>
<p>下面将分别介绍这些操作：</p>
<h4 id="增减操作"><a href="#增减操作" class="headerlink" title="#增减操作"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%A2%9E%E5%87%8F%E6%93%8D%E4%BD%9C">#</a><strong>增减操作</strong></h4><p>此类操作的前缀为 <code>Add</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，第一个参数必须是指针类型的值，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作。</p>
<p>使用举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(addr, delta) <span class="comment">//加操作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;add opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="载入操作"><a href="#载入操作" class="headerlink" title="#载入操作"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E8%BD%BD%E5%85%A5%E6%93%8D%E4%BD%9C">#</a><strong>载入操作</strong></h4><p>此类操作的前缀为 <code>Load</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊类型： Value类型，常用于配置变更</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>&#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>载入操作能够保证原子的读变量的值，当读取的时候，任何其他CPU操作都无法对该变量进行读写，其实现机制受到底层硬件的支持。</p>
<p>使用示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(addr *<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;load opts: &quot;</span>, atomic.LoadInt64(&amp;opts))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较并交换"><a href="#比较并交换" class="headerlink" title="#比较并交换"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">#</a><strong>比较并交换</strong></h4><p>此类操作的前缀为 <code>CompareAndSwap</code>, 该操作简称 CAS，可以用来实现乐观锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>

<p>该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数 <code>old</code> 所记录的值，满足此前提下才进行交换操作。CAS的做法类似操作数据库时常见的乐观锁机制。</p>
<p>需要注意的是，当有大量的goroutine 对变量进行读写操作时，可能导致CAS操作无法成功，这时可以利用for循环多次尝试。</p>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareAndSwap</span><span class="params">(addr *<span class="type">int64</span>, oldValue <span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt64(addr, oldValue, newValue) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;cas opts: &quot;</span>, *addr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E4%BA%A4%E6%8D%A2">#</a><strong>交换</strong></p>
<p>此类操作的前缀为 <code>Swap</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>

<p>相对于CAS，明显此类操作更为暴力直接，并不管变量的旧值是否被改变，直接赋予新值然后返回背替换的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.SwapInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="存储"><a href="#存储" class="headerlink" title="#存储"></a><a href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%AD%98%E5%82%A8">#</a><strong>存储</strong></h4><p>此类操作的前缀为 <code>Store</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊类型： Value类型，常用于配置变更</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>



<p>此类操作确保了写变量的原子性，避免其他操作读到了修改变量过程中的脏数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.StoreInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;store opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-Go-原子操作和锁的区别？"><a href="#7-Go-原子操作和锁的区别？" class="headerlink" title="7.Go 原子操作和锁的区别？"></a>7.Go 原子操作和锁的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Go 中的原子操作和锁都用于解决并发环境下的数据竞争问题，但它们的工作原理和适用场景有所不同。</span><br><span class="line"></span><br><span class="line">### 1. **锁 (Mutex) 和它的工作原理**</span><br><span class="line">   锁（如 `sync.Mutex`）用于保证在同一时刻只有一个 goroutine 访问临界区（共享数据）。当一个 goroutine 获取了锁后，其他 goroutine 必须等待这个锁释放才能继续执行。锁的适用场景是需要对一段复杂的代码或多条操作进行同步控制。</span><br><span class="line"></span><br><span class="line">   **优点：**</span><br><span class="line">   - 适用于保护复杂的临界区，多个操作之间需要保持一致性的场景。</span><br><span class="line">   - 可以防止多个 goroutine 同时进入临界区，有效避免数据不一致或竞态条件。</span><br><span class="line"></span><br><span class="line">   **缺点：**</span><br><span class="line">   - 性能开销较大：锁涉及上下文切换、调度器阻塞等开销，在高并发场景下可能降低性能。</span><br><span class="line">   - 易引发死锁：如果锁的使用不当（比如忘记解锁、多个锁互相等待），可能会引发死锁。</span><br><span class="line"></span><br><span class="line">### 2. **原子操作 (Atomic) 和它的工作原理**</span><br><span class="line">   原子操作则是另一种保证数据一致性的方法，它直接由 CPU 提供的指令级别的保证，确保对基本类型（如整数、指针等）的一些操作（例如加法、减法、交换等）在并发情况下是原子的。Go 提供的原子操作通过 `sync/atomic` 包来实现，比如 `atomic.AddInt32`、`atomic.LoadInt64` 等。</span><br><span class="line"></span><br><span class="line">   **优点：**</span><br><span class="line">   - **性能高**：由于原子操作直接使用底层硬件提供的指令，不需要上下文切换和锁竞争，因此比使用锁的性能开销小。</span><br><span class="line">   - **适用于简单操作**：当你只需要对单个变量进行简单的读写或递增递减操作时，原子操作是理想的选择。</span><br><span class="line"></span><br><span class="line">   **缺点：**</span><br><span class="line">   - **局限性**：原子操作只能对单一变量进行操作，且只支持一些简单的操作（如读、写、加减、交换等）。对于更复杂的同步需求，仍需要使用锁。</span><br><span class="line"></span><br><span class="line">### 为什么有了锁还需要原子操作？</span><br><span class="line"></span><br><span class="line">尽管锁在同步复杂操作时非常有效，但对于简单的操作（例如对单个变量的递增、赋值），使用锁往往显得过于笨重，并且性能开销较大。在这些情况下，**原子操作可以提供更高效的并发控制**。使用原子操作的场景通常包括对某个计数器、标志位、指针等单一变量的修改和访问。</span><br><span class="line"></span><br><span class="line">### 适用场景的对比</span><br><span class="line"></span><br><span class="line">- **锁的使用场景**：</span><br><span class="line">  - 需要保护复杂的临界区（多个变量、复杂的逻辑）时，例如在临界区中执行多步操作且这些操作必须保持一致性。</span><br><span class="line">  - 临界区可能涉及对多个变量或资源的修改，或者多个操作之间必须保持原子性。</span><br><span class="line">  - 避免竞态条件（race condition），保护复杂数据结构的并发安全。</span><br><span class="line"></span><br><span class="line">- **原子操作的使用场景**：</span><br><span class="line">  - 对单个共享变量进行简单的操作（例如递增、递减、加载、存储、交换等）。</span><br><span class="line">  - 高性能场景中，当锁的性能开销显著且操作非常简单时，使用原子操作来提高并发效率。</span><br><span class="line">  - 例如，计数器、标志位、引用计数等。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">尽管锁可以用于任何并发控制，但由于其性能开销较大，对于简单的操作（如递增或赋值），原子操作提供了更高效的解决方案。锁和原子操作各有优缺点，选择哪种方案取决于实际的并发操作复杂性和性能需求。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>原子操作由底层硬件支持，而锁是基于原子操作+信号量完成的。若实现相同的功能，前者通常会更有效率</p>
</li>
<li><p>原子操作是单个指令的互斥操作；互斥锁&#x2F;读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围</p>
</li>
<li><p>原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁</p>
</li>
<li><p>原子操作存在于各个指令&#x2F;语言层级，比如“机器指令层级的原子操作”，“汇编指令层级的原子操作”，“Go语言层级的原子操作”等。</p>
</li>
<li><p>锁也存在于各个指令&#x2F;语言层级中，比如“机器指令层级的锁”，“汇编指令层级的锁”，“Go语言层级的锁”等</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241013162657102.png" alt="image-20241013162657102"></p>
</li>
</ul>
<h1 id="第六章：Goroutine"><a href="#第六章：Goroutine" class="headerlink" title="第六章：Goroutine"></a>第六章：Goroutine</h1><h2 id="1-Go-goroutine的底层实现原理？"><a href="#1-Go-goroutine的底层实现原理？" class="headerlink" title="1.Go goroutine的底层实现原理？"></a>1.Go goroutine的底层实现原理？</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>Goroutine可以理解为一种Go语言的协程（轻量级线程），是Go支持高并发的基础，属于用户态的线程，由Go runtime管理而不是操作系统。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="#底层数据结构"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    goid    <span class="type">int64</span> <span class="comment">// 唯一的goroutine的ID</span></span><br><span class="line">    sched gobuf <span class="comment">// goroutine切换时，用于保存g的上下文</span></span><br><span class="line">    stack stack <span class="comment">// 栈</span></span><br><span class="line">  gopc        <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">    startpc    <span class="type">uintptr</span> <span class="comment">// pc of goroutine function</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span> <span class="comment">// 栈指针位置</span></span><br><span class="line">    pc   <span class="type">uintptr</span> <span class="comment">// 运行到的程序位置</span></span><br><span class="line">    g    guintptr <span class="comment">// 指向 goroutine</span></span><br><span class="line">    ret  <span class="type">uintptr</span>  <span class="comment">// 保存系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="type">uintptr</span> <span class="comment">// 栈的下界内存地址</span></span><br><span class="line">    hi <span class="type">uintptr</span> <span class="comment">// 栈的上界内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终有一个 runtime.g 对象放入调度队列</p>
<h3 id="状态流转"><a href="#状态流转" class="headerlink" title="#状态流转"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC">#</a>状态流转</h3><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>空闲中_Gidle</td>
<td>G刚刚新建, 仍未初始化</td>
</tr>
<tr>
<td>待运行_Grunnable</td>
<td>就绪状态，G在运行队列中, 等待M取出并运行</td>
</tr>
<tr>
<td>运行中_Grunning</td>
<td>M正在运行这个G, 这时候M会拥有一个P</td>
</tr>
<tr>
<td>系统调用中_Gsyscall</td>
<td>M正在运行这个G发起的系统调用, 这时候M并不拥有P</td>
</tr>
<tr>
<td>等待中_Gwaiting</td>
<td>G在等待某些条件完成, 这时候G不在运行也不在运行队列中(可能在channel的等待队列中)</td>
</tr>
<tr>
<td>已中止_Gdead</td>
<td>G未被使用, 可能已执行完毕</td>
</tr>
<tr>
<td>栈复制中_Gcopystack</td>
<td>G正在获取一个新的栈空间并把原来的内容复制过去(用于防止GC扫描)</td>
</tr>
</tbody></table>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/5.2.goroutine_state.jpg" alt="img"></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="#创建"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%88%9B%E5%BB%BA">#</a>创建</h3><p>通过<code>go</code>关键字调用底层函数<code>runtime.newproc()</code>创建一个<code>goroutine</code></p>
<p>当调用该函数之后，goroutine会被设置成<code>runnable</code>状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func routine&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">&quot;main goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好的这个goroutine会新建一个自己的栈空间，同时在G的sched中维护栈地址与程序计数器这些信息。</p>
<p>每个 G 在被创建之后，都会被优先放入到本地队列中，如果本地队列已经满了，就会被放入到全局队列中。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="#运行"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E8%BF%90%E8%A1%8C">#</a>运行</h3><p>goroutine 本身只是一个数据结构，真正让 goroutine 运行起来的是<strong>调度器</strong>。Go 实现了一个用户态的调度器（GMP模型），这个调度器充分利用现代计算机的多核特性，同时让多个 goroutine 运行，同时 goroutine 设计的很轻量级，调度和上下文切换的代价都比较小。</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220406201146142.png" alt="img"></p>
<p><strong>调度时机：</strong></p>
<ul>
<li>新起一个协程和协程执行完毕</li>
<li>会阻塞的系统调用，比如文件io、网络io</li>
<li>channel、mutex等阻塞操作</li>
<li>time.sleep</li>
<li>垃圾回收之后</li>
<li>主动调用runtime.Gosched()</li>
<li>运行过久或系统调用过久等等</li>
</ul>
<p>每个 M 开始执行 P 的本地队列中的 G时，goroutine会被设置成<code>running</code>状态</p>
<p>如果某个 M 把本地队列中的G都执行完成之后，然后就会去全局队列中拿 G，这里需要注意，每次去全局队列拿 G 的时候，都需要上锁，避免同样的任务被多次拿。</p>
<p>如果全局队列都被拿完了，而当前 M 也没有更多的 G 可以执行的时候，它就会去其他 P 的本地队列中拿任务，这个机制被称之为 work stealing 机制，每次会拿走一半的任务，向下取整，比如另一个 P 中有 3 个任务，那一半就是一个任务。</p>
<p>当全局队列为空，M 也没办法从其他的 P 中拿任务的时候，就会让自身进入自选状态，等待有新的 G 进来。最多只会有 GOMAXPROCS 个 M 在自旋状态，过多 M 的自旋会浪费 CPU 资源。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="#阻塞"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E9%98%BB%E5%A1%9E">#</a>阻塞</h3><p>channel的读写操作、等待锁、等待网络数据、系统调用等都有可能发生阻塞，会调用底层函数<code>runtime.gopark()</code>，会让出CPU时间片，让调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
<p>当调用该函数之后，goroutine会被设置成<code>waiting</code>状态</p>
<h3 id="唤醒"><a href="#唤醒" class="headerlink" title="#唤醒"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%94%A4%E9%86%92">#</a>唤醒</h3><p>处于waiting状态的goroutine，在调用<code>runtime.goready()</code>函数之后会被唤醒，唤醒的goroutine会被重新放到M对应的上下文P对应的runqueue中，等待被调度。</p>
<p>当调用该函数之后，goroutine会被设置成<code>runnable</code>状态</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="#退出"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E9%80%80%E5%87%BA">#</a>退出</h3><p>当goroutine执行完成后，会调用底层函数<code>runtime.Goexit()</code></p>
<p>当调用该函数之后，goroutine会被设置成<code>dead</code>状态</p>
<h2 id="2-Go-goroutine和线程的区别"><a href="#2-Go-goroutine和线程的区别" class="headerlink" title="2.Go goroutine和线程的区别?"></a>2.Go goroutine和线程的区别?</h2><table>
<thead>
<tr>
<th align="center"></th>
<th>goroutine</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存占用</td>
<td>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容</td>
<td>创建一个 线程 的栈内存消耗为 1 MB</td>
</tr>
<tr>
<td align="center">创建和销毀</td>
<td>goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</td>
<td>线程 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池</td>
</tr>
<tr>
<td align="center">切换</td>
<td>goroutines 切换只需保存三个寄存器：PC、SP、BP goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。</td>
<td>当线程切换时，需要保存各种寄存器，以便恢复现场。 线程切换会消耗 1000-1500 ns，相当于 12000-18000 条指令。</td>
</tr>
</tbody></table>
<h2 id="3-Go-goroutine泄露的场景"><a href="#3-Go-goroutine泄露的场景" class="headerlink" title="3.Go goroutine泄露的场景?"></a>3.Go goroutine泄露的场景?</h2><h3 id="泄露原因"><a href="#泄露原因" class="headerlink" title="#泄露原因"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0">#</a>泄露原因</h3><ul>
<li>Goroutine 内进行channel&#x2F;mutex 等读写操作被一直阻塞。</li>
<li>Goroutine 内的业务逻辑进入死循环，资源一直无法释放。</li>
<li>Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待</li>
</ul>
<h3 id="泄露场景"><a href="#泄露场景" class="headerlink" title="#泄露场景"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E6%B3%84%E9%9C%B2%E5%9C%BA%E6%99%AF">#</a>泄露场景</h3><p>如果输出的 goroutines 数量是在不断增加的，就说明存在泄漏</p>
<p><strong>nil channel</strong></p>
<p>channel 如果忘记初始化，那么无论你是读，还是写操作，都会造成阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    block1()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            &lt;-ch</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before goroutines:  1</span><br><span class="line">after goroutines:  11</span><br></pre></td></tr></table></figure>



<p><strong>发送不接收</strong></p>
<p>channel 发送数量 超过 channel接收数量，就会造成阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接收不发送</strong></p>
<p>channel 接收数量 超过 channel发送数量，也会造成阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            &lt;-ch</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>http request body未关闭</strong></p>
<p><code>resp.Body.Close()</code> 未被调用时，goroutine不会退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithNoClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, err := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred while fetching page, error: %s&quot;</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred while fetching page, error: %s&quot;</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                requestWithNoClose()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    block4()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一般发起http请求时，需要确保关闭body</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>

<p><strong>互斥锁忘记解锁</strong></p>
<p>第一个协程获取 <code>sync.Mutex</code> 加锁了，但是他可能在处理业务逻辑，又或是忘记 <code>Unlock</code> 了。</p>
<p>因此导致后面的协程想加锁，却因锁未释放被阻塞了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>sync.WaitGroup使用不当</strong></p>
<p>由于 <code>wg.Add</code> 的数量与 <code>wg.Done</code> 数量并不匹配，因此在调用 <code>wg.Wait</code> 方法后一直阻塞等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block6</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">2</span>)</span><br><span class="line">            wg.Done()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何排查"><a href="#如何排查" class="headerlink" title="#如何排查"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5">#</a>如何排查</h3><ul>
<li>单个函数：调用 <code>runtime.NumGoroutine</code> 方法来打印 执行代码前后Goroutine 的运行数量，进行前后比较，就能知道有没有泄露了。</li>
</ul>
<p>​		具体排查示例见：<code>9. 对未初始化的的chan进行读写，会怎么样？为什么？</code></p>
<ul>
<li>生产&#x2F;测试环境：使用<code>PProf</code>实时监测Goroutine的数量</li>
</ul>
<h2 id="4-Go-如何查看正在执行的goroutine数量"><a href="#4-Go-如何查看正在执行的goroutine数量" class="headerlink" title="4.Go 如何查看正在执行的goroutine数量?"></a>4.Go 如何查看正在执行的goroutine数量?</h2><h3 id="程序中引入pprof-pakage"><a href="#程序中引入pprof-pakage" class="headerlink" title="#程序中引入pprof pakage"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-4.html#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%BC%95%E5%85%A5pprof-pakage">#</a>程序中引入pprof pakage</h3><p>在程序中引入pprof package：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<p>程序中开启HTTP监听服务：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析goroutine文件"><a href="#分析goroutine文件" class="headerlink" title="#分析goroutine文件"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-4.html#%E5%88%86%E6%9E%90goroutine%E6%96%87%E4%BB%B6">#</a>分析goroutine文件</h3><p>在命令行下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:1248 http://127.0.0.1:6060/debug/pprof/goroutine</span><br></pre></td></tr></table></figure>

<p>会自动打开浏览器页面如下图所示</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/pprof.png" alt="img"></p>
<p>在图中可以清晰的看到goroutine的数量以及调用关系，可以看到有103个goroutine</p>
<h2 id="5-Go-如何控制并发的goroutine数量"><a href="#5-Go-如何控制并发的goroutine数量" class="headerlink" title="5.Go 如何控制并发的goroutine数量?"></a>5.Go 如何控制并发的goroutine数量?</h2><h3 id="为什么要控制goroutine并发的数量？"><a href="#为什么要控制goroutine并发的数量？" class="headerlink" title="#为什么要控制goroutine并发的数量？"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-5.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%A7%E5%88%B6goroutine%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B0%E9%87%8F">#</a><strong>为什么要控制goroutine并发的数量？</strong></h3><p>在开发过程中，如果不对goroutine加以控制而进行滥用的话，可能会导致服务整体崩溃。比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。</p>
<h3 id="用什么方法控制goroutine并发的数量？"><a href="#用什么方法控制goroutine并发的数量？" class="headerlink" title="#用什么方法控制goroutine并发的数量？"></a><a href="https://vip.golangroadmap.com/class/gointerview/6-5.html#%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%8E%A7%E5%88%B6goroutine%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B0%E9%87%8F">#</a><strong>用什么方法控制goroutine并发的数量？</strong></h3><p><strong>有缓冲channel</strong></p>
<p>利用缓冲满时发送阻塞的特性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 模拟用户请求数量</span></span><br><span class="line">    requestCount := <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;goroutine_num&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    <span class="comment">// 管道长度即最大并发数</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; requestCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="literal">true</span></span><br><span class="line">        <span class="keyword">go</span> Read(ch, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine_num: %d, go func: %d\n&quot;</span>, runtime.NumGoroutine(), i)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：默认最多不超过3（4-1）个goroutine并发执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">goroutine_num 1</span><br><span class="line">goroutine_num: 4, go func: 1</span><br><span class="line">goroutine_num: 4, go func: 3</span><br><span class="line">goroutine_num: 4, go func: 2</span><br><span class="line">goroutine_num: 4, go func: 0</span><br><span class="line">goroutine_num: 4, go func: 4</span><br><span class="line">goroutine_num: 4, go func: 5</span><br><span class="line">goroutine_num: 4, go func: 6</span><br><span class="line">goroutine_num: 4, go func: 8</span><br><span class="line">goroutine_num: 4, go func: 9</span><br><span class="line">goroutine_num: 4, go func: 7</span><br></pre></td></tr></table></figure>

<p><strong>无缓冲channel</strong></p>
<p>任务发送和执行分离，指定消费者并发协程数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 模拟用户请求数量</span></span><br><span class="line">    requestCount := <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;goroutine_num&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> Read(ch, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; requestCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _ = <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;goroutine_num: %d, go func: %d\n&quot;</span>, runtime.NumGoroutine(), i)</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码针对无缓冲的channel只有写，没有读，为什么不会出现阻塞？</p>
<p>for _ &#x3D; range ch  也是表示读channel </p>
<p>这和 &lt;-ch 读的 方式有什么区别？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是的，`for _ = range ch` 也表示从 channel 中读取数据。它和直接用 `&lt;-ch` 读取的方式有相似之处，但也有一些关键的区别。让我们来分析两者：</span><br><span class="line"></span><br><span class="line">### 1. `for _ = range ch`</span><br><span class="line">- **工作方式**：</span><br><span class="line">  当你使用 `for _ = range ch` 进行循环时，Go 会持续从 channel `ch` 中读取数据，直到这个 channel 被关闭。也就是说，`for range` 循环会一直阻塞，等待新的数据从 channel 中发送过来。一旦 channel 被关闭，循环会自动退出。</span><br><span class="line"></span><br><span class="line">- **自动处理 channel 关闭**：</span><br><span class="line">  `for range ch` 还有一个很重要的特点：当 channel 被关闭时，循环会自动终止。你不需要手动检测 channel 是否已经关闭。也就是说，`for range` 是一种简化的读取 channel 的方式，尤其在你需要持续读取 channel 并在 channel 关闭时结束时非常有用。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  ```go</span><br><span class="line">  ch := make(chan int)</span><br><span class="line">  go func() &#123;</span><br><span class="line">      for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">          ch &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">      close(ch) // 关闭 channel，for range 循环会自动退出</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  for v := range ch &#123;</span><br><span class="line">      fmt.Println(v) // 持续从 channel 读取值</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>for range</code> 会不断读取 channel 中的数据，直到 channel 被关闭，循环自动结束。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2. &lt;-ch 读取方式"></a>2. <code>&lt;-ch</code> 读取方式</h3><ul>
<li><p><strong>工作方式</strong>：<br>当你使用 <code>&lt;-ch</code> 读取 channel 的值时，它只是一次性从 channel 中读取一个值。如果 channel 中有值，它会立即读取并继续执行后续代码；如果 channel 中没有值，它会阻塞，直到有新的值可读取。</p>
</li>
<li><p><strong>手动检测 channel 是否关闭</strong>：<br>如果你使用 <code>&lt;-ch</code>，并且想要知道 channel 是否已经关闭，你需要显式使用第二个返回值，即：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// channel 已经关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received:&quot;</span>, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Channel closed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><p><strong>读取机制</strong>：</p>
<ul>
<li><code>for _ = range ch</code> 会持续读取 channel，直到 channel 被关闭。</li>
<li><code>&lt;-ch</code> 只读取一次。如果需要持续读取，必须显式地在循环中调用。</li>
</ul>
</li>
<li><p><strong>channel 关闭处理</strong>：</p>
<ul>
<li><code>for range</code> 在 channel 关闭时会自动退出循环。</li>
<li><code>&lt;-ch</code> 需要手动检测 channel 是否关闭，通过第二个返回值（<code>ok</code>）判断。</li>
</ul>
</li>
<li><p><strong>简洁性</strong>：</p>
<ul>
<li><code>for range</code> 适合在需要持续读取 channel 的情况下使用，并且简化了关闭 channel 时的处理。</li>
<li><code>&lt;-ch</code> 更灵活，适合在需要对每次读取做不同处理或更精细的控制时使用。</li>
</ul>
</li>
</ol>
<h3 id="什么时候用哪种方式？"><a href="#什么时候用哪种方式？" class="headerlink" title="什么时候用哪种方式？"></a>什么时候用哪种方式？</h3><ul>
<li>**<code>for range</code>**：适合持续从 channel 中读取数据，并且希望当 channel 关闭时自动结束读取过程。</li>
<li>**<code>&lt;-ch</code>**：适合需要单次读取或在读取时进行复杂控制的场景，比如明确判断 channel 是否关闭。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第七章：调度模型</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg -- 小徐先生的编程世界 -- Golang GMP 原理</span><br><span class="line"></span><br><span class="line">## 1.Go 线程实现模型？</span><br><span class="line"></span><br><span class="line">Go实现的是两级线程模型（M：N)，准确的说是GMP模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。</span><br><span class="line"></span><br><span class="line">### [#](https://vip.golangroadmap.com/class/gointerview/7-1.html#背景)背景</span><br><span class="line"></span><br><span class="line">|                 | 含义                                                         | 缺点                                                   |</span><br><span class="line">| --------------- | ------------------------------------------------------------ | ------------------------------------------------------ |</span><br><span class="line">| 单进程时代      | 每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程 | 1. 无法并发，只能串行 2. 进程阻塞所带来的 CPU 时间浪费 |</span><br><span class="line">| 多进程/线程时代 | 一个线程阻塞， cpu 可以立刻切换到其他线程中去执行            | 1. 进程/线程占用内存高 2. 进程/线程上下文切换成本高    |</span><br><span class="line">| 协程时代        | 协程（用户态线程）绑定线程（内核态线程），cpu调度线程执行    | 1. 实现起来较复杂，协程和线程的绑定依赖调度器算法      |</span><br><span class="line"></span><br><span class="line">线程 -&gt; CPU 由 操作系统 调度，协程 -&gt; 线程 由Go调度器来调度，协程与线程的映射关系有三种线程模型</span><br><span class="line"></span><br><span class="line">### [#](https://vip.golangroadmap.com/class/gointerview/7-1.html#三种线程模型)三种线程模型</span><br><span class="line"></span><br><span class="line">线程实现模型主要分为：`内核级线程模型`、`用户级线程模型`、`两级线程模型`，他们的区别在于用户线程与内核线程之间的对应关系。</span><br><span class="line"></span><br><span class="line">**内核级线程模型（1：1）**</span><br><span class="line"></span><br><span class="line">1个用户线程对应1个内核线程，这种最容易实现，协程的调度都由 CPU 完成了</span><br><span class="line"></span><br><span class="line">![img](golang面试/ult_klt_1_1.jpg)</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">- 实现起来最简单</span><br><span class="line">- 能够利用多核</span><br><span class="line">- 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">- 上下文切换成本高，创建、删除和切换都由 CPU 完成</span><br><span class="line"></span><br><span class="line">**用户级线程模型（N：1）**</span><br><span class="line"></span><br><span class="line">1个进程中的所有线程对应1个内核线程</span><br><span class="line"></span><br><span class="line">![img](golang面试/ult_klt_n_1.jpg)</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">- 上下文切换成本低，在用户态即可完成协程切换</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">- 无法利用多核</span><br><span class="line">- 一旦协程阻塞，造成线程阻塞，本线程的其它协程无法执行</span><br><span class="line"></span><br><span class="line">**两级线程模型（M：N)**</span><br><span class="line"></span><br><span class="line">M个线程对应N个内核线程</span><br><span class="line"></span><br><span class="line">![img](golang面试/ult_klt_n_m.jpg)</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">- 能够利用多核</span><br><span class="line">- 上下文切换成本低</span><br><span class="line">- 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">- 实现起来最复杂</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2.Go GMP和GM模型？</span><br><span class="line"></span><br><span class="line">什么才是一个好的调度器？</span><br><span class="line"></span><br><span class="line">能在适当的时机将合适的协程分配到合适的位置，保证公平和效率。</span><br><span class="line"></span><br><span class="line">Go采用了GMP模型（对两级线程模型的改进实现），使它能够更加灵活地进行线程之间的调度。</span><br><span class="line"></span><br><span class="line">### [#](https://vip.golangroadmap.com/class/gointerview/7-2.html#gmp模型)GMP模型</span><br><span class="line"></span><br><span class="line">GMP是Go运行时调度层面的实现，包含4个重要结构，分别是G、M、P、Sched</span><br><span class="line"></span><br><span class="line">![img](golang面试/image-20220419120403666.png)</span><br><span class="line"></span><br><span class="line">**G（Goroutine）**：代表Go 协程Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等。**G的数量无限制，理论上只受内存的影响**，创建一个 G 的初始栈大小为2-4K，配置一般的机器也能简简单单开启数十万个 Goroutine ，而且Go语言在 G 退出的时候还会把 G 清理之后放到 P 本地或者全局的闲置列表 gFree 中以便复用。</span><br><span class="line"></span><br><span class="line">**M（Machine）**： Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程，想要在 CPU 上执行代码必须有线程，通过系统调用 clone 创建。M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。**M的数量有限制，默认数量限制是 10000**，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。</span><br><span class="line"></span><br><span class="line">**P（Processor）：虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来。P 的数量决定了系统内最大可并行的 G 的数量，**P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。</span><br><span class="line"></span><br><span class="line">**Sched：调度器结构**，它维护有存储M和G的全局队列，以及调度器的一些状态信息</span><br><span class="line"></span><br><span class="line">|          | G                      | M                                                          | P                                                       |</span><br><span class="line">| -------- | ---------------------- | ---------------------------------------------------------- | ------------------------------------------------------- |</span><br><span class="line">| 数量限制 | 无限制，受机器内存影响 | 有限制，默认最多10000                                      | 有限制，最多GOMAXPROCS个                                |</span><br><span class="line">| 创建时机 | go func                | 当没有足够的M来关联P并运行其中的可运行的G时会请求创建新的M | 在确定了P的最大数量n后，运行时系统会根据这个数量创建个P |</span><br><span class="line"></span><br><span class="line">**核心数据结构:**</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type g struct &#123;</span><br><span class="line">    goid    int64 // 唯一的goroutine的ID</span><br><span class="line">    sched gobuf // goroutine切换时，用于保存g的上下文</span><br><span class="line">    stack stack // 栈</span><br><span class="line">  gopc        // pc of go statement that created this goroutine</span><br><span class="line">    startpc    uintptr // pc of goroutine function</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type p struct &#123;</span><br><span class="line">    lock mutex</span><br><span class="line">    id          int32</span><br><span class="line">    status      uint32 // one of pidle/prunning/...</span><br><span class="line"></span><br><span class="line">    // Queue of runnable goroutines. Accessed without lock.</span><br><span class="line">    runqhead uint32 // 本地队列队头</span><br><span class="line">    runqtail uint32 // 本地队列队尾</span><br><span class="line">    runq     [256]guintptr // 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高</span><br><span class="line">    runnext guintptr // 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type m struct &#123;</span><br><span class="line">    g0            *g     </span><br><span class="line">    // 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度</span><br><span class="line">    curg          *g    </span><br><span class="line">    // 当前正在执行的G</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type schedt struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    runq     gQueue // 全局队列，链表（长度无限制）</span><br><span class="line">    runqsize int32  // 全局队列长度</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>GMP模型的实现算是Go调度器的一大进步，但调度器仍然有一个令人头疼的问题，那就是不支持抢占式调度，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现“饿死”的情况。</p>
<p>当只有一个 P（GOMAXPROCS&#x3D;1）时，整个 Go 程序中的其他 G 都将“饿死”。于是在 Go 1.2 版本中实现了基于协作的“抢占式”调度，在Go 1.14 版本中实现了基于信号的“抢占式”调度。</p>
<h3 id="GM模型"><a href="#GM模型" class="headerlink" title="#GM模型"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-2.html#gm%E6%A8%A1%E5%9E%8B">#</a>GM模型</h3><p>Go早期是GM模型，没有P组件</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220412194120600.png" alt="img"></p>
<p>**GM调度存在的问题： **</p>
<ol>
<li><strong>全局队列的锁竞争</strong>，当 M 从全局队列中添加或者获取 G 的时候，都需要获取队列锁，导致激烈的锁竞争</li>
<li><strong>M 转移 G 增加额外开销</strong>，当 M1 在执行 G1 的时候， M1 创建了 G2，为了继续执行 G1，需要把 G2 保存到全局队列中，无法保证G2是被M1处理。因为 M1 原本就保存了 G2 的信息，所以 G2 最好是在 M1 上执行，这样的话也不需要转移G到全局队列和线程上下文切换</li>
<li><strong>线程使用效率不能最大化</strong>，没有<strong>work-stealing</strong> 和<strong>hand-off</strong> 机制</li>
</ol>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，为了解决这一的问题 go 从 1.1 版本引入P，在运行时系统的时候加入 P 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理 的 G</p>
<h2 id="3-Go-调度原理？"><a href="#3-Go-调度原理？" class="headerlink" title="3.Go 调度原理？"></a>3.Go 调度原理？</h2><p>CPU感知不到Goroutine，只知道内核线程，所以需要<strong>Go调度器</strong>将协程调度到内核线程上面去，然后<strong>操作系统调度器</strong>将内核线程放到CPU上去执行</p>
<p>M是对内核级线程的封装，<strong>所以Go调度器的工作就是将G分配到M</strong></p>
<p>Go 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的 GM 模型、到 GMP模型，从<strong>不支持抢占</strong>，到<strong>支持协作式抢占</strong>，再到<strong>支持基于信号的异步抢占</strong>，经历了不断地优化与打磨。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="#设计思想"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">#</a>设计思想</h3><ul>
<li>线程复用（<strong>work stealing 机制</strong>和<strong>hand off 机制</strong>）</li>
<li>利用并行（利用多核CPU）</li>
<li>抢占调度（解决公平性问题）</li>
</ul>
<h3 id="调度对象"><a href="#调度对象" class="headerlink" title="#调度对象"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E5%AF%B9%E8%B1%A1">#</a>调度对象</h3><p>Go 调度器</p>
<blockquote>
<p>Go 调度器是属于Go runtime中的一部分，Go runtime负责实现Go的<strong>并发调度</strong>、<strong>垃圾回收</strong>、<strong>内存堆栈管理</strong>等关键功能</p>
</blockquote>
<h3 id="被调度对象"><a href="#被调度对象" class="headerlink" title="#被调度对象"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%A2%AB%E8%B0%83%E5%BA%A6%E5%AF%B9%E8%B1%A1">#</a>被调度对象</h3><p>G的来源</p>
<ul>
<li>P的runnext（只有1个G，局部性原理，永远会被最先调度执行）</li>
<li>P的本地队列（数组，最多256个G）</li>
<li>全局G队列（链表，无限制）</li>
<li>网络轮询器<em>network poller</em>（存放网络调用被阻塞的G）</li>
</ul>
<p>P的来源</p>
<ul>
<li>全局P队列（数组，GOMAXPROCS个P）</li>
</ul>
<p>M的来源</p>
<ul>
<li>休眠线程队列（未绑定P，长时间休眠会等待GC回收销毁）</li>
<li>运行线程（绑定P，指向P中的G）</li>
<li>自旋线程（绑定P，指向M的G0）</li>
</ul>
<p>其中运行线程数 + 自旋线程数 &lt;&#x3D; P的数量（GOMAXPROCS），M个数 &gt;&#x3D; P个数</p>
<h3 id="调度流程"><a href="#调度流程" class="headerlink" title="#调度流程"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">#</a>调度流程</h3><p>协程的调度采用了生产者-消费者模型，实现了用户任务与调度器的解耦</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419200002580.png" alt="img"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/ddyl519.jpg" alt="img"></p>
<p>生产端我们开启的每个协程都是一个计算任务，这些任务会被提交给 go 的 runtime。如果计算任务非常多，有成千上万个，那么这些任务是不可能同时被立刻执行的，所以这个计算任务一定会被先暂存起来，一般的做法是放到内存的队列中等待被执行。</p>
<p>G的生命周期：G 从创建、保存、被获取、调度和执行、阻塞、销毁，步骤如下：</p>
<p><strong>步骤 1：创建 G</strong>，关键字 <code>go func()</code> 创建 G <strong>步骤 2：保存 G</strong>，创建的 G 优先保存到本地队列 P，如果 P 满了，则会平衡部分P到全局队列中</p>
<p><strong>步骤3</strong>：<strong>唤醒或者新建M</strong>执行任务，进入调度循环（步骤4,5,6)</p>
<p><strong>步骤 4：M 获取 G</strong>，M首先从P的本地队列获取 G，如果 P为空，则从全局队列获取 G，如果全局队列也为空，则从另一个本地队列偷取一半数量的 G（负载均衡），这种从其它P偷的方式称之为 work stealing</p>
<p><strong>步骤 5：M 调度和执行 G</strong>，M调用 <code>G.func()</code> 函数执行 G</p>
<ul>
<li>如果 M在执行 G 的过程发生<strong>系统调用阻塞</strong>（同步），会阻塞G和M（操作系统限制），此时P会和当前M解绑，并寻找新的M，如果没有空闲的M就会新建一个M ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当<strong>系统调用结束</strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。</li>
<li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，<strong>不会阻塞M</strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I&#x2F;O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</li>
</ul>
<p><strong>步骤6：M执行完G后清理现场</strong>，重新进入调度循环（将M上运⾏的goroutine切换为G0，G0负责调度时协程的切换）</p>
<p>其中步骤2中保存 G的详细流程如下：</p>
<ul>
<li>执行 go func 的时候，主线程 M0 会调用 newproc()生成一个 G 结构体，这里会先选定当前 M0 上的 P 结构</li>
<li>每个协程 G 都会被尝试先放到 P 中的 runnext，若 runnext 为空则放到 runnext 中，生产结束</li>
<li>若 runnext 满，则将原来 runnext 中的 G 踢到本地队列中，将当前 G 放到 runnext 中，生产结束</li>
<li>若本地队列也满了，则将本地队列中的 G 拿出一半，放到全局队列中，生产结束。</li>
</ul>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/33653a35dca9472fd1e487d3a94557c6.png" alt="img"></p>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="#调度时机"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">#</a>调度时机</h3><p><strong>什么时候进行调度（执行&#x2F;切换）？</strong></p>
<p>在以下情形下，会切换正在执行的goroutine</p>
<ul>
<li>抢占式调度<ul>
<li>sysmon 检测到协程运行过久（比如sleep，死循环）<ul>
<li>切换到g0，进入调度循环</li>
</ul>
</li>
</ul>
</li>
<li>主动调度<ul>
<li>新起一个协程和协程执行完毕<ul>
<li>触发调度循环</li>
</ul>
</li>
<li>主动调用runtime.Gosched()<ul>
<li>切换到g0，进入调度循环</li>
</ul>
</li>
<li>垃圾回收之后<ul>
<li>stw之后，会重新选择g开始执行</li>
</ul>
</li>
</ul>
</li>
<li>被动调度<ul>
<li>系统调用（比如文件IO）阻塞（同步）<ul>
<li>阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G</li>
</ul>
</li>
<li>网络IO调用阻塞（异步）<ul>
<li>阻塞G，G移动到NetPoller，M执行P的剩余G</li>
</ul>
</li>
<li>atomic&#x2F;mutex&#x2F;channel等阻塞（异步）<ul>
<li>阻塞G，G移动到channel的等待队列中，M执行P的剩余G</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="#调度策略"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5">#</a>调度策略</h3><p><strong>使用什么策略来挑选下一个goroutine执行？</strong></p>
<p>由于 P 中的 G 分布在 runnext、本地队列、全局队列、网络轮询器中，则需要挨个判断是否有可执行的 G，大体逻辑如下：</p>
<ul>
<li>每执行61次调度循环，从全局队列获取G，若有则直接返回</li>
<li>从P 上的 runnext 看一下是否有 G，若有则直接返回</li>
<li>从P 上的 本地队列 看一下是否有 G，若有则直接返回</li>
<li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他 P 中窃取，<strong>一直阻塞</strong>直到获取到一个可用的 G 为止</li>
</ul>
<p>源码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 每执行61次调度循环会看一下全局队列。为了保证公平，避免全局队列一直无法得到执行的情况，当全局运行队列中有待执行的G时，通过schedtick保证有一定几率会从全局的运行队列中查找对应的Goroutine；</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 先尝试从P的runnext和本地队列查找G</span></span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 仍找不到，去全局队列中查找。还找不到，要去网络轮询器中查找是否有G等待运行；仍找不到，则尝试从其他P中窃取G来执行。</span></span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">        <span class="comment">// 这个函数是阻塞的，执行到这里一定会获取到一个可执行的G</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用execute，继续调度循环</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从全局队列查找时，如果要所有 P 平分全局队列中的 G，每个 P 要分得多少个，这里假设会分得 n 个。然后把这 n 个 G，转移到当前 G 所在 P 的本地队列中去。但是最多不能超过 P 本地队列长度的一半（即 128）。这样做的目的是，如果下次调度循环到来的时候，就不必去加锁到全局队列中在获取一次 G 了，性能得到了很好的保障。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(_p_ *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// gomaxprocs = p的数量</span></span><br><span class="line">   <span class="comment">// sched.runqsize是全局队列长度</span></span><br><span class="line">   <span class="comment">// 这里n = 全局队列的G平分到每个P本地队列上的数量 + 1</span></span><br><span class="line">   n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">      n = sched.runqsize</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">      n = max</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 平分后的数量n不能超过本地队列长度的一半，也就是128</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq))/<span class="number">2</span> &#123;</span><br><span class="line">      n = <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq)) / <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行将G从全局队列中取n个分到当前P本地队列的操作</span></span><br><span class="line">   sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">   gp := sched.runq.pop()</span><br><span class="line">   n--</span><br><span class="line">   <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">      gp1 := sched.runq.pop()</span><br><span class="line">      runqput(_p_, gp1, <span class="literal">false</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从其它P查找时，会偷一半的G过来放到当前P的本地队列</p>
<h2 id="4-Go-work-stealing-机制？"><a href="#4-Go-work-stealing-机制？" class="headerlink" title="4.Go work stealing 机制？"></a>4.Go work stealing 机制？</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>当线程M⽆可运⾏的G时，尝试从其他M绑定的P偷取G，减少空转，提高了线程利用率（避免闲着不干活）。</p>
<p>当从本线程绑定 P 本地 队列、全局G队列、netpoller都找不到可执行的 g，会从别的 P 里窃取G并放到当前P上面。</p>
<p>从<em>netpoller</em> 中拿到的G是_Gwaiting状态（ 存放的是因为网络IO被阻塞的G），从其它地方拿到的G是_Grunnable状态</p>
<p>从全局队列取的G数量：N &#x3D; min(len(GRQ)&#x2F;GOMAXPROCS + 1, len(GRQ&#x2F;2)) （根据GOMAXPROCS负载均衡）</p>
<p>从其它P本地队列<strong>窃取</strong>的G数量：N &#x3D; len(LRQ)&#x2F;2（平分）</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419153014030.png" alt="img"></p>
<h3 id="窃取流程"><a href="#窃取流程" class="headerlink" title="#窃取流程"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E7%AA%83%E5%8F%96%E6%B5%81%E7%A8%8B">#</a>窃取流程</h3><p>源码见runtime&#x2F;proc.go stealWork函数，窃取流程如下，如果经过多次努力一直找不到需要运行的goroutine则调用stopm进入睡眠状态，等待被其它工作线程唤醒。</p>
<ol>
<li>选择要窃取的P</li>
<li>从P中偷走一半G</li>
</ol>
<h4 id="选择要窃取的P"><a href="#选择要窃取的P" class="headerlink" title="#选择要窃取的P"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E9%80%89%E6%8B%A9%E8%A6%81%E7%AA%83%E5%8F%96%E7%9A%84p">#</a><strong>选择要窃取的P</strong></h4><p>窃取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列</p>
<p>为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p，而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offset := <span class="type">uint32</span>(random()) % nprocs</span><br><span class="line">coprime := 随机选取一个小于nprocs且与nprocs互质的数</span><br><span class="line"><span class="keyword">const</span> stealTries = <span class="number">4</span> <span class="comment">// 最多重试4次</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nprocs; i++ &#123;</span><br><span class="line">      p := allp[offset]</span><br><span class="line">        从p的运行队列偷取goroutine</span><br><span class="line">        <span class="keyword">if</span> 偷取成功 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">     &#125;</span><br><span class="line">        offset += coprime</span><br><span class="line">        offset = offset % nprocs</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到只要随机数不一样，偷取p的顺序也不一样，但可以保证经过nprocs次循环，每个p都会被访问到。</p>
<h4 id="从P中偷走一半G"><a href="#从P中偷走一半G" class="headerlink" title="#从P中偷走一半G"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E4%BB%8Ep%E4%B8%AD%E5%81%B7%E8%B5%B0%E4%B8%80%E5%8D%8Ag">#</a><strong>从P中偷走一半G</strong></h4><p>源码见runtime&#x2F;proc.go runqsteal函数：</p>
<p>挑选出盗取的对象p之后，则调用runqsteal盗取p的运行队列中的goroutine，runqsteal函数再调用runqgrap从p的本地队列尾部批量偷走一半的g</p>
<p>为啥是偷一半的g，可以理解为负载均衡</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(_p_ *p, batch *[256]guintptr, batchHead <span class="type">uint32</span>, stealRunNextG <span class="type">bool</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">        t := atomic.LoadAcq(&amp;_p_.runqtail) <span class="comment">// load-acquire, synchronize with the producer</span></span><br><span class="line">        n := t - h        <span class="comment">//计算队列中有多少个goroutine</span></span><br><span class="line">        n = n - n/<span class="number">2</span>     <span class="comment">//取队列中goroutine个数的一半</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-Go-hand-off-机制？"><a href="#5-Go-hand-off-机制？" class="headerlink" title="5.Go hand off 机制？"></a>5.Go hand off 机制？</h2><p><a href="https://vip.golangroadmap.com/class/gointerview/7-5.html#%E6%A6%82%E5%BF%B5">#</a>概念</p>
<p>也称为P分离机制，当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率（避免站着茅坑不拉shi）。</p>
<h3 id="分离流程"><a href="#分离流程" class="headerlink" title="#分离流程"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-5.html#%E5%88%86%E7%A6%BB%E6%B5%81%E7%A8%8B">#</a>分离流程</h3><p>当前线程M阻塞时，释放P，给其它空闲的M处理</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419152721948.png" alt="img"></p>
<h2 id="6-Go-抢占式调度？"><a href="#6-Go-抢占式调度？" class="headerlink" title="6.Go 抢占式调度？"></a>6.Go 抢占式调度？</h2><p>在1.2版本之前，Go的调度器仍然不支持抢占式调度，程序只能依靠Goroutine主动让出CPU资源才能触发调度，这会引发一些问题，比如：</p>
<ul>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿</li>
<li>垃圾回收器是需要stop the world的，如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine停下来，这会造成较长时间的等待时间</li>
</ul>
<p>为解决这个问题：</p>
<ul>
<li>Go 1.2 中实现了基于协作的“抢占式”调度</li>
<li>Go 1.14 中实现了基于信号的“抢占式”调度</li>
</ul>
<h3 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="#基于协作的抢占式调度"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-6.html#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">#</a>基于协作的抢占式调度</h3><p>协作式：大家都按事先定义好的规则来，比如：一个goroutine执行完后，退出，让出p，然后下一个goroutine被调度到p上运行。这样做的缺点就在于 是否让出p的决定权在groutine自身。一旦某个g不主动让出p或执行时间较长，那么后面的goroutine只能等着，没有方法让前者让出p，导致延迟甚至饿死。</p>
<p>非协作式: 就是由runtime来决定一个goroutine运行多长时间，如果你不主动让出，对不起，我有手段可以抢占你，把你踢出去，让后面的goroutine进来运行。</p>
<p>基于协作的抢占式调度流程：</p>
<ul>
<li>编译器会在调用函数前插入 runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占调度</li>
<li>Go语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms，那么会在这个协程设置一个抢占标记</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack会检查抢占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里</li>
</ul>
<p>这种解决方案只能说局部解决了“饿死”问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。</p>
<p>比如，死循环等并没有给编译器插入抢占代码的机会，以下程序在 go 1.14 之前的 go版本中，运行后会一直卡住，而不会打印 <code>I got scheduled!</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;I got scheduled!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这些问题，<strong>Go 在 1.14 版本中增加了对非协作的抢占式调度的支持</strong>，这种<strong>抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行的 Goroutine</strong></p>
<h3 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="#基于信号的抢占式调度"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-6.html#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">#</a>基于信号的抢占式调度</h3><p>真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。不管协程有没有意愿主动让出 cpu 运行权，只要某个协程执行时间过长，就会发送信号强行夺取 cpu 运行权。</p>
<ul>
<li>M 注册一个 SIGURG 信号的处理函数：sighandler</li>
<li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占P超过10ms，会给M发送抢占信号</li>
<li>M 收到信号后，内核执行 sighandler 函数把当前协程的状态从_Grunning正在执行改成 _Grunnable可执行，把抢占的协程放到全局队列里，M继续寻找其他 goroutine 来运行</li>
<li>被抢占的 G 再次调度过来执行时，会继续原来的执行流</li>
</ul>
<p>抢占分为<code>_Prunning</code>和<code>_Psyscall</code>，<code>_Psyscall</code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。<code>_Prunning</code>抢占通常是由于一些类似死循环的计算逻辑引起的。</p>
<h2 id="7-Go-如何查看运行时调度信息？"><a href="#7-Go-如何查看运行时调度信息？" class="headerlink" title="7.Go 如何查看运行时调度信息？"></a>7.Go 如何查看运行时调度信息？</h2><p>有 2 种方式可以查看一个程序的调度GMP信息，分别是go tool trace和GODEBUG</p>
<p>trace.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="go-tool-trace"><a href="#go-tool-trace" class="headerlink" title="#go tool trace"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-7.html#go-tool-trace">#</a>go tool trace</h3><p>启动可视化界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run trace.go</span><br><span class="line">go tool trace trace.out</span><br><span class="line">2022/04/22 10:44:11 Parsing trace...</span><br><span class="line">2022/04/22 10:44:11 Splitting trace...</span><br><span class="line">2022/04/22 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:35488</span><br></pre></td></tr></table></figure>



<p><strong>1.打开 <code>http://127.0.0.1:35488</code> 查看可视化界面：</strong></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422214355669.png" alt="img"></p>
<p>点击 <code>view trace</code> 能够看见可视化的调度流程：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422213604926.png" alt="img"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422210738598.png" alt="img"></p>
<p>一共有2个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，另外一个是G1 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>2. 点击 Threads 那一行可视化的数据条，我们会看到M详细的信息</strong></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422211223494.png" alt="img"></p>
<p>一共有2个 M 在程序中，一个是特殊的 M0，用于初始化使用，另外一个是用于执行G1的M1</p>
<p><strong>3. 点击 Proc 那一行可视化的数据条，我们会看到P上正在运行goroutine详细的信息</strong></p>
<p>一共有3个 P 在程序中，分别是P0、P1、P2</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422212719433.png" alt="img"></p>
<p>点击具体的 Goroutine 行为后可以看到其相关联的详细信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Start：开始时间</span><br><span class="line">Wall Duration：持续时间</span><br><span class="line">Self Time：执行时间</span><br><span class="line">Start Stack Trace：开始时的堆栈信息</span><br><span class="line">End Stack Trace：结束时的堆栈信息</span><br><span class="line">Incoming flow：输入流</span><br><span class="line">Outgoing flow：输出流</span><br><span class="line">Preceding events：之前的事件</span><br><span class="line">Following events：之后的事件</span><br><span class="line">All connected：所有连接的事件</span><br></pre></td></tr></table></figure>



<h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="#GODEBUG"></a><a href="https://vip.golangroadmap.com/class/gointerview/7-7.html#godebug">#</a>GODEBUG</h3><p>GODEBUG 变量可以控制运行时内的调试变量。查看调度器信息，将会使用如下两个参数：</p>
<ul>
<li>schedtrace：设置 <code>schedtrace=X</code> 参数可以使运行时在每 X 毫秒发出一行调度器的摘要信息到标准 err 输出中。</li>
<li>scheddetail：设置 <code>schedtrace=X</code> 和 <code>scheddetail=1</code> 可以使运行时在每 X 毫秒发出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程 和 Goroutine 的状态。</li>
</ul>
<p><strong>查看基本信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build trace.go</span><br><span class="line">GODEBUG=schedtrace=1000 ./trace</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1010ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3024ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4027ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 5029ms: gomaxprocs=8 idleprocs=7 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>



<p>sched：每一行都代表调度器的调试信息，后面提示的毫秒数表示启动到现在的运行时间，输出的时间间隔受 <code>schedtrace</code> 的值影响。</p>
<p>gomaxprocs：当前的 CPU 核心数（GOMAXPROCS 的当前值）。</p>
<p>idleprocs：空闲的处理器数量，后面的数字表示当前的空闲数量。</p>
<p>threads：OS 线程数量，后面的数字表示当前正在运行的线程数量。</p>
<p>spinningthreads：自旋状态的 OS 线程数量。</p>
<p>idlethreads：空闲的线程数量。</p>
<p>runqueue：全局队列中中的 Goroutine 数量，而后面的[0 0 0 0 0 0 0 0] 则分别代表这 8 个 P 的本地队列正在运行的 Goroutine 数量。</p>
<p><strong>查看详细信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build trace.go</span><br><span class="line">GODEBUG=scheddetail=1,schedtrace=1000 ./trace</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0</span><br><span class="line">  P0: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=1 gfreecnt=0 timerslen=0</span><br><span class="line">  P1: status=1 schedtick=0 syscalltick=0 m=2 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  M3: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M2: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=1</span><br><span class="line">  G1: status=1(chan receive) m=-1 lockedm=0</span><br><span class="line">  G2: status=1() m=-1 lockedm=-1</span><br><span class="line">  G3: status=1() m=-1 lockedm=-1</span><br><span class="line">  G4: status=4(GC scavenge <span class="built_in">wait</span>) m=-1 lockedm=-1</span><br></pre></td></tr></table></figure>



<p>G</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">status：G 的运行状态。</span><br><span class="line">m：隶属哪一个 M。</span><br><span class="line">lockedm：是否有锁定 M。</span><br></pre></td></tr></table></figure>



<p>G 的运行状态共涉及如下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_Gidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行初始化。</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>1</td>
<td>已经在运行队列中，还没有执行用户代码。</td>
</tr>
<tr>
<td>_Grunning</td>
<td>2</td>
<td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>正在执行系统调用，此时分配了 M。</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td>
</tr>
<tr>
<td>_Gmoribund_unused</td>
<td>5</td>
<td>尚未使用，但是在 gdb 中进行了硬编码。</td>
</tr>
<tr>
<td>_Gdead</td>
<td>6</td>
<td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td>
</tr>
<tr>
<td>_Genqueue_unused</td>
<td>7</td>
<td>尚未使用。</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>8</td>
<td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td>
</tr>
</tbody></table>
<p>M</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p：隶属哪一个 P。</span><br><span class="line">curg：当前正在使用哪个 G。</span><br><span class="line">runqsize：运行队列中的 G 数量。</span><br><span class="line">gfreecnt：可用的G（状态为 Gdead）。</span><br><span class="line">mallocing：是否正在分配内存。</span><br><span class="line">throwing：是否抛出异常。</span><br><span class="line">preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。</span><br></pre></td></tr></table></figure>



<p>P</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">status：P 的运行状态。</span><br><span class="line">schedtick：P 的调度次数。</span><br><span class="line">syscalltick：P 的系统调用次数。</span><br><span class="line">m：隶属哪一个 M。</span><br><span class="line">runqsize：运行队列中的 G 数量。</span><br><span class="line">gfreecnt：可用的G（状态为 Gdead）</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_Pidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行进行初始化。</td>
</tr>
<tr>
<td>_Prunning</td>
<td>1</td>
<td>当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。</td>
</tr>
<tr>
<td>_Psyscall</td>
<td>2</td>
<td>正在执行系统调用。</td>
</tr>
<tr>
<td>_Pgcstop</td>
<td>3</td>
<td>暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。</td>
</tr>
<tr>
<td>_Pdead</td>
<td>4</td>
<td>废弃，不再使用。</td>
</tr>
</tbody></table>
<h1 id="第八章：内存管理"><a href="#第八章：内存管理" class="headerlink" title="第八章：内存管理"></a>第八章：内存管理</h1><h2 id="1-Go-内存分配机制？"><a href="#1-Go-内存分配机制？" class="headerlink" title="1.Go 内存分配机制？"></a>1.Go 内存分配机制？</h2><hr>
<p><a href="https://mp.weixin.qq.com/s/2TBwpQT5-zU4Gy7-i0LZmQ">https://mp.weixin.qq.com/s/2TBwpQT5-zU4Gy7-i0LZmQ</a> – Golang 内存模型与分配机制（小徐先生的编程世界）</p>
<p><a href="https://www.bilibili.com/video/BV1bv411c7bp?p=6&spm_id_from=pageDriver&vd_source=51d632fc88dc2672d78996251d66eda0">https://www.bilibili.com/video/BV1bv411c7bp?p=6&amp;spm_id_from=pageDriver&amp;vd_source=51d632fc88dc2672d78996251d66eda0</a></p>
<hr>
<p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p>
<h3 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h3><ul>
<li>内存分配算法采用Google的<code>TCMalloc算法</code>，每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争</li>
<li>把内存切分的非常的细小，分为多级管理，以降低锁的粒度</li>
<li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li>
</ul>
<h3 id="分配组件"><a href="#分配组件" class="headerlink" title="分配组件"></a>分配组件</h3><p>Go的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code>和<code>mheap</code></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220501185553347.png" alt="img"></p>
<h4 id="内存管理单元：mspan"><a href="#内存管理单元：mspan" class="headerlink" title="内存管理单元：mspan"></a>内存管理单元：mspan</h4><p><code>mspan</code>是 内存管理的基本单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个mspan，每个<code>mspan</code> 都管理 <code>npages</code> 个大小为 8KB 的页，一个span 是由多个page组成的，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。</p>
<p><code>page</code>是内存存储的基本单元，“对象”放到<code>page</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan <span class="comment">// 后指针</span></span><br><span class="line">    prev *mspan <span class="comment">// 前指针</span></span><br><span class="line">    startAddr <span class="type">uintptr</span> <span class="comment">// 管理页的起始地址，指向page</span></span><br><span class="line">    npages    <span class="type">uintptr</span> <span class="comment">// 页数</span></span><br><span class="line">    spanclass   spanClass <span class="comment">// 规格</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> spanClass <span class="type">uint8</span></span><br></pre></td></tr></table></figure>

<p>Go有68种不同大小的spanClass，用于小对象的分配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const _NumSizeClasses = 68</span><br><span class="line">var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure>

<p>如果按照序号为1的spanClass（对象规格为8B）分配，每个span占用堆的字节数：8k，mspan可以保存1024个对象</p>
<p>如果按照序号为2的spanClass（对象规格为16B）分配，每个span占用堆的字节数：8k，mspan可以保存512个对象</p>
<p>…</p>
<p>如果按照序号为67的spanClass（对象规格为32K）分配，每个span占用堆的字节数：32k，mspan可以保存1个对象</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg4NzQ0,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>字段含义：</p>
<ul>
<li>class： class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型</li>
<li>bytes&#x2F;obj：该class代表对象的字节数</li>
<li>bytes&#x2F;span：每个span占用堆的字节数，也即页数*页大小</li>
<li>objects: 每个span可分配的对象个数，也即（bytes&#x2F;spans）&#x2F;（bytes&#x2F;obj）</li>
<li>waste bytes: 每个span产生的内存碎片，也即（bytes&#x2F;spans）%（bytes&#x2F;obj）</li>
</ul>
<p>大于32k的对象出现时，会直接从heap分配一个特殊的span，这个特殊的span的类型(class)是0, 只包含了一个大对象</p>
<h4 id="线程缓存：mcache"><a href="#线程缓存：mcache" class="headerlink" title="线程缓存：mcache"></a>线程缓存：mcache</h4><p>mcache管理线程在本地缓存的mspan，每个goroutine绑定的P都有一个<code>mcache</code>字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [numSpanClasses]*mspan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_NumSizeClasses = <span class="number">68</span></span><br><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>68*2=136</code>，其中*2是将spanClass分成了有指针和没有指针两种,方便与垃圾回收。对于每种规格，有2个mspan，一个mspan不包含指针，另一个mspan则包含指针。对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。</p>
<p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p>
<h4 id="中心缓存：mcentral"><a href="#中心缓存：mcentral" class="headerlink" title="中心缓存：mcentral"></a>中心缓存：mcentral</h4><p>mcentral管理全局的mspan供所有线程使用，全局mheap变量包含central字段，每个 mcentral 结构都维护在<strong>mheap</strong>结构内</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    spanclass spanClass <span class="comment">// 指当前规格大小</span></span><br><span class="line"></span><br><span class="line">    partial [<span class="number">2</span>]spanSet <span class="comment">// 有空闲object的mspan列表</span></span><br><span class="line">    full    [<span class="number">2</span>]spanSet <span class="comment">// 没有空闲object的mspan列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个mcentral管理一种spanClass的mspan，并将有空闲空间和没有空闲空间的mspan分开管理。partial和 full<code>的数据类型为</code>spanSet，表示 <code>mspans</code>集，可以通过pop、push来获得mspans</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> spanSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    spineLock mutex</span><br><span class="line">    spine     unsafe.Pointer <span class="comment">// 指向[]span的指针</span></span><br><span class="line">    spineLen  <span class="type">uintptr</span>        <span class="comment">// Spine array length, accessed atomically</span></span><br><span class="line">    spineCap  <span class="type">uintptr</span>        <span class="comment">// Spine array cap, accessed under lock</span></span><br><span class="line"></span><br><span class="line">    index headTailIndex  <span class="comment">// 前32位是头指针，后32位是尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p>
<ul>
<li>获取； 加锁，从<code>partial</code>链表找到一个可用的<code>mspan</code>；并将其从<code>partial</code>链表删除；将取出的<code>mspan</code>加入到<code>full</code>链表；将<code>mspan</code>返回给工作线程，解锁。</li>
<li>归还； 加锁，将<code>mspan</code>从<code>full</code>链表删除；将<code>mspan</code>加入到<code>partial</code>链表，解锁。</li>
</ul>
<h4 id="页堆：mheap"><a href="#页堆：mheap" class="headerlink" title="页堆：mheap"></a>页堆：mheap</h4><p>mheap管理Go的所有动态分配内存，可以认为是Go程序持有的整个堆空间，全局唯一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mheap_ mheap</span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex    <span class="comment">// 全局锁</span></span><br><span class="line">    pages     pageAlloc <span class="comment">// 页面分配的数据结构</span></span><br><span class="line">    allspans []*mspan <span class="comment">// 所有通过 mheap_ 申请的mspans</span></span><br><span class="line">        <span class="comment">// 堆</span></span><br><span class="line">    arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 所有中心缓存mcentral</span></span><br><span class="line">    central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有<code>mcentral</code>的集合则是存放于<code>mheap</code>中的。<code>mheap</code>里的<code>arena</code> 区域是堆内存的抽象，运行时会将 <code>8KB</code> 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。</p>
<p>当申请内存时，依次经过 <code>mcache</code> 和 <code>mcentral</code> 都没有可用合适规格的大小内存，这时候会向 <code>mheap</code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 <code>mcentral</code> 的 <code>非空闲列表</code> 后面</p>
<h3 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h3><ul>
<li>微对象 (0, 16B)：先使用线程缓存上的微型分配器，再依次尝试线程缓存、中心缓存、堆 分配内存；</li>
<li>小对象 [16B, 32KB]：依次尝试线程缓存、中心缓存、堆 分配内存；</li>
<li>大对象 (32KB, +∞)：直接尝试堆分配内存；</li>
</ul>
<h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><p>Golang 中，依据 object 的大小，会将其分为下述三类：</p>
<img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640-20241011165748267" alt="图片" style="zoom: 33%;">

 

<p>不同类型的对象，会有着不同的分配策略，这些内容在 mallocgc 方法中都有体现.</p>
<p>核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p>
<p>对于微对象的分配流程：</p>
<p>（1）从 P 专属 mcache 的 tiny 分配器取内存（无锁）</p>
<p>（2）根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</p>
<p>（3）根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</p>
<p>（4）根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</p>
<p>（5）mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复（4）.</p>
<p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步；</p>
<p>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步.</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640" alt="图片"> </p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20241011165919471.png" alt="image-20241011165919471"></p>
<h2 id="2-Go-内存逃逸机制？"><a href="#2-Go-内存逃逸机制？" class="headerlink" title="2.Go 内存逃逸机制？"></a>2.Go 内存逃逸机制？</h2><hr>
<h3 id="概念-6"><a href="#概念-6" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从”栈”上逃逸到”堆”上的现象就成为内存逃逸。</p>
<p>在栈上分配的地址，一般由系统申请和释放，不会有额外性能的开销，比如函数的入参、局部变量、返回值等。在堆上分配的内存，如果要回收掉，需要进行 GC，那么GC 一定会带来额外的性能开销。编程语言不断优化GC算法，主要目的都是为了减少 GC带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<h3 id="逃逸机制"><a href="#逃逸机制" class="headerlink" title="#逃逸机制"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6">#</a>逃逸机制</h3><p>编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中;</li>
<li>如果栈上放不下，则必定放到堆上;</li>
</ol>
<p>逃逸分析也就是由编译器决定哪些变量放在栈，哪些放在堆中，通过编译参数<code>-gcflag=-m</code>可以查看编译过程中的逃逸分析，发生逃逸的几种场景如下：</p>
<h4 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="#指针逃逸"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%8C%87%E9%92%88%E9%80%83%E9%80%B8">#</a>指针逃逸</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func escape1() *int &#123;</span><br><span class="line">    var a int = 1</span><br><span class="line">    <span class="built_in">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    escape1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main.go:4:6: moved to heap: a</span><br></pre></td></tr></table></figure>

<p>函数返回值为局部变量的指针，函数虽然退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</p>
<h4 id="栈空间不足"><a href="#栈空间不足" class="headerlink" title="#栈空间不足"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%A0%88%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3">#</a>栈空间不足</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main.go:4:11: make([]int, 10000, 10000) escapes to heap</span><br></pre></td></tr></table></figure>

<p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量s占用内存过大，编译器会将其分配到堆上</p>
<h4 id="变量大小不确定"><a href="#变量大小不确定" class="headerlink" title="#变量大小不确定"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E5%8F%98%E9%87%8F%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A">#</a>变量大小不确定</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">10</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, number) <span class="comment">// 编译期间无法确定slice的长度</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译期间无法确定slice的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。直接<code>s := make([]int, 10)</code>不会发生逃逸</p>
<h4 id="动态类型"><a href="#动态类型" class="headerlink" title="#动态类型"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">#</a>动态类型</h4><p>动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸</p>
<p>空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="number">1111</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape4()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main.go:6:14: 1111 escapes to heap</span><br></pre></td></tr></table></figure>

<p>fmt.Println(a …interface{})函数参数为interface，编译器不确定参数的类型，会将变量分配到堆上</p>
<h4 id="闭包引用对象"><a href="#闭包引用对象" class="headerlink" title="#闭包引用对象"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E9%97%AD%E5%8C%85%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">#</a>闭包引用对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape5</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape5()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main.go:4:6: moved to heap: i</span><br></pre></td></tr></table></figure>

<p>闭包函数中局部变量i在后续函数是继续使用的，编译器将其分配到堆上</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="#总结"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%80%BB%E7%BB%93">#</a>总结</h3><ol>
<li>栈上分配内存比在堆中分配内存效率更高</li>
<li>栈上分配的内存不需要 GC 处理，而堆需要</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ol>
<p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率（而不是传指针）更高一点。</p>
<h2 id="3-Go-内存对齐机制？"><a href="#3-Go-内存对齐机制？" class="headerlink" title="3.Go 内存对齐机制？"></a>3.Go 内存对齐机制？</h2><hr>
<h3 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="#什么是内存对齐"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">#</a>什么是内存对齐</h3><p>为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。<strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。</strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。</p>
<h3 id="对齐系数"><a href="#对齐系数" class="headerlink" title="#对齐系数"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E5%AF%B9%E9%BD%90%E7%B3%BB%E6%95%B0">#</a>对齐系数</h3><p>不同硬件平台占用的大小和对齐值都可能是不一样的，每个特定平台上的编译器都有自己的默认”对齐系数”，32位系统对齐系数是4，64位系统对齐系数是8</p>
<p>不同类型的对齐系数也可能不一样，使用<code>Go</code>语言中的<code>unsafe.Alignof</code>函数可以返回相应类型的对齐系数，对齐系数都符合<code>2^n</code>这个规律，最大也不会超过8</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">bool</span>(<span class="literal">true</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;string alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">string</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">int</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;float alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">float64</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int32 alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">int32</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;float32 alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">float32</span>(<span class="number">0</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以查看到各种类型在Mac 64位上的对齐系数如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool alignof is 1</span><br><span class="line">string alignof is 8</span><br><span class="line">int alignof is 8</span><br><span class="line">int32 alignof is 4</span><br><span class="line">float32 alignof is 4</span><br><span class="line"><span class="built_in">float</span> alignof is 8</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="#优点"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E4%BC%98%E7%82%B9">#</a>优点</h3><ol>
<li>提高可移植性，有些<code>CPU</code>可以访问任意地址上的任意数据，而有些<code>CPU</code>只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了</li>
<li>提高内存的访问效率，32位CPU下一次可以从内存中读取32位（4个字节）的数据，64位CPU下一次可以从内存中读取64位（8个字节）的数据，这个长度也称为CPU的字长。CPU一次可以读取1个字长的数据到内存中，如果所需要读取的数据正好跨了1个字长，那就得花两个CPU周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="#缺点"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E7%BC%BA%E7%82%B9">#</a>缺点</h3><ol>
<li>存在内存空间的浪费，实际上是空间换时间</li>
</ol>
<h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="#结构体对齐"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">#</a>结构体对齐</h3><p>对齐原则：</p>
<ol>
<li><strong>结构体变量中成员的偏移量必须是成员大小的整数倍</strong></li>
<li><strong>整个结构体的地址必须是最大字节的整数倍</strong>（结构体的内存占用是1&#x2F;4&#x2F;8&#x2F;16byte…)</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i16  <span class="type">int16</span> <span class="comment">// 2 byte</span></span><br><span class="line">    <span class="type">bool</span> <span class="type">bool</span>  <span class="comment">// 1 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i8  <span class="type">int8</span>  <span class="comment">// 1 byte</span></span><br><span class="line">    i64 <span class="type">int64</span> <span class="comment">// 8 byte</span></span><br><span class="line">    i32 <span class="type">int32</span> <span class="comment">// 4 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i8  <span class="type">int8</span>  <span class="comment">// 1 byte</span></span><br><span class="line">    i32 <span class="type">int32</span> <span class="comment">// 4 byte</span></span><br><span class="line">    i64 <span class="type">int64</span> <span class="comment">// 8 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOARCH) <span class="comment">// amd64</span></span><br><span class="line"></span><br><span class="line">    t1 := T1&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t1)) <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    t2 := T2&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t2)) <span class="comment">// 24 bytes</span></span><br><span class="line"></span><br><span class="line">    t3 := T3&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t3)) <span class="comment">// 16 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以T1结构体为例，实际存储数据的只有3字节，但实际用了4字节，浪费了1个字节：</p>
<p>i16并没有直接放在bool的后面，而是在bool中填充了一个空白后，放到了偏移量为2的位置上。如果i16从偏移量为1的位置开始占用2个字节，根据对齐原则2：构体变量中成员的偏移量必须是成员大小的整数倍，套用公式 1 % 2 &#x3D; 1，就不满足对齐的要求，所以i16从偏移量为2的位置开始</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502132935164.png" alt="img"></p>
<p>以T2结构体为例，实际存储数据的只有13字节，但实际用了24字节，浪费了11个字节：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502133003644.png" alt="img"></p>
<p>以T3结构体为例，实际存储数据的只有13字节，但实际用了16字节，浪费了3个字节：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502133303337.png" alt="img"></p>
<h2 id="4-Go-GC实现原理？"><a href="#4-Go-GC实现原理？" class="headerlink" title="4.Go GC实现原理？"></a>4.Go GC实现原理？</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247484000&idx=1&sn=e5050d2a63068edef20f0198674e672a&chksm=c10c4cbef67bc5a8f72c2694255896985d52821137cab8599fbee16b2c29ae166153f5b6e81f&scene=178&cur_album_id=2709593649634033668#rd">https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&amp;mid=2247484000&amp;idx=1&amp;sn=e5050d2a63068edef20f0198674e672a&amp;chksm=c10c4cbef67bc5a8f72c2694255896985d52821137cab8599fbee16b2c29ae166153f5b6e81f&amp;scene=178&amp;cur_album_id=2709593649634033668#rd</a></p>
<hr>
<h3 id="什么是GC？"><a href="#什么是GC？" class="headerlink" title="#什么是GC？"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%BB%80%E4%B9%88%E6%98%AFgc">#</a>什么是GC？</h3><p>垃圾回收也称为GC（Garbage Collection），是一种自动内存管理机制</p>
<p>现代高级编程语言管理内存的方式分为两种：自动和手动，像C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。</p>
<p>在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC负责回收堆内存，而不负责回收栈中的内存：</p>
<p>栈是线程的专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈，函数执行完后，编译器可以将栈上分配的内存可以直接释放，不需要通过GC来回收。</p>
<p>堆是程序共享的内存，需要GC进行回收在堆上分配的内存。</p>
<p>垃圾回收器的执行过程被划分为两个半独立的组件：</p>
<ul>
<li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li>
<li>回收器（Collector）：负责执行垃圾回收的代码。</li>
</ul>
<h3 id="主流GC算法"><a href="#主流GC算法" class="headerlink" title="#主流GC算法"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%B8%BB%E6%B5%81gc%E7%AE%97%E6%B3%95">#</a>主流GC算法</h3><p>目前比较常见的垃圾回收算法有三种：</p>
<ol>
<li>引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。<ul>
<li>代表语言：<strong>Python</strong>、<strong>PHP</strong>、<strong>Swift</strong></li>
<li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li>
<li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li>
</ul>
</li>
<li>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。<ul>
<li>代表语言：<strong>Java</strong></li>
<li>优点：回收性能好</li>
<li>缺点：算法复杂</li>
</ul>
</li>
<li>标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。<ul>
<li>代表语言：<strong>Golang</strong>（三色标记法）</li>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要 STW，暂时停掉程序运行。</li>
</ul>
</li>
</ol>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220503232512072.png" alt="img"></p>
<h3 id="Go-GC算法"><a href="#Go-GC算法" class="headerlink" title="#Go GC算法"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#go-gc%E7%AE%97%E6%B3%95">#</a>Go GC算法</h3><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="#三色标记法"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95">#</a><strong>三色标记法</strong></h4><p>此算法是在Go 1.5版本开始使用，Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和混合写屏障技术，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW</p>
<p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p>
<ul>
<li>灰色：对象还在标记队列中等待</li>
<li>黑色：对象已被标记，<code>gcmarkBits</code> 对应位为 <code>1</code> （该对象不会在本次 GC 中被回收）</li>
<li>白色：对象未被标记，<code>gcmarkBits</code> 对应位为 <code>0</code> （该对象将会在本次 GC 中被清理）</li>
</ul>
<p>step 1: 创建：白、灰、黑 三个集合</p>
<p>step 2: 将所有对象放入白色集合中</p>
<p>step 3: 遍历所有<strong>root对象</strong>，把遍历到的对象从白色集合放入灰色集合 (这里放入灰色集合的都是根节点的对象)</p>
<p>step 4: 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，自身标记为黑色</p>
<p>step 5: 重复步骤4，直到灰色中无任何对象，其中用到2个机制：</p>
<ul>
<li><strong>写屏障（Write Barrier）</strong>：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后<strong>指针传递时</strong>会把指针标记，即本轮不回收，下次 GC 时再确定。</li>
<li><strong>辅助 GC（Mutator Assist）</strong>：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
</ul>
<p>step 6: 收集所有白色对象（垃圾）</p>
<h4 id="root对象"><a href="#root对象" class="headerlink" title="#root对象"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#root%E5%AF%B9%E8%B1%A1">#</a><strong>root对象</strong></h4><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p>
<p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上指向堆内存的指针。 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p>
<h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="#插入写屏障"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>插入写屏障</strong></h4><p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p>
<p>缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活</p>
<h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="#删除写屏障"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>删除写屏障</strong></h4><p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p>
<p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="#混合写屏障"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>混合写屏障</strong></h4><p>GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p>
<ul>
<li>GC开始将栈上的对象全部扫描并标记为黑色。</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ul>
<h3 id="GC流程"><a href="#GC流程" class="headerlink" title="#GC流程"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E6%B5%81%E7%A8%8B">#</a>GC流程</h3><p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p>
<ol>
<li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记 ，与用户程序并发执行</li>
<li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行</li>
</ol>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504185906969.png" alt="img"></p>
<h3 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="#GC触发时机"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">#</a>GC触发时机</h3><p><strong>主动触发：</strong></p>
<ul>
<li>调用 runtime.GC() 方法，触发 GC</li>
</ul>
<p><strong>被动触发：</strong></p>
<ul>
<li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</li>
<li>根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC</li>
</ul>
<h3 id="GC算法演进"><a href="#GC算法演进" class="headerlink" title="#GC算法演进"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B">#</a>GC算法演进</h3><ul>
<li>Go 1：mark and sweep操作都需要STW</li>
<li><strong>Go 1.3</strong>：分离了mark和sweep操作，mark过程需要 STW，mark完成后让sweep任务和普通协程任务一样并行，停顿时间在约几百ms</li>
<li><strong>Go 1.5</strong>：引入三色并发标记法、插入写屏障，不需要每次都扫描整个内存空间，可以减少stop the world的时间，停顿时间在100ms以内</li>
<li>Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在10ms以内</li>
<li>Go 1.7：停顿时间控制在2ms以内</li>
<li><strong>Go 1.8</strong>：混合写屏障（插入写屏障和删除写屏障），停顿时间在0.5ms左右</li>
<li>Go 1.9：彻底移除了栈的重扫描过程</li>
<li>Go 1.12：整合了两个阶段的 Mark Termination</li>
<li>Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger</li>
<li>Go 1.14：替代了仅存活了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题</li>
</ul>
<h2 id="5-Go-GC如何调优？"><a href="#5-Go-GC如何调优？" class="headerlink" title="5.Go GC如何调优？"></a>5.Go GC如何调优？</h2><hr>
<ul>
<li>控制内存分配的速度，限制 Goroutine 的数量，提高赋值器 mutator 的 CPU 利用率（降低GC的CPU利用率）</li>
<li>少量使用<code>+</code>连接string</li>
<li>slice提前分配足够的内存来降低扩容带来的拷贝</li>
<li>避免map key对象过多，导致扫描时间增加</li>
<li>变量复用，减少对象分配，例如使用 sync.Pool 来复用需要频繁创建临时对象、使用全局变量等</li>
<li>增大 GOGC 的值，降低 GC 的运行频率</li>
</ul>
<h2 id="6-Go-如何查看GC信息？"><a href="#6-Go-如何查看GC信息？" class="headerlink" title="6.Go 如何查看GC信息？"></a>6.Go 如何查看GC信息？</h2><hr>
<h3 id="1-GODEBUG-’gctrace-1’"><a href="#1-GODEBUG-’gctrace-1’" class="headerlink" title="#1. GODEBUG&#x3D;’gctrace&#x3D;1’"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_1-godebug-gctrace-1">#</a>1. GODEBUG&#x3D;’gctrace&#x3D;1’</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    for n := 1; n &lt; 100000; n++ &#123;</span><br><span class="line">        _ = make([]byte, 1&lt;&lt;20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ GODEBUG=&#x27;gctrace=1&#x27; go run main.go</span><br><span class="line"></span><br><span class="line">gc 1 @0.003s 4%: 0.013+1.7+0.008 ms clock, 0.10+0.67/1.2/0.018+0.064 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 2 @0.006s 2%: 0.006+4.5+0.058 ms clock, 0.048+0.070/0.027/3.6+0.47 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 3 @0.011s 3%: 0.021+1.3+0.009 ms clock, 0.17+0.041/0.41/0.046+0.072 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 4 @0.013s 5%: 0.025+0.38+0.26 ms clock, 0.20+0.054/0.15/0.009+2.1 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 5 @0.014s 5%: 0.021+0.16+0.002 ms clock, 0.17+0.098/0.028/0.001+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 6 @0.014s 7%: 0.025+1.6+0.003 ms clock, 0.20+0.061/2.9/1.5+0.025 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 7 @0.016s 7%: 0.019+1.0+0.002 ms clock, 0.15+0.053/1.0/0.018+0.017 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 8 @0.017s 7%: 0.029+0.17+0.002 ms clock, 0.23+0.037/0.10/0.063+0.022 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 8 P</span><br><span class="line">gc 9 @0.018s 7%: 0.019+0.23+0.002 ms clock, 0.15+0.040/0.16/0.023+0.018 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 10 @0.018s 7%: 0.022+0.23+0.003 ms clock, 0.17+0.061/0.13/0.006+0.024 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 11 @0.018s 7%: 0.019+0.11+0.001 ms clock, 0.15+0.033/0.051/0.013+0.015 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 12 @0.019s 7%: 0.018+0.19+0.001 ms clock, 0.14+0.035/0.10/0.018+0.014 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 13 @0.019s 7%: 0.018+0.35+0.002 ms clock, 0.15+0.21/0.054/0.013+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 14 @0.019s 8%: 0.024+0.27+0.002 ms clock, 0.19+0.022/0.13/0.014+0.017 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 15 @0.020s 8%: 0.019+0.42+0.038 ms clock, 0.15+0.060/0.28/0.007+0.31 ms cpu, 4-&gt;17-&gt;13 MB, 5 MB goal, 8 P</span><br><span class="line">gc 16 @0.021s 8%: 0.018+0.53+0.060 ms clock, 0.14+0.045/0.39/0.005+0.48 ms cpu, 21-&gt;28-&gt;7 MB, 26 MB goal, 8 P</span><br><span class="line">gc 17 @0.021s 10%: 0.020+0.91+0.64 ms clock, 0.16+0.050/0.36/0.027+5.1 ms cpu, 12-&gt;16-&gt;4 MB, 14 MB goal, 8 P</span><br><span class="line">gc 18 @0.023s 10%: 0.020+0.55+0.002 ms clock, 0.16+0.053/0.50/0.081+0.023 ms cpu, 7-&gt;9-&gt;2 MB, 8 MB goal, 8 P</span><br></pre></td></tr></table></figure>

<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gc 2</td>
<td align="left">第二个 GC 周期</td>
</tr>
<tr>
<td align="left">0.006</td>
<td align="left">程序开始后的 0.006 秒</td>
</tr>
<tr>
<td align="left">2%</td>
<td align="left">该 GC 周期中 CPU 的使用率</td>
</tr>
<tr>
<td align="left">0.006</td>
<td align="left">标记开始时， STW 所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">4.5</td>
<td align="left">标记过程中，并发标记所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">0.058</td>
<td align="left">标记终止时， STW 所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">0.048</td>
<td align="left">标记开始时， STW 所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.070</td>
<td align="left">标记过程中，标记辅助所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.027</td>
<td align="left">标记过程中，并发标记所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">3.6</td>
<td align="left">标记过程中，GC 空闲的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.47</td>
<td align="left">标记终止时， STW 所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">标记开始时，堆的大小的实际值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">标记结束时，堆的大小的实际值</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">标记结束时，标记为存活的对象大小</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">标记结束时，堆的大小的预测值</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">P 的数量</td>
</tr>
</tbody></table>
<h3 id="2-go-tool-trace"><a href="#2-go-tool-trace" class="headerlink" title="#2. go tool trace"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_2-go-tool-trace">#</a>2. go tool trace</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;runtime/trace&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f, _ := os.Create(&quot;trace.out&quot;)</span><br><span class="line">    defer f.Close()</span><br><span class="line">    trace.Start(f)</span><br><span class="line">    defer trace.Stop()</span><br><span class="line">    for n := 1; n &lt; 100000; n++ &#123;</span><br><span class="line">        _ = make([]byte, 1&lt;&lt;20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ go tool trace trace.out</span><br></pre></td></tr></table></figure>

<p>打开浏览器后，可以看到如下统计：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504204708533.png" alt="img"></p>
<p>点击View trace，可以查看当时的trace情况</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/f3d74b546b1e360c9d6946757ada4f64.png" alt="img"></p>
<p>点击 Minimum mutator utilization，可以查看到赋值器 mutator （用户程序）对 CPU 的利用率 74.1%，接近100%则代表没有针对GC的优化空间了</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504204751752.png" alt="img"></p>
<h3 id="3-debug-ReadGCStats"><a href="#3-debug-ReadGCStats" class="headerlink" title="#3. debug.ReadGCStats"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_3-debug-readgcstats">#</a>3. debug.ReadGCStats</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGCStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(time.Second)</span><br><span class="line">    s := debug.GCStats&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            debug.ReadGCStats(&amp;s)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;gc %d last@%v, PauseTotal %v\n&quot;</span>, s.NumGC, s.LastGC, s.PauseTotal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> printGCStats()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">        _ = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"></span><br><span class="line">gc 3392 last@2022-05-04 19:22:52.877293 +0800 CST, PauseTotal 117.524907ms</span><br><span class="line">gc 6591 last@2022-05-04 19:22:53.876837 +0800 CST, PauseTotal 253.254996ms</span><br><span class="line">gc 10028 last@2022-05-04 19:22:54.87674 +0800 CST, PauseTotal 376.981595ms</span><br><span class="line">gc 13447 last@2022-05-04 19:22:55.87689 +0800 CST, PauseTotal 511.420111ms</span><br><span class="line">gc 16938 last@2022-05-04 19:22:56.876955 +0800 CST, PauseTotal 649.293449ms</span><br><span class="line">gc 20350 last@2022-05-04 19:22:57.876756 +0800 CST, PauseTotal 788.003014ms</span><br></pre></td></tr></table></figure>

<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NumGC</td>
<td align="left">GC总次数</td>
</tr>
<tr>
<td align="left">LastGC</td>
<td align="left">上次GC时间</td>
</tr>
<tr>
<td align="left">PauseTotal</td>
<td align="left">STW总耗时</td>
</tr>
</tbody></table>
<h3 id="4-runtime-ReadMemStats"><a href="#4-runtime-ReadMemStats" class="headerlink" title="#4. runtime.ReadMemStats"></a><a href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_4-runtime-readmemstats">#</a>4. runtime.ReadMemStats</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(time.Second)</span><br><span class="line">    s := runtime.MemStats&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            runtime.ReadMemStats(&amp;s)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;gc %d last@%v, heap_object_num: %v, heap_alloc: %vMB, next_heap_size: %vMB\n&quot;</span>,</span><br><span class="line">                s.NumGC, time.Unix(<span class="type">int64</span>(time.Duration(s.LastGC).Seconds()), <span class="number">0</span>), s.HeapObjects, s.HeapAlloc/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>), s.NextGC/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> printMemStats()</span><br><span class="line">    fmt.Println(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">        _ = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"></span><br><span class="line">gc 2978 last@2022-05-04 19:38:04 +0800 CST, heap_object_num: 391, heap_alloc: 20MB, next_heap_size: 28MB</span><br><span class="line">gc 5817 last@2022-05-04 19:38:05 +0800 CST, heap_object_num: 370, heap_alloc: 4MB, next_heap_size: 4MB</span><br><span class="line">gc 9415 last@2022-05-04 19:38:06 +0800 CST, heap_object_num: 392, heap_alloc: 7MB, next_heap_size: 8MB</span><br><span class="line">gc 11429 last@2022-05-04 19:38:07 +0800 CST, heap_object_num: 339, heap_alloc: 4MB, next_heap_size: 5MB</span><br><span class="line">gc 14706 last@2022-05-04 19:38:08 +0800 CST, heap_object_num: 436, heap_alloc: 6MB, next_heap_size: 8MB</span><br><span class="line">gc 18253 last@2022-05-04 19:38:09 +0800 CST, heap_object_num: 375, heap_alloc: 4MB, next_heap_size: 6M</span><br></pre></td></tr></table></figure>

<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NumGC</td>
<td align="left">GC总次数</td>
</tr>
<tr>
<td align="left">LastGC</td>
<td align="left">上次GC时间</td>
</tr>
<tr>
<td align="left">HeapObjects</td>
<td align="left">堆中已经分配的对象总数，GC内存回收后HeapObjects取值相应减小</td>
</tr>
<tr>
<td align="left">HeapAlloc</td>
<td align="left">堆中已经分配给对象的字节数，GC内存回收后HeapAlloc取值相应减小</td>
</tr>
<tr>
<td align="left">NextGC</td>
<td align="left">下次GC目标堆的大小</td>
</tr>
</tbody></table>
<h1 id="第九章：并发编程"><a href="#第九章：并发编程" class="headerlink" title="第九章：并发编程"></a>第九章：并发编程</h1><h2 id="1-Go-常用的并发模型？"><a href="#1-Go-常用的并发模型？" class="headerlink" title="1.Go 常用的并发模型？"></a>1.Go 常用的并发模型？</h2><hr>
<p>并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行<strong>通信</strong>和协作。</p>
<h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="#线程间通信方式"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">#</a>线程间通信方式</h3><p>线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步信息</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="#共享内存"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">#</a><strong>共享内存</strong></h4><p><strong>抽象层级</strong>：抽象层级低，当我们遇到对资源进行更细粒度的控制或者对性能有极高要求的场景才应该考虑抽象层级更低的方法</p>
<p><strong>耦合</strong>：高，线程需要在读取或者写入数据时先获取保护该资源的互斥锁</p>
<p><strong>线程竞争</strong>：需要加锁，才能避免线程竞争和数据冲突</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="#发送消息"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">#</a><strong>发送消息</strong></h4><p><strong>抽象层级</strong>：抽象层级高，提供了更良好的封装和与领域更相关和契合的设计，比如Go 语言中的<code>Channel</code>就提供了 Goroutine 之间用于传递信息的方式，它在内部实现时就广泛用到了共享内存和锁，通过对两者进行的组合提供了更高级的同步机制</p>
<p><strong>耦合</strong>：低，生产消费者模型</p>
<p><strong>线程竞争</strong>：保证同一时间只有一个活跃的线程能够访问数据，channel维护所有被该chanel阻塞的协程，保证有资源的时候只唤醒一个协程，从而避免竞争</p>
<p>Go语言中实现了两种并发模型，一种是共享内存并发模型，另一种则是CSP模型。</p>
<h3 id="共享内存并发模型"><a href="#共享内存并发模型" class="headerlink" title="#共享内存并发模型"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B">#</a>共享内存并发模型</h3><p>通过直接共享内存 + 锁的方式同步信息，传统多线程并发</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220514161804822.png" alt="img"></p>
<h3 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="#CSP并发模型"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-1.html#csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B">#</a>CSP并发模型</h3><p>通过发送消息的方式来同步信息，Go语言推荐使用的<em>通信顺序进程</em>（communicating sequential processes）并发模型，通过goroutine和channel来实现</p>
<ul>
<li><code>goroutine</code> 是Go语言中并发的执行单位，可以理解为”线程“</li>
<li><code>channel</code>是Go语言中各个并发结构体(<code>goroutine</code>)之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的”管道“，类似于Linux中的管道</li>
</ul>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220514161841437.png" alt="img"></p>
<h2 id="2-Go-有哪些并发同步原语？"><a href="#2-Go-有哪些并发同步原语？" class="headerlink" title="2.Go 有哪些并发同步原语？"></a>2.Go 有哪些并发同步原语？</h2><hr>
<p>Go是一门以并发编程见长的语言，它提供了一系列的同步原语方便开发者使用</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="#原子操作"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">#</a>原子操作</h3><p>Mutex、RWMutex 等并发原语的底层实现是通过 atomic 包中的一些原子操作来实现的，原子操作是最基础的并发原语</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/53d55255fe851754659d90cbee814f13.jpeg" alt="img"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> opts <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add(&amp;opts, <span class="number">3</span>)</span><br><span class="line">    load(&amp;opts)</span><br><span class="line">    compareAndSwap(&amp;opts, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    swap(&amp;opts, <span class="number">5</span>)</span><br><span class="line">    store(&amp;opts, <span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(addr, delta) <span class="comment">//加操作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;add opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(addr *<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;load opts: &quot;</span>, atomic.LoadInt64(&amp;opts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareAndSwap</span><span class="params">(addr *<span class="type">int64</span>, oldValue <span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt64(addr, oldValue, newValue) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;cas opts: &quot;</span>, *addr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.SwapInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.StoreInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;store opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Channel"><a href="#Channel" class="headerlink" title="#Channel"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#channel">#</a>Channel</h3><p><code>channel</code> 管道，高级同步原语，goroutine之间通信的桥梁</p>
<p>使用场景：消息队列、数据传递、信号通知、任务编排、锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(<span class="string">&quot;通过ch访问临界区&quot;</span>)</span><br><span class="line">            &lt;-c</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基本并发原语"><a href="#基本并发原语" class="headerlink" title="#基本并发原语"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD">#</a>基本并发原语</h3><p>Go 语言在 <code>sync</code>包中提供了用于同步的一些基本原语，这些基本原语提供了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级更高的 Channel 实现同步。</p>
<p>常见的并发原语如下：<code>sync.Mutex</code>、<code>sync.RWMutex</code>、<code>sync.WaitGroup</code>、<code>sync.Cond</code>、<code>sync.Once</code>、<code>sync.Pool</code>、<code>sync.Context</code></p>
<h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="#sync.Mutex"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-mutex">#</a><strong>sync.Mutex</strong></h4><p><code>sync.Mutex</code> （互斥锁） 可以限制对临界资源的访问，保证只有一个 goroutine 访问共享资源</p>
<p>使用场景：大量读写，比如多个 goroutine 并发更新同一个资源，像计数器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 封装好的计数器</span></span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> gNum = <span class="number">1000</span></span><br><span class="line">    wg.Add(gNum)</span><br><span class="line">    <span class="comment">// 启动10个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; gNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            counter.Incr() <span class="comment">// 受到锁保护的方法</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的计数器类型</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加1的方法，内部使用互斥锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到计数器的值，也需要锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="#sync.RWMutex"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-rwmutex">#</a><strong>sync.RWMutex</strong></h4><p><code>sync.RWMutex</code> （读写锁） 可以限制对临界资源的访问，保证只有一个 goroutine 写共享资源，可以有多个goroutine 读共享资源</p>
<p>使用场景：大量并发读，少量并发写，有强烈的性能要求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 封装好的计数器</span></span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">var</span> gNum = <span class="number">1000</span></span><br><span class="line">    <span class="comment">// 启动10个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; gNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            counter.Count() <span class="comment">// 受到锁保护的方法</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;incr&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的计数器类型</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加1的方法，内部使用互斥锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到计数器的值，也需要锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="#sync.WaitGroup"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-waitgroup">#</a><strong>sync.WaitGroup</strong></h4><p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回</p>
<p>使用场景：并发等待，任务编排，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>



<h4 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="#sync.Cond"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-cond">#</a><strong>sync.Cond</strong></h4><p><code>sync.Cond</code> 可以让一组的 Goroutine 都在满足特定条件时被唤醒</p>
<p>使用场景：利用等待 &#x2F; 通知机制实现阻塞或者唤醒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> listen(c)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">go</span> broadcast(c)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">    c.Signal()</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="#sync.Once"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-once">#</a><strong>sync.Once</strong></h4><p><code>sync.Once</code> 可以保证在 Go 程序运行期间的某段代码只会执行一次</p>
<p>使用场景：常常用于单例对象的初始化场景</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="#sync.Pool"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-pool">#</a><strong>sync.Pool</strong></h4><p><code>sync.Pool</code>可以将暂时将不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能（频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺）</p>
<p>使用场景：对象池化， TCP连接池、数据库连接池、Worker Pool</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        v := pool.Get().(<span class="type">int</span>)</span><br><span class="line">        fmt.Println(v) <span class="comment">// 取出来的值是put进去的，对象复用；如果是新建对象，则取出来的值为0</span></span><br><span class="line">        pool.Put(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="#sync.Map"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-map">#</a><strong>sync.Map</strong></h4><p><code>sync.Map</code> 线程安全的map</p>
<p>使用场景：map 并发读写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scene sync.Map</span><br><span class="line">    <span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">    scene.Store(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    scene.Store(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    scene.Store(<span class="string">&quot;3&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">    fmt.Println(scene.Load(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    <span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">    scene.Delete(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">    scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-Context"><a href="#sync-Context" class="headerlink" title="#sync.Context"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-context">#</a><strong>sync.Context</strong></h4><p><code>sync.Context</code> 可以进行上下文信息传递、提供超时和取消机制、控制子 goroutine 的执行</p>
<p>使用场景：取消一个goroutine的执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;goroutine exit&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;receive cancel signal!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展并发原语"><a href="#扩展并发原语" class="headerlink" title="#扩展并发原语"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD">#</a>扩展并发原语</h3><h4 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="#ErrGroup"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#errgroup">#</a><strong>ErrGroup</strong></h4><p><code>errgroup</code> 可以在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能</p>
<p>使用场景：只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费，并且返回错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">    &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var g errgroup.Group</span><br><span class="line">    var urls = []string&#123;</span><br><span class="line">        &quot;http://www.baidu.com/&quot;,</span><br><span class="line">        &quot;https://www.sina.com.cn/&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    for i := range urls &#123;</span><br><span class="line">        url := urls[i]</span><br><span class="line">        g.Go(func() error &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            if err == nil &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">            return err</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    err := g.Wait()</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        fmt.Println(&quot;Successfully fetched all URLs.&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;fetched error:&quot;, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="#Semaphore"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#semaphore">#</a><strong>Semaphore</strong></h4><p><code>Semaphore</code>带权重的信号量，控制多个goroutine同时访问资源</p>
<p>使用场景：控制 goroutine 的阻塞和唤醒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/semaphore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">    sema       = semaphore.NewWeighted(<span class="type">int64</span>(maxWorkers)) <span class="comment">//信号量</span></span><br><span class="line">    task       = <span class="built_in">make</span>([]<span class="type">int</span>, maxWorkers*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务数，是worker的四</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> task &#123;</span><br><span class="line">        <span class="comment">// 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span></span><br><span class="line">        <span class="keyword">if</span> err := sema.Acquire(ctx, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动worker goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> sema.Release(<span class="number">1</span>)</span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">            task[i] = i + <span class="number">1</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求所有的worker,这样能确保前面的worker都执行完</span></span><br><span class="line">    <span class="keyword">if</span> err := sema.Acquire(ctx, <span class="type">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;获取所有的worker失败: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(maxWorkers, task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="#SingleFlight"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-2.html#singleflight">#</a><strong>SingleFlight</strong></h4><p>用于抑制对下游的重复请求</p>
<p>使用场景：访问缓存、数据库等场景，缓存过期时只有一个请求去更新数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟从数据库读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArticle</span><span class="params">(id <span class="type">int</span>)</span></span> (article <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 假设这里会对数据库进行调用, 模拟不同并发下耗时不同</span></span><br><span class="line">    atomic.AddInt32(&amp;count, <span class="number">1</span>)</span><br><span class="line">    time.Sleep(time.Duration(count) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;article: %d&quot;</span>, id), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟优先读缓存，缓存不存在读取数据库，并且只有一个请求读取数据库，其它请求等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleflightGetArticle</span><span class="params">(sg *singleflight.Group, id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    v, err, _ := sg.Do(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getArticle(id)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v.(<span class="type">string</span>), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.AfterFunc(<span class="number">1</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;count, -count)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        wg  sync.WaitGroup</span><br><span class="line">        now = time.Now()</span><br><span class="line">        n   = <span class="number">1000</span></span><br><span class="line">        sg  = &amp;singleflight.Group&#123;&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            res, _ := singleflightGetArticle(sg, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// res, _ := getArticle(1)</span></span><br><span class="line">            <span class="keyword">if</span> res != <span class="string">&quot;article: 1&quot;</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;同时发起 %d 次请求，耗时: %s&quot;</span>, n, time.Since(now))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Go-WaitGroup实现原理？"><a href="#3-Go-WaitGroup实现原理？" class="headerlink" title="3.Go WaitGroup实现原理？"></a>3.Go WaitGroup实现原理？</h2><hr>
<h3 id="概念-7"><a href="#概念-7" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p><code>Go</code>标准库提供了<code>WaitGroup</code>原语, 可以用它来等待一批 Goroutine 结束</p>
<h3 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="#底层数据结构"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line"> noCopy noCopy</span><br><span class="line"> state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>noCopy</code> 是 golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错。但需要注意的是，noCopy 不会影响程序正常的编译和运行。</p>
<p><code>state1</code>主要是存储着状态和信号量，状态维护了 2 个计数器，一个是请求计数器counter ，另外一个是等待计数器waiter（已调用 <code>WaitGroup.Wait</code> 的 goroutine 的个数）</p>
<p>当数组的首地址是处于一个<code>8</code>字节对齐的位置上时，那么就将这个数组的前<code>8</code>个字节作为<code>64</code>位值使用表示状态，后<code>4</code>个字节作为<code>32</code>位值表示信号量(<code>semaphore</code>)；同理如果首地址没有处于<code>8</code>字节对齐的位置上时，那么就将前<code>4</code>个字节作为<code>semaphore</code>，后<code>8</code>个字节作为<code>64</code>位数值。</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220522104433409.png" alt="img"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="#使用方法"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">#</a>使用方法</h3><p>在WaitGroup里主要有3个方法：</p>
<ul>
<li><code>WaitGroup.Add()</code>：可以添加或减少请求的goroutine数量，*<code>Add(n)</code> 将会导致 <code>counter += n</code>*</li>
<li><code>WaitGroup.Done()</code>：相当于Add(-1)，<code>Done()</code> 将导致 <code>counter -=1</code>，请求计数器counter为0 时通过信号量调用<code>runtime_Semrelease</code>唤醒waiter线程</li>
<li><code>WaitGroup.Wait()</code>：会将 <code>waiter++</code>，同时通过信号量调用 <code>runtime_Semacquire(semap)</code>阻塞当前 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Go-Cond实现原理？"><a href="#4-Go-Cond实现原理？" class="headerlink" title="4. Go Cond实现原理？"></a>4. Go Cond实现原理？</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p><code>Go</code>标准库提供了<code>Cond</code>原语，可以让 Goroutine 在满足特定条件时被阻塞和唤醒</p>
<h3 id="底层数据结构-2"><a href="#底层数据结构-2" class="headerlink" title="#底层数据结构"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait   <span class="type">uint32</span></span><br><span class="line">    notify <span class="type">uint32</span></span><br><span class="line">    lock   <span class="type">uintptr</span> <span class="comment">// key field of the mutex</span></span><br><span class="line">    head   unsafe.Pointer</span><br><span class="line">    tail   unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要有<code>4</code>个字段：</p>
<ul>
<li><code>nocopy</code> ： golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错，但需要注意的是，noCopy 不会影响程序正常的编译和运行</li>
<li><code>checker</code>：用于禁止运行期间发生拷贝，双重检查(<code>Double check</code>)</li>
<li><code>L</code>：可以传入一个读写锁或互斥锁，当修改条件或者调用<code>Wait</code>方法时需要加锁</li>
<li><code>notify</code>：通知链表，调用<code>Wait()</code>方法的<code>Goroutine</code>会放到这个链表中，从这里获取需被唤醒的Goroutine列表</li>
</ul>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="#使用方法"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">#</a>使用方法</h3><p>在Cond里主要有3个方法：</p>
<ul>
<li><code>sync.NewCond(l Locker)</code>: 新建一个 sync.Cond 变量，注意该函数需要一个 Locker 作为必填参数，这是因为在 <code>cond.Wait()</code> 中底层会涉及到 Locker 的锁操作</li>
<li><code>Cond.Wait()</code>: 阻塞等待被唤醒，调用Wait函数前<strong>需要先加锁</strong>；并且由于Wait函数被唤醒时存在虚假唤醒等情况，导致唤醒后发现，条件依旧不成立，因此需要使用 for 语句来循环地进行等待，直到条件成立为止</li>
<li><code>Cond.Signal()</code>: 只唤醒一个最先 Wait 的 goroutine，可以不用加锁</li>
<li><code>Cond.Broadcast()</code>: 唤醒所有Wait的goroutine，可以不用加锁</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> listen(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> broadcast(c)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    atomic.StoreInt64(&amp;status, <span class="number">1</span>) </span><br><span class="line">    c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">        c.Wait() </span><br><span class="line">        <span class="comment">// Wait 内部会先调用 c.L.Unlock()，来先释放锁，如果调用方不先加锁的话，会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-Go-有哪些方式安全读写共享变量？"><a href="#5-Go-有哪些方式安全读写共享变量？" class="headerlink" title="5. Go 有哪些方式安全读写共享变量？"></a>5. Go 有哪些方式安全读写共享变量？</h2><table>
<thead>
<tr>
<th>方法</th>
<th>并发原语</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>不要修改变量</td>
<td>sync.Once</td>
<td>不要去写变量，变量只初始化一次</td>
</tr>
<tr>
<td>只允许一个goroutine访问变量</td>
<td>Channel</td>
<td>不要通过共享变量来通信，通过通信(channel)来共享变量</td>
</tr>
<tr>
<td>允许多个goroutine访问变量，但是同一时间只允许一个goroutine访问</td>
<td>sync.Mutex、sync.RWMutex、原子操作</td>
<td>实现锁机制，同时只有一个线程能拿到锁</td>
</tr>
</tbody></table>
<h2 id="6-Go-如何排查数据竞争问题？"><a href="#6-Go-如何排查数据竞争问题？" class="headerlink" title="6. Go 如何排查数据竞争问题？"></a>6. Go 如何排查数据竞争问题？</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="#概念"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-6.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>只要有两个以上的goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争；全是读的情况下是不存在数据竞争的。</p>
<h3 id="排查方式"><a href="#排查方式" class="headerlink" title="#排查方式"></a><a href="https://vip.golangroadmap.com/class/gointerview/9-6.html#%E6%8E%92%E6%9F%A5%E6%96%B9%E5%BC%8F">#</a>排查方式</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i++ <span class="comment">// write i</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(i) <span class="comment">// read i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>go命令行</code>有个参数<code>race</code>可以帮助检测代码中的数据竞争</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run -race main.go</span><br><span class="line"></span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c0000ba008 by goroutine 7:</span><br><span class="line"><span class="built_in">exit</span> status 66</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
