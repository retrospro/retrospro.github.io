<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/retrospro.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/retrospro.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/retrospro.png">
  <link rel="mask-icon" href="/images/retrospro.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="RETROSPRO">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="RETROSPRO">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Eric Hao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RETROSPRO</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">RETROSPRO</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Eric Hao"
      src="/images/retrospro.png">
  <p class="site-author-name" itemprop="name">Eric Hao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/retrospro" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;retrospro" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/29/golang%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/29/golang%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">golang面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-29 01:57:33 / 修改时间：16:14:35" itemprop="dateCreated datePublished" datetime="2024-08-29T01:57:33+08:00">2024-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">golang面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.golangroadmap.com/docs/books/interviewPresentation.html">https://www.golangroadmap.com/docs/books/interviewPresentation.html</a></p>
<h1 id="第一章：Go基础"><a href="#第一章：Go基础" class="headerlink" title="第一章：Go基础"></a>第一章：Go基础</h1><h1 id="第二章：Slice"><a href="#第二章：Slice" class="headerlink" title="第二章：Slice"></a>第二章：Slice</h1><h1 id="1-Go-slice的底层实现原理"><a href="#1-Go-slice的底层实现原理" class="headerlink" title="1.Go slice的底层实现原理?"></a>1.Go slice的底层实现原理?</h1><details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go slice的底层实现原理?</summary><iframe src="https://player.bilibili.com/player.html?aid=936954822&amp;bvid=BV1JT4y1S7at&amp;cid=541228117&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>切片是基于数组实现的，它的底层是数组，可以理解为对 底层数组的抽象。</p>
<p>源码包中src&#x2F;runtime&#x2F;slice.go 定义了slice的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice占用24个字节</p>
<p>array: 指向底层数组的指针，占用8个字节</p>
<p>len: 切片的长度，占用8个字节</p>
<p>cap: 切片的容量，cap 总是大于等于 len 的，占用8个字节</p>
<p>slice有4种初始化方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方式1：直接声明</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2：使用字面量</span></span><br><span class="line">slice2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式3：使用make创建slice</span></span><br><span class="line">slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式4: 从切片或数组“截取”</span></span><br><span class="line">slcie4 := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>通过一个简单程序，看下slice初始化调用的底层函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>go tool compile -S test.go | grep CALL</code> 得到汇编代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)</span><br><span class="line">0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)</span><br><span class="line">0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)</span><br><span class="line">0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)</span><br><span class="line">0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)</span><br><span class="line">0x0166 00358 (<span class="variable">$GOROOT</span>/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)</span><br><span class="line">0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x0079 00121 (&lt;autogenerated&gt;:1)        CALL    runtime.efaceeq(SB)</span><br><span class="line">0x00a0 00160 (&lt;autogenerated&gt;:1)        CALL    runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure>

<p>初始化slice调用的是runtime.makeslice，makeslice函数的工作主要就是计算slice所需内存大小，然后调用mallocgc进行内存的分配</p>
<p>所需内存大小 &#x3D; 切片中元素大小 * 切片的容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line">        <span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line">        <span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line">        <span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">        <span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">        mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-Go-array和slice的区别？"><a href="#2-Go-array和slice的区别？" class="headerlink" title="2.Go array和slice的区别？"></a>2.Go array和slice的区别？</h1><details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go array和slice的区别？</summary><iframe src="https://player.bilibili.com/player.html?aid=682008425&amp;bvid=BV1bU4y1f7ej&amp;cid=542175934&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe><p style="line-height: 1.7;"><strong style="font-weight: 600;"></strong></p><p style="line-height: 1.7;"></p><p style="line-height: 1.7;"></p><p style="line-height: 1.7;"><strong style="font-weight: 600;"></strong></p><p style="line-height: 1.7;"><strong style="font-weight: 600;"></strong></p><p style="line-height: 1.7;"><strong style="font-weight: 600;"></strong></p><p style="line-height: 1.7;"><strong style="font-weight: 600;"></strong></p><p style="line-height: 1.7;"></p><p style="line-height: 1.7; margin-bottom: 0px; padding-bottom: 0px;"></p></details>

<h1 id="3-Go-slice深拷贝和浅拷贝"><a href="#3-Go-slice深拷贝和浅拷贝" class="headerlink" title="3.Go slice深拷贝和浅拷贝"></a>3.Go slice深拷贝和浅拷贝</h1><hr>
<p><em>caspar</em> <em>1840</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go slice深拷贝和浅拷贝</summary><iframe src="https://player.bilibili.com/player.html?aid=424534458&amp;bvid=BV1b341157bf&amp;cid=543972269&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>深拷贝：拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值</p>
<p>实现深拷贝的方式：</p>
<ol>
<li>copy(slice2, slice1)</li>
<li>遍历append赋值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice1: %v, %p\n&quot;</span>, slice1, slice1)</span><br><span class="line">    <span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice2: %v, %p\n&quot;</span>, slice2, slice2)</span><br><span class="line">    slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">        slice3 = <span class="built_in">append</span>(slice3, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice3: %v, %p\n&quot;</span>, slice3, slice3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice1: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0030</span></span><br><span class="line">slice2: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0060</span></span><br><span class="line">slice3: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc0000b0090</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p>复制代码</p>
<p>浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化</p>
<p>实现浅拷贝的方式：</p>
<p>引用类型的变量，默认赋值操作就是浅拷贝</p>
<ol>
<li>slice2 :&#x3D; slice1</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice1: %v, %p\n&quot;</span>, slice1, slice1)</span><br><span class="line">    slice2 := slice1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice2: %v, %p\n&quot;</span>, slice2, slice2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice1: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc00001a120</span></span><br><span class="line">slice2: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>], <span class="number">0xc00001a120</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<h1 id="4-Go-slice扩容机制？"><a href="#4-Go-slice扩容机制？" class="headerlink" title="4.Go slice扩容机制？"></a>4.Go slice扩容机制？</h1><hr>
<p><em>caspar</em> <em>1694</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go slice扩容机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=894512371&amp;bvid=BV1JP4y1g7kw&amp;cid=543979526&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>扩容会发生在slice append的时候，当slice的cap不足以容纳新元素，就会进行扩容，扩容规则如下</p>
<ul>
<li>如果新申请容量比两倍原有容量大，那么扩容后容量大小 为 新申请容量</li>
<li>如果原有 slice 长度小于 1024， 那么每次就扩容为原来的 2 倍</li>
<li>如果原 slice 长度大于等于 1024， 那么每次扩容就扩为原来的 1.25 倍</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">        slice1 = <span class="built_in">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;addr: %p, len: %v, cap: %v\n&quot;</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">addr: 0xc00001a120, len: 4, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc00001a120, len: 5, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc00001a120, len: 6, <span class="built_in">cap</span>: 6</span><br><span class="line">addr: 0xc000060060, len: 7, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 8, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 9, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 10, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 11, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc000060060, len: 12, <span class="built_in">cap</span>: 12</span><br><span class="line">addr: 0xc00007c000, len: 13, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 14, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 15, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 16, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 17, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 18, <span class="built_in">cap</span>: 24</span><br><span class="line">addr: 0xc00007c000, len: 19, <span class="built_in">cap</span>: 24</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p>复制代码</p>
<h1 id="5-Go-slice为什么不是线程安全的？"><a href="#5-Go-slice为什么不是线程安全的？" class="headerlink" title="5.Go slice为什么不是线程安全的？"></a>5.Go slice为什么不是线程安全的？</h1><hr>
<p><em>caspar</em> <em>1755</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go slice为什么不是线程安全的？</summary><iframe src="https://player.bilibili.com/player.html?aid=467067343&amp;bvid=BV1DL411N7km&amp;cid=543985249&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>先看下线程安全的定义</strong>：</p>
<p>多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>再看Go语言实现线程安全常用的几种方式</strong>：</p>
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>原子操作</li>
<li>sync.once</li>
<li>sync.atomic</li>
<li>channel</li>
</ol>
<p>slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 切片非并发安全</span></span><br><span class="line"><span class="comment">* 多次执行，每次得到的结果都不一样</span></span><br><span class="line"><span class="comment">* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSliceConcurrencySafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   a = <span class="built_in">append</span>(a, i)</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> t.Log(<span class="built_in">len</span>(a)) </span><br><span class="line"> <span class="comment">// not equal 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>复制代码</p>
<h1 id="第三章：Map"><a href="#第三章：Map" class="headerlink" title="第三章：Map"></a>第三章：Map</h1><h1 id="1-Go-map的底层实现原理？"><a href="#1-Go-map的底层实现原理？" class="headerlink" title="1.Go map的底层实现原理？"></a>1.Go map的底层实现原理？</h1><hr>
<p><em>caspar</em> <em>3638</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map的底层实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=212128410&amp;bvid=BV1Wa411b7x3&amp;cid=546742218&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go中的map是一个指针，占用8个字节，指向hmap结构体</p>
<p>源码包中<code>src/runtime/map.go</code>定义了hmap的数据结构：</p>
<p>hmap包含若干个结构为bmap的数组，每个bmap底层都采用链表结构，bmap通常叫其bucket</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640.png" alt="图片"></p>
<p><strong>hmap结构体</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int </span><br><span class="line">    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。</span><br><span class="line">    flags     uint8 </span><br><span class="line">    // 状态标志（是否处于正在写入的状态等）</span><br><span class="line">    B         uint8  </span><br><span class="line">    // buckets（桶）的对数</span><br><span class="line">    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶</span><br><span class="line">    noverflow uint16 </span><br><span class="line">    // 溢出桶的数量</span><br><span class="line">    hash0     uint32 </span><br><span class="line">    // 生成hash的随机数种子</span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。</span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。</span><br><span class="line">    nevacuate  uintptr        </span><br><span class="line">    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。</span><br><span class="line">    extra *mapextra </span><br><span class="line">    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</p>
<p>复制代码</p>
<p><strong>bmap结构体</strong></p>
<p><code>bmap</code> 就是我们常说的“桶”，一个桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果的低B位是相同的，关于key的定位我们在map的查询中详细说明。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置)。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [bucketCnt]uint8        </span><br><span class="line">    // len为8的数组</span><br><span class="line">    // 用来快速定位key是否在这个bmap中</span><br><span class="line">    // 一个桶最多8个槽位，如果key所在的tophash值在tophash中，则代表该key在这个桶中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<p>上面bmap结构是静态结构，在编译过程中<code>runtime.bmap</code>会拓展成以下结构体：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type bmap struct&#123;</span><br><span class="line">    tophash [8]uint8</span><br><span class="line">    keys [8]keytype </span><br><span class="line">    // keytype 由编译器编译时候确定</span><br><span class="line">    values [8]elemtype </span><br><span class="line">    // elemtype 由编译器编译时候确定</span><br><span class="line">    overflow uintptr </span><br><span class="line">    // overflow指向下一个bmap，overflow是uintptr而不是*bmap类型，保证bmap完全不含指针，是为了减少gc，溢出桶存储到extra字段中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<p>tophash就是用于实现快速定位key的位置，在实现过程中会使用key的hash值的高8位作为tophash值，存放在bmap的tophash字段中</p>
<p>tophash字段不仅存储key哈希值的高8位，还会存储一些状态值，用来表明当前桶单元状态，这些状态值都是小于minTopHash的</p>
<p>为了避免key哈希值的高8位值和这些状态值相等，产生混淆情况，所以当key哈希值高8位若小于minTopHash时候，自动将其值加上minTopHash作为该key的tophash。桶单元的状态值如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">emptyRest      = 0 // 表明此桶单元为空，且更高索引的单元也是空</span><br><span class="line">emptyOne       = 1 // 表明此桶单元为空</span><br><span class="line">evacuatedX     = 2 // 用于表示扩容迁移到新桶前半段区间</span><br><span class="line">evacuatedY     = 3 // 用于表示扩容迁移到新桶后半段区间</span><br><span class="line">evacuatedEmpty = 4 // 用于表示此单元已迁移</span><br><span class="line">minTopHash     = 5 // key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值</span><br><span class="line"></span><br><span class="line">func tophash(hash uintptr) uint8 &#123;</span><br><span class="line">    top := uint8(hash &gt;&gt; (goarch.PtrSize*8 - 8))</span><br><span class="line">    if top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    return top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>复制代码</p>
<p><strong>mapextra结构体</strong></p>
<p>当map的key和value都不是指针类型时候，bmap将完全不包含指针，那么gc时候就不用扫描bmap。bmap指向溢出桶的字段overflow是uintptr类型，为了防止这些overflow桶被gc掉，所以需要mapextra.overflow将它保存起来。如果bmap的overflow是*bmap类型，那么gc扫描的是一个个拉链表，效率明显不如直接扫描一段内存(hmap.mapextra.overflow)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type mapextra struct &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets</span><br><span class="line">    oldoverflow *[]*bma</span><br><span class="line">   // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket</span><br><span class="line">    nextOverflow *bmap </span><br><span class="line">     // 指向空闲的 overflow bucket 的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p><strong>总结</strong></p>
<p>bmap（bucket）内存数据结构可视化如下:</p>
<p>注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式，当key和value类型不一样的时候，key和value占用字节大小不一样，使用key&#x2F;value这种形式可能会因为内存对齐导致内存空间浪费，所以Go采用key和value分开存储的设计，更节省内存空间</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/640-20220309173633627.png" alt="图片"></p>
<h1 id="2-Go-map遍历为什么是无序的？"><a href="#2-Go-map遍历为什么是无序的？" class="headerlink" title="2.Go map遍历为什么是无序的？"></a>2.Go map遍历为什么是无序的？</h1><hr>
<p><em>caspar</em> <em>1880</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map遍历为什么是无序的？</summary><iframe src="https://player.bilibili.com/player.html?aid=297199288&amp;bvid=BV1CF41147KL&amp;cid=548490640&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序</p>
<p>主要原因有2点：</p>
<ul>
<li>map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个<strong>随机值序号的bucket</strong>，再从其中<strong>随机的cell</strong>开始遍历</li>
<li>map遍历时，是按序遍历bucket，同时按需遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个bucket中的key，搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了</li>
</ul>
<p>map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMapRange</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    t.Log(<span class="string">&quot;first range:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        t.Logf(<span class="string">&quot;m[%v]=%v &quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Log(<span class="string">&quot;\nsecond range:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        t.Logf(<span class="string">&quot;m[%v]=%v &quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现有序遍历</span></span><br><span class="line">    <span class="keyword">var</span> sl []<span class="type">int</span></span><br><span class="line">    <span class="comment">// 把 key 单独取出放到切片</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        sl = <span class="built_in">append</span>(sl, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序切片</span></span><br><span class="line">    sort.Ints(sl)</span><br><span class="line">    <span class="comment">// 以切片中的 key 顺序遍历 map 就是有序的了</span></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> sl &#123;</span><br><span class="line">        t.Log(k, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-Go-map为什么是非线程安全的？"><a href="#3-Go-map为什么是非线程安全的？" class="headerlink" title="3.Go map为什么是非线程安全的？"></a>3.Go map为什么是非线程安全的？</h1><hr>
<p><em>caspar</em> <em>1574</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map为什么是非线程安全的？</summary><iframe src="https://player.bilibili.com/player.html?aid=382366652&amp;bvid=BV1TZ4y167B7&amp;cid=549562194&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>map默认是并发不安全的，同时对map进行并发读写时，程序会panic，原因如下：</p>
<p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p>
<p>场景: 2个协程同时读和写，以下程序会出现致命错误：fatal error: concurrent map writes</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            s[i] = i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;map第%d个元素值是%d\n&quot;</span>, i, s[i])</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<p>复制代码</p>
<p>如果想实现map线程安全，有两种方式：</p>
<p>方式一：使用读写锁 <code>map</code> + <code>sync.RWMutex</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line">    s := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.Lock()</span><br><span class="line">            s[i] = i</span><br><span class="line">            lock.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.RLock()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;map第%d个元素值是%d\n&quot;</span>, i, s[i])</span><br><span class="line">            lock.RUnlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<p>复制代码</p>
<p>方式二：使用Go提供的 <code>sync.Map</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Map</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            m.Store(i, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            v, ok := m.Load(i)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Load: %v, %v\n&quot;</span>, v, ok)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23</p>
<p>复制代码</p>
<h1 id="4-Go-map如何查找？"><a href="#4-Go-map如何查找？" class="headerlink" title="4.Go map如何查找？"></a>4.Go map如何查找？</h1><hr>
<p><em>caspar</em> <em>1639</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map如何查找？</summary><iframe src="https://player.bilibili.com/player.html?aid=767293470&amp;bvid=BV1Xr4y1B7Pu&amp;cid=550339350&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带 comma 用法</span></span><br><span class="line">value := m<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span></span><br><span class="line">fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value:%s&quot;</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 comma 用法</span></span><br><span class="line">value, ok := m<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value:%s&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<p>map的查找通过生成汇编码可以知道，根据 key 的不同类型&#x2F;返回参数，编译器会将查找函数用更具体的函数替换，以优化效率：</p>
<table>
<thead>
<tr>
<th align="left">key 类型</th>
<th align="left">查找</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uint32</td>
<td align="left">mapaccess1_fast32(t <em>maptype, h</em> hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">mapaccess2_fast32(t <em>maptype, h</em> hmap, key uint32) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapaccess1_fast64(t <em>maptype, h</em> hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">mapaccess2_fast64(t <em>maptype, h</em> hmap, key uint64) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapaccess1_faststr(t <em>maptype, h</em> hmap, ky string) unsafe.Pointer</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">mapaccess2_faststr(t <em>maptype, h</em> hmap, ky string) (unsafe.Pointer, bool)</td>
</tr>
</tbody></table>
<h2 id="查找流程"><a href="#查找流程" class="headerlink" title="#查找流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/3-4.html#%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B">#</a><strong>查找流程</strong></h2><p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220117201006909.png" alt="img"></p>
<ol>
<li><strong>写保护监测</strong></li>
</ol>
<p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic，这也说明了 map 不是线程安全的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>复制代码</p>
<ol>
<li><strong>计算hash值</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>key经过哈希函数计算后，得到的哈希值如下（主流64位机下共 64 个 bit 位）， 不同类型的key会有不同的hash函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<ol>
<li><strong>找到hash对应的bucket</strong></li>
</ol>
<p>bucket定位：<strong>哈希值的低B个bit 位</strong>，用来定位key所存放的bucket</p>
<p>如果当前正在扩容中，并且定位到的旧bucket数据还未完成迁移，则使用旧的bucket（扩容前的bucket）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"><span class="comment">// 桶的个数m-1，即 1&lt;&lt;B-1,B=5时，则有0~31号桶</span></span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line"><span class="comment">// 计算哈希值对应的bucket</span></span><br><span class="line"><span class="comment">// t.bucketsize为一个bmap的大小，通过对哈希值和桶个数取模得到桶编号，通过对桶编号和buckets起始地址进行运算，获取哈希值对应的bucket</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">// 是否在扩容</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 桶个数已经发生增长一倍，则旧bucket的桶个数为当前桶个数的一半</span></span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值对应的旧bucket</span></span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 如果旧bucket的数据没有完成迁移，则使用旧bucket查找</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">        b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>复制代码</p>
<p><strong>4. 遍历bucket查找</strong></p>
<p>tophash值定位：<strong>哈希值的高8个bit 位</strong>，用来快速判断key是否已在当前bucket中（如果不在的话，需要去bucket的overflow中查找）</p>
<p>用步骤2中的hash值，得到高8个bit位，也就是<code>10010111</code>，转化为十进制，也就是<strong>151</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top := tophash(hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p>上面函数中hash是64位的，sys.PtrSize值是8，所以<code>top := uint8(hash &gt;&gt; (sys.PtrSize*8 - 8))</code>等效<code>top = uint8(hash &gt;&gt; 56)</code>，最后top取出来的值就是hash的高8位值</p>
<p>在 bucket 及bucket的overflow中寻找<strong>tophash 值（HOB hash）为 151* 的 槽位</strong>，即为key所在位置，找到了空槽位或者 2 号槽位，这样整个查找过程就结束了，其中找到空槽位代表没找到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">              <span class="comment">// 未被使用的槽位，插入</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到tophash值对应的的key</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>复制代码</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/f39e10e1474fda593cbca86eb0c517e2.png" alt="img"></p>
<p><strong>5. 返回key对应的指针</strong></p>
<p>如果通过上面的步骤找到了key对应的槽位下标 i，我们再详细分析下key&#x2F;value值是如何获取的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys的偏移量</span></span><br><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span>&#123;</span><br><span class="line">  b bmap</span><br><span class="line">  v <span class="type">int64</span></span><br><span class="line">&#125;&#123;&#125;.v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个bucket的元素个数</span></span><br><span class="line">bucketCnt = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 定位公式</span></span><br><span class="line">k :=add(unsafe.Pointer(b),dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 定位公式</span></span><br><span class="line">v:= add(unsafe.Pointer(b),dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>复制代码</p>
<p>bucket 里 keys 的起始地址就是 unsafe.Pointer(b)+dataOffset</p>
<p>第 i 个下标 key 的地址就要在此基础上跨过 i 个 key 的大小；</p>
<p>而我们又知道，value 的地址是在所有 key 之后，因此第 i 个下标 value 的地址还需要加上所有 key 的偏移。</p>
<h1 id="5-Go-map冲突的解决方式？"><a href="#5-Go-map冲突的解决方式？" class="headerlink" title="5.Go map冲突的解决方式？"></a>5.Go map冲突的解决方式？</h1><hr>
<p><em>caspar</em> <em>1489</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map冲突的解决方式？</summary><iframe src="https://player.bilibili.com/player.html?aid=724806999&amp;bvid=BV1YS4y1D7pM&amp;cid=550728187&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>比较常用的Hash冲突解决方案有链地址法和开放寻址法：</p>
<p><strong>链地址法</strong></p>
<p>当哈希冲突发生时，创建新<strong>单元</strong>，并将新单元添加到冲突单元所在链表的尾部。</p>
<p><strong>开放寻址法</strong></p>
<p>当哈希冲突发生时，从发生冲突的那个<strong>单元</strong>起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。<strong>开放寻址法需要的表长度要大于等于所需要存放的元素数量</strong></p>
<p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。这里以线性探测法来帮助读者理解开放寻址法思想</p>
<p><strong>线性探测法</strong></p>
<p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值， 表示哈希表的槽位数（哈希表的大小）。</p>
<p>线性探测法则可以表示为：</p>
<p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p>
<p><strong>两种解决方案比较</strong></p>
<p>对于链地址法，基于数组 + 链表进行存储，链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。</p>
<p>对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。<strong>当数据量明确、装载因子小，适合采用开放寻址法。</strong></p>
<p><strong>总结</strong></p>
<p>在发生哈希冲突时，Python中dict采用的开放寻址法，Java的HashMap采用的是链地址法，而Go map也采用链地址法解决冲突，具体就是<strong>插入key到map中时</strong>，当key定位的桶<strong>填满8个元素后</strong>（这里的单元就是桶，不是元素），将会创建一个溢出桶，并且将溢出桶插入当前桶所在链表尾部。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// 创建一个新的溢出桶</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<h1 id="6-Go-map-的负载因子为什么是-6-5？"><a href="#6-Go-map-的负载因子为什么是-6-5？" class="headerlink" title="6.Go map 的负载因子为什么是 6.5？"></a>6.Go map 的负载因子为什么是 6.5？</h1><hr>
<p><em>caspar</em> <em>1413</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map冲突的解决方式？</summary><iframe src="https://player.bilibili.com/player.html?aid=894801261&amp;bvid=BV1uP4y1u7cS&amp;cid=551527586&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>什么是负载因子?</strong></p>
<p><strong>负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标</strong>，也就是每个 bucket 桶存储的平均元素个数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 哈希表存储的元素个数/桶个数</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>另外负载因子<strong>与扩容、迁移</strong>等重新散列（rehash）行为有直接关系：</p>
<ul>
<li>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。</li>
<li>在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。</li>
</ul>
<p>负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是<strong>为了平衡 buckets 的存储空间大小和查找元素时的性能高低</strong>。</p>
<p>在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。</p>
<p><strong>为什么是 6.5?</strong></p>
<p>为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？</p>
<p><strong>测试报告</strong></p>
<p>实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。</p>
<p>报告中共包含 4 个关键指标，如下：</p>
<table>
<thead>
<tr>
<th align="left">loadFactor</th>
<th align="left">%overflow</th>
<th align="left">bytes&#x2F;entry</th>
<th align="left">hitprobe</th>
<th align="left">missprobe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">4.00</td>
<td align="left">2.13</td>
<td align="left">20.77</td>
<td align="left">3.00</td>
<td align="left">4.00</td>
</tr>
<tr>
<td align="left">4.50</td>
<td align="left">4.05</td>
<td align="left">17.30</td>
<td align="left">3.25</td>
<td align="left">4.50</td>
</tr>
<tr>
<td align="left">5.00</td>
<td align="left">6.85</td>
<td align="left">14.77</td>
<td align="left">3.50</td>
<td align="left">5.00</td>
</tr>
<tr>
<td align="left">5.50</td>
<td align="left">10.55</td>
<td align="left">12.94</td>
<td align="left">3.75</td>
<td align="left">5.50</td>
</tr>
<tr>
<td align="left">6.00</td>
<td align="left">15.27</td>
<td align="left">11.67</td>
<td align="left">4.00</td>
<td align="left">6.00</td>
</tr>
<tr>
<td align="left">6.50</td>
<td align="left">20.90</td>
<td align="left">10.79</td>
<td align="left">4.25</td>
<td align="left">6.50</td>
</tr>
<tr>
<td align="left">7.00</td>
<td align="left">27.14</td>
<td align="left">10.15</td>
<td align="left">4.50</td>
<td align="left">7.00</td>
</tr>
<tr>
<td align="left">7.50</td>
<td align="left">34.03</td>
<td align="left">9.73</td>
<td align="left">4.75</td>
<td align="left">7.50</td>
</tr>
<tr>
<td align="left">8.00</td>
<td align="left">41.10</td>
<td align="left">9.40</td>
<td align="left">5.00</td>
<td align="left">8.00</td>
</tr>
</tbody></table>
<ul>
<li>loadFactor：负载因子，也有叫装载因子。</li>
<li>%overflow：溢出率，有溢出 bukcet 的百分比。</li>
<li>bytes&#x2F;entry：平均每对 key&#x2F;value 的开销字节数.</li>
<li>hitprobe：查找一个存在的 key 时，要查找的平均个数。</li>
<li>missprobe：查找一个不存在的 key 时，要查找的平均个数。</li>
</ul>
<p><strong>选择数值</strong></p>
<p>Go 官方发现：<strong>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong></p>
<p>根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>
<p>这意味着在 Go 语言中，<strong>当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为</strong>。</p>
<h1 id="7-Go-map如何扩容"><a href="#7-Go-map如何扩容" class="headerlink" title="7.Go map如何扩容?"></a>7.Go map如何扩容?</h1><hr>
<p><em>caspar</em> <em>1513</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map如何扩容?</summary><iframe src="https://player.bilibili.com/player.html?aid=724796371&amp;bvid=BV1hS4y1D7Zs&amp;cid=552270537&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>扩容时机：</strong></p>
<p>在<strong>向 map 插入新 key</strong> 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">  hashGrow(t, h)</span><br><span class="line">  <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在扩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> growing() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<p><strong>扩容条件：</strong></p>
<p>条件1：超过负载</p>
<p>map元素个数 &gt; 6.5 * 桶个数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactor*bucketShift(B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中 </span><br><span class="line"></span><br><span class="line">bucketCnt = <span class="number">8</span>，一个桶可以装的最大元素个数</span><br><span class="line">loadFactor = <span class="number">6.5</span>，负载因子，平均每个桶的元素个数</span><br><span class="line">bucketShift(B): 桶的个数</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<p>条件2：溢出桶太多</p>
<p>当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多。</p>
<p>当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line">    <span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line">    <span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line">    <span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line">    <span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">        B = <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line">    <span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p>对于条件2，其实算是对条件1的补充。因为在负载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。</p>
<p>表面现象就是负载因子比较小比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。比如不断的增删，这样会造成overflow的bucket数量增多，但负载因子又不高，达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 扩容条件。</p>
<p><strong>扩容机制：</strong></p>
<p><strong>双倍扩容</strong>：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。该方法我们称之为<strong>双倍扩容</strong></p>
<p>**等量扩容：**针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。该方法我们称之为**等量扩容**。</p>
<p><strong>扩容函数：</strong></p>
<p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是<strong>插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作</strong>。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  <span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line"> <span class="number">2</span>  <span class="comment">// 如果达到条件 1，那么将B值加1，相当于是原来的2倍</span></span><br><span class="line"> <span class="number">3</span>  <span class="comment">// 否则对应条件 2，进行等量扩容，所以 B 不变</span></span><br><span class="line"> <span class="number">4</span>    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line"> <span class="number">6</span>        bigger = <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>        h.flags |= sameSizeGrow</span><br><span class="line"> <span class="number">8</span>    &#125;</span><br><span class="line"> <span class="number">9</span>  <span class="comment">// 记录老的buckets</span></span><br><span class="line"><span class="number">10</span>    oldbuckets := h.buckets</span><br><span class="line"><span class="number">11</span>  <span class="comment">// 申请新的buckets空间</span></span><br><span class="line"><span class="number">12</span>    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"><span class="number">13</span>  <span class="comment">// 注意&amp;^ 运算符，这块代码的逻辑是转移标志位</span></span><br><span class="line"><span class="number">14</span>    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line"><span class="number">15</span>    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line"><span class="number">16</span>        flags |= oldIterator</span><br><span class="line"><span class="number">17</span>    &#125;</span><br><span class="line"><span class="number">18</span>    <span class="comment">// 提交grow (atomic wrt gc)</span></span><br><span class="line"><span class="number">19</span>    h.B += bigger</span><br><span class="line"><span class="number">20</span>    h.flags = flags</span><br><span class="line"><span class="number">21</span>    h.oldbuckets = oldbuckets</span><br><span class="line"><span class="number">22</span>    h.buckets = newbuckets</span><br><span class="line"><span class="number">23</span>  <span class="comment">// 搬迁进度为0</span></span><br><span class="line"><span class="number">24</span>    h.nevacuate = <span class="number">0</span></span><br><span class="line"><span class="number">25</span>  <span class="comment">// overflow buckets 数为0</span></span><br><span class="line"><span class="number">26</span>    h.noverflow = <span class="number">0</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>  <span class="comment">// 如果发现hmap是通过extra字段 来存储 overflow buckets时</span></span><br><span class="line"><span class="number">29</span>    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">30</span>        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">31</span>            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line"><span class="number">32</span>        &#125;</span><br><span class="line"><span class="number">33</span>        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line"><span class="number">34</span>        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line"><span class="number">35</span>    &#125;</span><br><span class="line"><span class="number">36</span>    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">37</span>        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">38</span>            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line"><span class="number">39</span>        &#125;</span><br><span class="line"><span class="number">40</span>        h.extra.nextOverflow = nextOverflow</span><br><span class="line"><span class="number">41</span>    &#125;</span><br><span class="line"><span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p>
<p>复制代码</p>
<p>由于 map 扩容需要将原有的 key&#x2F;value 重新搬迁到新的内存地址，如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，因此 Go map 的扩容采取了一种称为<strong>“渐进式”</strong>的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为了确认搬迁的 bucket 是我们正在使用的 bucket</span></span><br><span class="line">    <span class="comment">// 即如果当前key映射到老的bucket1，那么就搬迁该bucket1。</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">    <span class="comment">// 如果还未完成扩容工作，则再搬迁一个bucket。</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<h1 id="8-Go-map和sync-Map谁的性能好，为什么？"><a href="#8-Go-map和sync-Map谁的性能好，为什么？" class="headerlink" title="8.Go map和sync.Map谁的性能好，为什么？"></a>8.Go map和sync.Map谁的性能好，为什么？</h1><hr>
<p><em>caspar</em> <em>1463</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go map和sync.Map谁的性能好，为什么？</summary><iframe src="https://player.bilibili.com/player.html?aid=937429370&amp;bvid=BV1UT4y1v773&amp;cid=553415261&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go 语言的 <code>sync.Map</code> 支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu Mutex</span><br><span class="line">   read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">   dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">   misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p><strong>对比原始map：</strong></p>
<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>
<p><strong>优点：</strong></p>
<p>适合读多写少的场景</p>
<p><strong>缺点：</strong></p>
<p>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p>
<h1 id="第四章：Channel"><a href="#第四章：Channel" class="headerlink" title="第四章：Channel"></a>第四章：Channel</h1><h2 id="1-for-select-时，如果通道已经关闭会怎么样？如果select中只有一个case呢？"><a href="#1-for-select-时，如果通道已经关闭会怎么样？如果select中只有一个case呢？" class="headerlink" title="1. for select 时，如果通道已经关闭会怎么样？如果select中只有一个case呢？"></a>1. for select 时，如果通道已经关闭会怎么样？如果select中只有一个case呢？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Ju41167BL?p=9&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h1 id="1-Go-channel的底层实现原理？"><a href="#1-Go-channel的底层实现原理？" class="headerlink" title="1.Go channel的底层实现原理？"></a>1.Go channel的底层实现原理？</h1><hr>
<p><em>caspar</em> <em>3041</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel的底层实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=979954115&amp;bvid=BV1N44y1N7Cs&amp;cid=554071750&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>概念：</strong></p>
<p>Go中的channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的）</p>
<p><strong>使用场景：</strong></p>
<p>停止信号监听</p>
<p>定时任务</p>
<p>生产方和消费方解耦</p>
<p>控制并发数</p>
<p><strong>底层数据结构：</strong></p>
<p>通过var声明或者make函数创建的channel变量是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>
<p>源码包中<code>src/runtime/chan.go</code>定义了hchan的数据结构：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/hchan.png" alt="hchan"></p>
<p>hchan结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"> closed   <span class="type">uint32</span>   <span class="comment">// channel是否关闭的标志</span></span><br><span class="line"> elemtype *_type   <span class="comment">// channel中的元素类型</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// channel分为无缓冲和有缓冲两种。</span></span><br><span class="line"> <span class="comment">// 对于有缓冲的channel存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组</span></span><br><span class="line"> <span class="comment">// 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移</span></span><br><span class="line"> <span class="comment">// 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</span></span><br><span class="line"> buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针（环形缓冲区）</span></span><br><span class="line"> qcount   <span class="type">uint</span>           <span class="comment">// 循环数组中的元素数量</span></span><br><span class="line"> dataqsiz <span class="type">uint</span>           <span class="comment">// 循环数组的长度</span></span><br><span class="line"> elemsize <span class="type">uint16</span>                 <span class="comment">// 元素的大小</span></span><br><span class="line"> sendx    <span class="type">uint</span>           <span class="comment">// 下一次写下标的位置</span></span><br><span class="line"> recvx    <span class="type">uint</span>           <span class="comment">// 下一次读下标的位置</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 尝试读取channel或向channel写入数据而被阻塞的goroutine</span></span><br><span class="line"> recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line"> sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line"></span><br><span class="line"> lock mutex <span class="comment">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<p>复制代码</p>
<p>等待队列：</p>
<p>双向链表，包含一个头结点和一个尾结点</p>
<p>每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送&#x2F;接收的数据在哪里</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">   first *sudog</span><br><span class="line">   last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer </span><br><span class="line">    c        *hchan </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>复制代码</p>
<p><strong>操作</strong>：</p>
<p><strong>创建</strong></p>
<p>使用 <code>make(chan T, cap)</code> 来创建 channel，make 语法会在编译时，转换为 <code>makechan64</code> 和 <code>makechan</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<p>创建channel 有两种，一种是带缓冲的channel，一种是不带缓冲的channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 不带缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<p>创建时会做一些检查:</p>
<ul>
<li>元素大小不能超过 64K</li>
<li>元素的对齐大小不能超过 maxAlign 也就是 8 字节</li>
<li>计算出来的内存是否超过限制</li>
</ul>
<p>创建时的策略:</p>
<ul>
<li>如果是无缓冲的 channel，会直接给 hchan 分配内存</li>
<li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</li>
<li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</li>
</ul>
<p><strong>发送</strong></p>
<p>发送操作，编译时转换为<code>runtime.chansend</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> </span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>阻塞式：</p>
<p>调用chansend函数，并且block&#x3D;true</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>非阻塞式：</p>
<p>调用chansend函数，并且block&#x3D;false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">10</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p>向 channel 中发送数据时大概分为两大块：检查和数据发送，数据发送流程如下：</p>
<ul>
<li>如果 channel 的读等待队列存在接收者goroutine<ul>
<li>将数据<strong>直接发送</strong>给第一个等待的 goroutine， <strong>唤醒接收的 goroutine</strong></li>
</ul>
</li>
<li>如果 channel 的读等待队列不存在接收者goroutine<ul>
<li>如果循环数组buf未满，那么将会把数据发送到循环数组buf的队尾</li>
<li>如果循环数组buf已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并<strong>挂起等待唤醒</strong></li>
</ul>
</li>
</ul>
<p><strong>接收</strong></p>
<p>发送操作，编译时转换为<code>runtime.chanrecv</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) </span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>阻塞式：</p>
<p>调用chanrecv函数，并且block&#x3D;true</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ch</span><br><span class="line"></span><br><span class="line">v := &lt;ch</span><br><span class="line"></span><br><span class="line">v, ok := &lt;ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel,造成读到数据为通道所存储的数据类型的零值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<p>非阻塞式：</p>
<p>调用chanrecv函数，并且block&#x3D;false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p>向 channel 中接收数据时大概分为两大块，检查和数据发送，而数据接收流程如下：</p>
<ul>
<li>如果 channel 的写等待队列存在发送者goroutine<ul>
<li>如果是无缓冲 channel，<strong>直接</strong>从第一个发送者goroutine那里把数据拷贝给接收变量，<strong>唤醒发送的 goroutine</strong></li>
<li>如果是有缓冲 channel（已满），将循环数组buf的队首元素拷贝给接收变量，将第一个发送者goroutine的数据拷贝到 buf循环数组队尾，<strong>唤醒发送的 goroutine</strong></li>
</ul>
</li>
<li>如果 channel 的写等待队列不存在发送者goroutine<ul>
<li>如果循环数组buf非空，将循环数组buf的队首元素拷贝给接收变量</li>
<li>如果循环数组buf为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>
</ul>
</li>
</ul>
<p><strong>关闭</strong></p>
<p>关闭操作，调用close函数，编译时转换为<code>runtime.closechan</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> </span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p><strong>案例分析：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// ch是长度为4的带缓冲的channel</span></span><br><span class="line">  <span class="comment">// 初始hchan结构体重的buf为空，sendx和recvx均为0</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(ch, unsafe.Sizeof(ch))</span><br><span class="line">    <span class="keyword">go</span> sendTask(ch)</span><br><span class="line">    <span class="keyword">go</span> receiveTask(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G1是发送者</span></span><br><span class="line"><span class="comment">// 当G1向ch里发送数据时，首先会对buf加锁，然后将task存储的数据copy到buf中，然后sendx++，然后释放对buf的锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTask</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    taskList := []<span class="type">string</span>&#123;<span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;demo&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> taskList &#123;</span><br><span class="line">        ch &lt;- task <span class="comment">//发送任务到channel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G2是接收者</span></span><br><span class="line"><span class="comment">// 当G2消费ch的时候，会首先对buf加锁，然后将buf中的数据copy到task变量对应的内存里，然后recvx++,并释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveTask</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task := &lt;-ch                  <span class="comment">//接收任务</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;received&quot;</span>, task) <span class="comment">//处理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35</p>
<p>复制代码</p>
<p>总结hchan结构体的主要组成部分有四个：</p>
<ul>
<li>用来保存goroutine之间传递数据的循环数组：buf</li>
<li>用来记录此循环数组当前发送或接收数据的下标值：sendx和recvx</li>
<li>用于保存向该chan发送和从该chan接收数据被阻塞的goroutine队列： sendq 和 recvq</li>
<li>保证channel写入和读取数据时线程安全的锁：lock</li>
</ul>
<h1 id="2-Go-channel有什么特点？"><a href="#2-Go-channel有什么特点？" class="headerlink" title="2.Go channel有什么特点？"></a>2.Go channel有什么特点？</h1><hr>
<p><em>caspar</em> <em>1579</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel有什么特点？</summary><iframe src="https://player.bilibili.com/player.html?aid=339954906&amp;bvid=BV1NR4y1c7df&amp;cid=556064380&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>channel有2种类型：无缓冲、有缓冲</p>
<p>channel有3种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>
<table>
<thead>
<tr>
<th></th>
<th>写操作模式</th>
<th>读操作模式</th>
<th>读写操作模式</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>make(chan&lt;- int)</td>
<td>make(&lt;-chan int)</td>
<td>make(chan int)</td>
</tr>
</tbody></table>
<p>channel有3种状态：未初始化、正常、关闭</p>
<table>
<thead>
<tr>
<th></th>
<th>未初始化</th>
<th>关闭</th>
<th>正常</th>
</tr>
</thead>
<tbody><tr>
<td>关闭</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>发送</td>
<td>永远阻塞导致死锁</td>
<td>panic</td>
<td>阻塞或者成功发送</td>
</tr>
<tr>
<td>接收</td>
<td>永远阻塞导致死锁</td>
<td>缓冲区为空则为零值, 否则可以继续读</td>
<td>阻塞或者成功接收</td>
</tr>
</tbody></table>
<p><strong>注意点</strong>：</p>
<ol>
<li>一个 channel不能多次关闭，会导致painc</li>
<li>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></li>
<li>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></li>
</ol>
<h1 id="3-Go-channel有无缓冲的区别？"><a href="#3-Go-channel有无缓冲的区别？" class="headerlink" title="3.Go channel有无缓冲的区别？"></a>3.Go channel有无缓冲的区别？</h1><hr>
<p><em>caspar</em> <em>1415</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel有无缓冲的区别？</summary><iframe src="https://player.bilibili.com/player.html?aid=767547717&amp;bvid=BV1br4y1q71d&amp;cid=556811503&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>无缓冲：一个送信人去你家送信，你不在家他不走，你一定要接下信，他才会走。</p>
<p>有缓冲：一个送信人去你家送信，扔到你家的信箱转身就走，除非你的信箱满了，他必须等信箱有多余空间才会走。</p>
<table>
<thead>
<tr>
<th></th>
<th>无缓冲</th>
<th>有缓冲</th>
</tr>
</thead>
<tbody><tr>
<td>创建方式</td>
<td>make(chan TYPE)</td>
<td>make(chan TYPE, SIZE)</td>
</tr>
<tr>
<td>发送阻塞</td>
<td>数据接收前发送阻塞</td>
<td>缓冲满时发送阻塞</td>
</tr>
<tr>
<td>接收阻塞</td>
<td>数据发送前接收阻塞</td>
<td>缓冲空时接收阻塞</td>
</tr>
</tbody></table>
<p><strong>非缓冲</strong> <code>channel</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">&quot;this  value of unbuffer channel&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">go</span> loop(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</p>
<p>复制代码</p>
<p>这里会报错 <code>fatal error: all goroutines are asleep - deadlock!</code> 就是因为 <code>ch&lt;-1</code> 发送了，但是同时没有接收者，所以就发生了阻塞</p>
<p>但如果我们把 <code>ch &lt;- 1</code> 放到 <code>go loop(ch)</code> 下面，程序就会正常运行</p>
<p><strong>缓冲</strong> <code>channel</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">&quot;this  value of unbuffer channel&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    <span class="keyword">go</span> loop(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25</p>
<p>复制代码</p>
<p>这里也会报 fatal error: all goroutines are asleep - deadlock! ，这是因为 channel 的大小为 3 ，而我们要往里面塞 4 个数据，所以就会阻塞住，解决的办法有两个:</p>
<ol>
<li>把 channel 长度调大一点</li>
<li>把 channel 的信息发送者 ch &lt;- 1 这些代码移动到 go loop(ch) 下面 ，让 channel 实时消费就不会导致阻塞了</li>
</ol>
<h1 id="4-Go-channel为什么是线程安全的？"><a href="#4-Go-channel为什么是线程安全的？" class="headerlink" title="4.Go channel为什么是线程安全的？"></a>4.Go channel为什么是线程安全的？</h1><hr>
<p><em>caspar</em> <em>1341</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel为什么是线程安全的？</summary><iframe src="https://player.bilibili.com/player.html?aid=212591784&amp;bvid=BV1Pa411b7CL&amp;cid=557840651&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>为什么设计成线程安全？</strong></p>
<p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>
<p><strong>如何实现线程安全的？</strong></p>
<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>
<h1 id="5-Go-channel如何控制goroutine并发执行顺序？"><a href="#5-Go-channel如何控制goroutine并发执行顺序？" class="headerlink" title="5.Go channel如何控制goroutine并发执行顺序？"></a>5.Go channel如何控制goroutine并发执行顺序？</h1><hr>
<p><em>caspar</em> <em>1346</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel如何控制goroutine并发执行顺序？</summary><iframe src="https://player.bilibili.com/player.html?aid=510103685&amp;bvid=BV1gu411B73Y&amp;cid=558262036&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>多个goroutine并发执行时，每一个goroutine抢到处理器的时间点不一致，gorouine的执行本身不能保证顺序</strong>。即代码中先写的gorouine并不能保证先执行</p>
<p>思路：使用channel进行通信通知，用channel去传递信息，从而控制并发执行顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch2 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch3 :<span class="operator">=</span> make(chan struct&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch1 <span class="operator">&lt;</span><span class="operator">-</span> struct&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">start</span> :<span class="operator">=</span> time.Now().Unix()</span><br><span class="line">    go print(&quot;gorouine1&quot;, ch1, ch2)</span><br><span class="line">    go print(&quot;gorouine2&quot;, ch2, ch3)</span><br><span class="line">    go print(&quot;gorouine3&quot;, ch3, ch1)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">end</span> :<span class="operator">=</span> time.Now().Unix()</span><br><span class="line">    fmt.Printf(&quot;duration:%d\n&quot;, <span class="keyword">end</span><span class="operator">-</span><span class="keyword">start</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func print(gorouine string, inputchan chan struct&#123;&#125;, outchan chan struct&#123;&#125;) &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 模拟内部操作耗时</span><br><span class="line">    time.Sleep(<span class="number">1</span> <span class="operator">*</span> time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="operator">&lt;</span><span class="operator">-</span>inputchan:</span><br><span class="line">        fmt.Printf(&quot;%s\n&quot;, gorouine)</span><br><span class="line">        outchan <span class="operator">&lt;</span><span class="operator">-</span> struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35</p>
<p>复制代码</p>
<ul>
<li>输出：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gorouine1</span><br><span class="line">gorouine2</span><br><span class="line">gorouine3</span><br><span class="line">duration:1</span><br></pre></td></tr></table></figure>



<h1 id="6-Go-channel共享内存有什么优劣势？"><a href="#6-Go-channel共享内存有什么优劣势？" class="headerlink" title="6.Go channel共享内存有什么优劣势？"></a>6.Go channel共享内存有什么优劣势？</h1><hr>
<p><em>caspar</em> <em>1260</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel共享内存有什么优劣势？</summary><iframe src="https://player.bilibili.com/player.html?aid=937598899&amp;bvid=BV16T4y1i7wS&amp;cid=559620157&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 这句话想必大家已经非常熟悉了，在官方的博客，初学时的教程，甚至是在 Go 的源码中都能看到</p>
<p>无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP(Communication Sequential Process) 模型以及 Erlang 采用的 Actor 模型，这两种方式都是通过通信来共享内存。</p>
<p><img src="https://img.lailin.xyz/image/1610460699237-f6400aaa-34d5-4c8d-b323-27683704abd2.png" alt="02_Go进阶03_blog_channel.png"></p>
<p>大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。而 Actor 模型和 CSP 模型都是通过发送消息来共享内存，但是它们之间最大的区别就是 Actor 模型当中并没有一个独立的 Channel 组件，而是 Actor 与 Actor 之间直接进行消息的发送与接收，每个 Actor 都有一个本地的“信箱”消息都会先发送到这个“信箱当中”。</p>
<p><strong>优点</strong></p>
<ul>
<li>使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>容易出现死锁的情况</li>
</ul>
<h1 id="7-Go-channel发送和接收什么情况下会死锁？"><a href="#7-Go-channel发送和接收什么情况下会死锁？" class="headerlink" title="7.Go channel发送和接收什么情况下会死锁？"></a>7.Go channel发送和接收什么情况下会死锁？</h1><hr>
<p><em>caspar</em> <em>1332</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go channel发送和接收什么情况下会死锁？</summary><iframe src="https://player.bilibili.com/player.html?aid=595154615&amp;bvid=BV1aq4y1Y7Jv&amp;cid=560133081&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p><strong>死锁：</strong></p>
<ul>
<li>单个协程永久阻塞</li>
<li>两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</li>
</ul>
<p><strong>channel死锁场景：</strong></p>
<ul>
<li>非缓存channel只写不读</li>
<li>非缓存channel读在写后面</li>
<li>缓存channel写入超过缓冲区数量</li>
<li>空读</li>
<li>多个协程互相等待</li>
</ul>
<ol>
<li>非缓存channel只写不读</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line">    ch &lt;- <span class="number">3</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<ol>
<li>非缓存channel读在写后面</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span>  <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    num := &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">100</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        num := &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p>复制代码</p>
<ol>
<li>缓存channel写入超过缓冲区数量</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">    ch &lt;- <span class="number">6</span>  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<ol>
<li>空读</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// ch := make(chan int, 1)</span></span><br><span class="line">    fmt.Println(&lt;-ch)  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>
<ol>
<li><strong>多个协程互相等待</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 互相等对方造成死锁</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">                fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">                ch2 &lt;- <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">            ch1 &lt;- <span class="number">300</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</p>
<p>复制代码</p>
<h1 id="第五章：Mutex"><a href="#第五章：Mutex" class="headerlink" title="第五章：Mutex"></a>第五章：Mutex</h1><h1 id="1-Go-互斥锁的实现原理？"><a href="#1-Go-互斥锁的实现原理？" class="headerlink" title="1.Go 互斥锁的实现原理？"></a>1.Go 互斥锁的实现原理？</h1><hr>
<p><em>caspar</em> <em>2504</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 互斥锁的实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=937723304&amp;bvid=BV1BT4y1e7W7&amp;cid=561757939&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于悲观锁。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>Mutex是互斥锁，当一个 goroutine 获得了锁后，其他 goroutine 不能获取锁（只能存在一个写者或读者，不能同时读和写）</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="#使用场景"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h2><p>多个线程同时访问临界区，为保证数据的安全，锁住一些共享资源， 以防止并发访问这些共享数据时可能导致的数据不一致问题。</p>
<p>获取锁的线程可以正常访问临界区，未获取到锁的线程等待锁释放后可以尝试获取锁</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/thread_safe.png" alt="img"></p>
<h2 id="底层实现结构"><a href="#底层实现结构" class="headerlink" title="#底层实现结构"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84">#</a>底层实现结构</h2><p>互斥锁对应的是底层结构是sync.Mutex结构体，，位于 src&#x2F;sync&#x2F;mutex.go中</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Mutex struct &#123;  </span><br><span class="line">     state int32  </span><br><span class="line">     sema  uint32</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<p>state表示锁的状态，有锁定、被唤醒、饥饿模式等，并且是用state的二进制位来标识的，不同模式下会有不同的处理方式</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_state.png" alt="mutex_state"></p>
<p>sema表示信号量，mutex阻塞队列的定位是通过这个变量来实现的，从而实现goroutine的阻塞和唤醒</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_sema.png" alt="mutex_sema"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">addr = &amp;sema</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semroot</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> *semaRoot &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;semtable[(<span class="type">uintptr</span>(unsafe.Pointer(addr))&gt;&gt;<span class="number">3</span>)%semTabSize].root  </span><br><span class="line">&#125;</span><br><span class="line">root := semroot(addr)</span><br><span class="line">root.queue(addr, s, lifo)</span><br><span class="line">root.dequeue(addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> semtable [<span class="number">251</span>]<span class="keyword">struct</span> &#123;  </span><br><span class="line">   root semaRoot  </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;  </span><br><span class="line">  lock  mutex  </span><br><span class="line">  treap *sudog <span class="comment">// root of balanced tree of unique waiters.  </span></span><br><span class="line">  nwait <span class="type">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g  </span><br><span class="line">    next *sudog  </span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// 指向sema变量</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot  </span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28</p>
<p>复制代码</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="#操作"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%93%8D%E4%BD%9C">#</a>操作</h2><p>锁的实现一般会依赖于原子操作、信号量，通过atomic 包中的一些原子操作来实现锁的锁定，通过信号量来实现线程的阻塞与唤醒</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="#加锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E5%8A%A0%E9%94%81">#</a><strong>加锁</strong></h3><p>通过原子操作cas加锁，如果加锁不成功，根据不同的场景选择自旋重试加锁或者阻塞等待被唤醒后加锁</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_lock.png" alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (m *Mutex) Lock() &#123;</span><br><span class="line">    // Fast path: 幸运之路，一下就获取到了锁</span><br><span class="line">    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Slow path：缓慢之路，尝试自旋或阻塞获取锁</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="#解锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E8%A7%A3%E9%94%81">#</a><strong>解锁</strong></h3><p>通过原子操作add解锁，如果仍有goroutine在等待，唤醒等待的goroutine</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/mutex_unlock.png" alt="mutex_unlock"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (m *Mutex) Unlock() &#123;  </span><br><span class="line">   // Fast path: 幸运之路，解锁</span><br><span class="line">   new := atomic.AddInt32(&amp;m.state, -mutexLocked)  </span><br><span class="line">   if new != 0 &#123;  </span><br><span class="line">            // Slow path：如果有等待的goroutine，唤醒等待的goroutine</span><br><span class="line">            m.unlockSlow()</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="#注意点："></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-1.html#%E6%B3%A8%E6%84%8F%E7%82%B9">#</a><strong>注意点：</strong></h3><ul>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁</li>
<li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 Lock，另一个 goroutine 可以 Unlock</li>
</ul>
<h1 id="2-Go-互斥锁正常模式和饥饿模式的区别？"><a href="#2-Go-互斥锁正常模式和饥饿模式的区别？" class="headerlink" title="2.Go 互斥锁正常模式和饥饿模式的区别？"></a>2.Go 互斥锁正常模式和饥饿模式的区别？</h1><hr>
<p><em>caspar</em> <em>1544</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 互斥锁正常模式和饥饿模式的区别？</summary><iframe src="https://player.bilibili.com/player.html?aid=212667913&amp;bvid=BV1da411x7KK&amp;cid=562576834&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>在Go一共可以分为两种抢锁的模式，一种是<strong>正常模式</strong>，另外一种是<strong>饥饿模式</strong>。</p>
<h2 id="正常模式-非公平锁"><a href="#正常模式-非公平锁" class="headerlink" title="#正常模式(非公平锁)"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">#</a>正常模式(非公平锁)</h2><p>在刚开始的时候，是处于正常模式（Barging），也就是，当一个G1持有着一个锁的时候，G2会自旋的去尝试获取这个锁</p>
<p>当<strong>自旋超过4次</strong>还没有能获取到锁的时候，这个G2就会被加入到获取锁的等待队列里面，并阻塞等待唤醒</p>
<p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式</p>
<h2 id="饥饿模式-公平锁"><a href="#饥饿模式-公平锁" class="headerlink" title="#饥饿模式(公平锁)"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E9%A5%A5%E9%A5%BF%E6%A8%A1%E5%BC%8F-%E5%85%AC%E5%B9%B3%E9%94%81">#</a>饥饿模式(公平锁)</h2><p>当一个 goroutine 等待锁时间超过 1 毫秒时，它可能会遇到饥饿问题。 在版本1.9中，这种场景下Go Mutex 切换到饥饿模式（handoff），解决饥饿问题。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">starving = runtime_nanotime()-waitStartTime &gt; 1e6</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式</p>
<p>那么也不可能说永远的保持一个饥饿的状态，总归会有吃饱的时候，也就是总有那么一刻Mutex会回归到正常模式，那么回归正常模式必须具备的条件有以下几种：</p>
<ol>
<li>G的执行时间小于1ms</li>
<li>等待队列已经全部清空了</li>
</ol>
<p>当满足上述两个条件的任意一个的时候，Mutex会切换回正常模式，而Go的抢锁的过程，就是在这个正常模式和饥饿模式中来回切换进行的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)  </span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;  </span><br><span class="line">    delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-2.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。</p>
<h1 id="3-Go-互斥锁允许自旋的条件？"><a href="#3-Go-互斥锁允许自旋的条件？" class="headerlink" title="3.Go 互斥锁允许自旋的条件？"></a>3.Go 互斥锁允许自旋的条件？</h1><hr>
<p><em>caspar</em> <em>1323</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 互斥锁允许自旋的条件？</summary><iframe src="https://player.bilibili.com/player.html?aid=810135446&amp;bvid=BV1p34y147aL&amp;cid=563375098&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>线程没有获取到锁时常见有2种处理方式：</p>
<ul>
<li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁也叫做<strong>自旋锁</strong>，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>
<li>另外一种处理方式就是把自己阻塞起来，会<strong>释放CPU给其他线程</strong>，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销</li>
</ul>
<p>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞</p>
<p><strong>允许自旋的条件：</strong></p>
<ol>
<li>锁已被占用，并且锁不处于饥饿模式。</li>
<li>积累的自旋次数小于最大自旋次数（active_spin&#x3D;4）。</li>
<li>cpu 核数大于 1。</li>
<li>有空闲的 P。</li>
<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;  </span><br><span class="line">    ...</span><br><span class="line">    runtime_doSpin()   </span><br><span class="line">    <span class="keyword">continue</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin </span><br><span class="line">    || ncpu &lt;= <span class="number">1</span> </span><br><span class="line">    || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">   <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>复制代码</p>
<p><strong>自旋：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    procyield(active_spin_cnt)</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>复制代码</p>
<p>如果可以进入自旋状态之后就会调用 <code>runtime_doSpin</code> 方法进入自旋， <code>doSpin</code> 方法会调用 <code>procyield(30)</code> 执行30次 <code>PAUSE</code> 指令，什么都不做，但是会消耗CPU时间</p>
<h1 id="4-Go-读写锁的实现原理？"><a href="#4-Go-读写锁的实现原理？" class="headerlink" title="4.Go 读写锁的实现原理？"></a>4.Go 读写锁的实现原理？</h1><hr>
<p><em>caspar</em> <em>1315</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 读写锁的实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=980367149&amp;bvid=BV1k44y1P7Kd&amp;cid=564296461&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>读写互斥锁RWMutex，是对Mutex的一个扩展，当一个 goroutine 获得了读锁后，其他 goroutine可以获取读锁，但不能获取写锁；当一个 goroutine 获得了写锁后，其他 goroutine既不能获取读锁也不能获取写锁（只能存在一个写者或多个读者，可以同时读）</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="#使用场景"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h2><p><strong>读</strong>多于<strong>写</strong>的情况（既保证线程安全，又保证性能不太差）</p>
<h2 id="底层实现结构-1"><a href="#底层实现结构-1" class="headerlink" title="#底层实现结构"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84">#</a>底层实现结构</h2><p>互斥锁对应的是底层结构是sync.RWMutex结构体，，位于 src&#x2F;sync&#x2F;rwmutex.go中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 复用互斥锁</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 信号量，用于写等待读</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 信号量，用于读等待写</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 当前执行读的 goroutine 数量</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 被阻塞的准备读的 goroutine 的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="#操作:"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%93%8D%E4%BD%9C">#</a><strong>操作:</strong></h3><p>读锁的加锁与释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() <span class="comment">// 加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() <span class="comment">// 释放读锁</span></span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<h3 id="加读锁"><a href="#加读锁" class="headerlink" title="#加读锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%8A%A0%E8%AF%BB%E9%94%81">#</a><strong>加读锁</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line"><span class="comment">// 为什么readerCount会小于0呢？往下看发现writer的Lock()会对readerCount做减法操作（原子操作）</span></span><br><span class="line">  <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">    runtime_Semacquire(&amp;rw.readerSem)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<p><code>atomic.AddInt32(&amp;rw.readerCount, 1)</code> 调用这个原子方法，对当前在读的数量加1，如果返回负数，那么说明当前有其他写锁，这时候就调用 <code>runtime_SemacquireMutex</code> 休眠当前goroutine 等待被唤醒</p>
<h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="#释放读锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E9%87%8A%E6%94%BE%E8%AF%BB%E9%94%81">#</a><strong>释放读锁</strong></h3><p>解锁的时候对正在读的操作减1，如果返回值小于 0 那么说明当前有在写的操作，这个时候调用 <code>rUnlockSlow</code> 进入慢速通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>
<p>被阻塞的准备读的 goroutine 的数量减1，readerWait 为 0，就表示当前没有正在准备读的 goroutine 这时候调用 <code>runtime_Semrelease</code> 唤醒写操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<p>写锁的加锁与释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() <span class="comment">// 加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() <span class="comment">// 释放写锁</span></span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<h3 id="加写锁"><a href="#加写锁" class="headerlink" title="#加写锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E5%8A%A0%E5%86%99%E9%94%81">#</a><strong>加写锁</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// Wait for active readers.</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        runtime_Semacquire(&amp;rw.writerSem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>复制代码</p>
<p>首先调用互斥锁的 lock，获取到互斥锁之后，如果计算之后当前仍然有其他 goroutine 持有读锁，那么就调用 <code>runtime_SemacquireMutex</code> 休眠当前的 goroutine 等待所有的读操作完成</p>
<p>这里readerCount 原子性加上一个很大的负数，是防止后面的协程能拿到读锁，阻塞读</p>
<h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="#释放写锁"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E9%87%8A%E6%94%BE%E5%86%99%E9%94%81">#</a><strong>释放写锁</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<p>解锁的操作，会先调用 <code>atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</code> 将恢复之前写入的负数，然后根据当前有多少个读操作在等待，循环唤醒</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="#注意点"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E6%B3%A8%E6%84%8F%E7%82%B9">#</a>注意点</h2><ul>
<li>读锁或写锁在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>使用 Lock() 加锁后，再次 Lock() 会导致死锁（不支持重入），需Unlock()解锁后才能再加锁</li>
<li>锁定状态与 goroutine 没有关联，一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）</li>
</ul>
<h2 id="互斥锁和读写锁的区别"><a href="#互斥锁和读写锁的区别" class="headerlink" title="#互斥锁和读写锁的区别"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-4.html#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>互斥锁和读写锁的区别</h2><ul>
<li>读写锁区分读者和写者，而互斥锁不区分</li>
<li>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
<h1 id="5-Go-可重入锁如何实现？"><a href="#5-Go-可重入锁如何实现？" class="headerlink" title="5.Go 可重入锁如何实现？"></a>5.Go 可重入锁如何实现？</h1><hr>
<p><em>caspar</em> <em>1082</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 可重入锁如何实现？</summary><iframe src="https://player.bilibili.com/player.html?aid=255308112&amp;bvid=BV19Y411J7tB&amp;cid=565415509&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-2"><a href="#概念-2" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法时会自动获取锁，不会因为之前已经获取过还没释放再次加锁导致死锁</p>
<h2 id="为什么Go语言中没有可重入锁？"><a href="#为什么Go语言中没有可重入锁？" class="headerlink" title="#为什么Go语言中没有可重入锁？"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E4%B8%BA%E4%BB%80%E4%B9%88go%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">#</a>为什么Go语言中没有可重入锁？</h2><p>Mutex 不是可重入的锁。Mutex 的实现中没有记录哪个 goroutine 拥有这把锁。理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件，并且Mutex 重复Lock会导致死锁。</p>
<h2 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="#如何实现可重入锁？"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-5.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">#</a>如何实现可重入锁？</h2><p>实现一个可重入锁需要这两点：</p>
<ul>
<li>记住持有锁的线程</li>
<li>统计重入的次数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReentrantLock <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    recursion <span class="type">int32</span> <span class="comment">// 这个goroutine 重入的次数</span></span><br><span class="line">    owner     <span class="type">int64</span> <span class="comment">// 当前持有锁的goroutine id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the id of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGoroutineID</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">64</span>]<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> s = buf[:runtime.Stack(buf[:], <span class="literal">false</span>)]</span><br><span class="line">    s = s[<span class="built_in">len</span>(<span class="string">&quot;goroutine &quot;</span>):]</span><br><span class="line">    s = s[:bytes.IndexByte(s, <span class="string">&#x27; &#x27;</span>)]</span><br><span class="line">    gid, _ := strconv.ParseInt(<span class="type">string</span>(s), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">return</span> gid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReentrantLock</span><span class="params">()</span></span> sync.Locker &#123;</span><br><span class="line">    res := &amp;ReentrantLock&#123;</span><br><span class="line">        Mutex:     sync.Mutex&#123;&#125;,</span><br><span class="line">        recursion: <span class="number">0</span>,</span><br><span class="line">        owner:     <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantMutex 包装一个Mutex,实现可重入</span></span><br><span class="line"><span class="keyword">type</span> ReentrantMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    owner     <span class="type">int64</span> <span class="comment">// 当前持有锁的goroutine id</span></span><br><span class="line">    recursion <span class="type">int32</span> <span class="comment">// 这个goroutine 重入的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ReentrantMutex)</span></span> Lock() &#123;</span><br><span class="line">    gid := GetGoroutineID()</span><br><span class="line">    <span class="comment">// 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;m.owner) == gid &#123;</span><br><span class="line">        m.recursion++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.Mutex.Lock()</span><br><span class="line">    <span class="comment">// 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1</span></span><br><span class="line">    atomic.StoreInt64(&amp;m.owner, gid)</span><br><span class="line">    m.recursion = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ReentrantMutex)</span></span> Unlock() &#123;</span><br><span class="line">    gid := GetGoroutineID()</span><br><span class="line">    <span class="comment">// 非持有锁的goroutine尝试释放锁，错误的使用</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(&amp;m.owner) != gid &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;wrong the owner(%d): %d!&quot;</span>, m.owner, gid))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用次数减1</span></span><br><span class="line">    m.recursion--</span><br><span class="line">    <span class="keyword">if</span> m.recursion != <span class="number">0</span> &#123; <span class="comment">// 如果这个goroutine还没有完全释放，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此goroutine最后一次调用，需要释放锁</span></span><br><span class="line">    atomic.StoreInt64(&amp;m.owner, <span class="number">-1</span>)</span><br><span class="line">    m.Mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mutex = &amp;ReentrantMutex&#123;&#125;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Println(<span class="number">111</span>)</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80</p>
<p>复制代码</p>
<h1 id="6-Go-原子操作有哪些？"><a href="#6-Go-原子操作有哪些？" class="headerlink" title="6.Go 原子操作有哪些？"></a>6.Go 原子操作有哪些？</h1><hr>
<p><em>caspar</em> <em>1130</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 原子操作有哪些？</summary><iframe src="https://player.bilibili.com/player.html?aid=255415704&amp;bvid=BV1vY41177Gt&amp;cid=569268208&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32&#x2F;int64&#x2F;uint32&#x2F;uint64&#x2F;uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）</p>
<h2 id="概念-3"><a href="#概念-3" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。</p>
<h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="#使用场景"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a>使用场景</h2><p>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync&#x2F;atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。</p>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="#常见操作"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">#</a>常见操作</h2><ul>
<li>增减Add</li>
<li>载入Load</li>
<li>比较并交换CompareAndSwap</li>
<li>交换Swap</li>
<li>存储Store</li>
</ul>
<p>atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</p>
<p>下面将分别介绍这些操作：</p>
<h3 id="增减操作"><a href="#增减操作" class="headerlink" title="#增减操作"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%A2%9E%E5%87%8F%E6%93%8D%E4%BD%9C">#</a><strong>增减操作</strong></h3><p>此类操作的前缀为 <code>Add</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>复制代码</p>
<p>需要注意的是，第一个参数必须是指针类型的值，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作。</p>
<p>使用举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(addr, delta) <span class="comment">//加操作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;add opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<h3 id="载入操作"><a href="#载入操作" class="headerlink" title="#载入操作"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E8%BD%BD%E5%85%A5%E6%93%8D%E4%BD%9C">#</a><strong>载入操作</strong></h3><p>此类操作的前缀为 <code>Load</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊类型： Value类型，常用于配置变更</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>&#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>复制代码</p>
<p>载入操作能够保证原子的读变量的值，当读取的时候，任何其他CPU操作都无法对该变量进行读写，其实现机制受到底层硬件的支持。</p>
<p>使用示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(addr *<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;load opts: &quot;</span>, atomic.LoadInt64(&amp;opts))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>复制代码</p>
<h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="#比较并交换"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">#</a><strong>比较并交换</strong></h3><p>此类操作的前缀为 <code>CompareAndSwap</code>, 该操作简称 CAS，可以用来实现乐观锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p>该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数 <code>old</code> 所记录的值，满足此前提下才进行交换操作。CAS的做法类似操作数据库时常见的乐观锁机制。</p>
<p>需要注意的是，当有大量的goroutine 对变量进行读写操作时，可能导致CAS操作无法成功，这时可以利用for循环多次尝试。</p>
<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareAndSwap</span><span class="params">(addr *<span class="type">int64</span>, oldValue <span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt64(addr, oldValue, newValue) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;cas opts: &quot;</span>, *addr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="#交换"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E4%BA%A4%E6%8D%A2">#</a><strong>交换</strong></h3><p>此类操作的前缀为 <code>Swap</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p>相对于CAS，明显此类操作更为暴力直接，并不管变量的旧值是否被改变，直接赋予新值然后返回背替换的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.SwapInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="#存储"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/5-6.html#%E5%AD%98%E5%82%A8">#</a><strong>存储</strong></h3><p>此类操作的前缀为 <code>Store</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊类型： Value类型，常用于配置变更</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>复制代码</p>
<p>此类操作确保了写变量的原子性，避免其他操作读到了修改变量过程中的脏数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.StoreInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;store opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>复制代码</p>
<h1 id="7-Go-原子操作和锁的区别？"><a href="#7-Go-原子操作和锁的区别？" class="headerlink" title="7.Go 原子操作和锁的区别？"></a>7.Go 原子操作和锁的区别？</h1><hr>
<p><em>caspar</em> <em>992</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 原子操作和锁的区别？</summary><iframe src="https://player.bilibili.com/player.html?aid=552890781&amp;bvid=BV1vi4y1S7mw&amp;cid=569618863&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<ul>
<li>原子操作由底层硬件支持，而锁是基于原子操作+信号量完成的。若实现相同的功能，前者通常会更有效率</li>
<li>原子操作是单个指令的互斥操作；互斥锁&#x2F;读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围</li>
<li>原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁</li>
<li>原子操作存在于各个指令&#x2F;语言层级，比如“机器指令层级的原子操作”，“汇编指令层级的原子操作”，“Go语言层级的原子操作”等。</li>
<li>锁也存在于各个指令&#x2F;语言层级中，比如“机器指令层级的锁”，“汇编指令层级的锁”，“Go语言层级的锁”等</li>
</ul>
<h1 id="第六章：Goroutine"><a href="#第六章：Goroutine" class="headerlink" title="第六章：Goroutine"></a>第六章：Goroutine</h1><h2 id="1-协程顺序打印问题"><a href="#1-协程顺序打印问题" class="headerlink" title="1. 协程顺序打印问题"></a>1. 协程顺序打印问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1EF411h7Xq?p=15&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

<h1 id="1-Go-goroutine的底层实现原理？"><a href="#1-Go-goroutine的底层实现原理？" class="headerlink" title="1.Go goroutine的底层实现原理？"></a>1.Go goroutine的底层实现原理？</h1><hr>
<p><em>caspar</em> <em>2338</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go goroutine的底层实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=853088635&amp;bvid=BV1aL4y157zr&amp;cid=570711120&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h3 id="概念-4"><a href="#概念-4" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E6%A6%82%E5%BF%B5">#</a>概念</h3><p>Goroutine可以理解为一种Go语言的协程（轻量级线程），是Go支持高并发的基础，属于用户态的线程，由Go runtime管理而不是操作系统。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="#底层数据结构"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    goid    <span class="type">int64</span> <span class="comment">// 唯一的goroutine的ID</span></span><br><span class="line">    sched gobuf <span class="comment">// goroutine切换时，用于保存g的上下文</span></span><br><span class="line">    stack stack <span class="comment">// 栈</span></span><br><span class="line">  gopc        <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">    startpc    <span class="type">uintptr</span> <span class="comment">// pc of goroutine function</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span> <span class="comment">// 栈指针位置</span></span><br><span class="line">    pc   <span class="type">uintptr</span> <span class="comment">// 运行到的程序位置</span></span><br><span class="line">    g    guintptr <span class="comment">// 指向 goroutine</span></span><br><span class="line">    ret  <span class="type">uintptr</span>  <span class="comment">// 保存系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="type">uintptr</span> <span class="comment">// 栈的下界内存地址</span></span><br><span class="line">    hi <span class="type">uintptr</span> <span class="comment">// 栈的上界内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<p>复制代码</p>
<p>最终有一个 runtime.g 对象放入调度队列</p>
<h3 id="状态流转"><a href="#状态流转" class="headerlink" title="#状态流转"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC">#</a>状态流转</h3><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>空闲中_Gidle</td>
<td>G刚刚新建, 仍未初始化</td>
</tr>
<tr>
<td>待运行_Grunnable</td>
<td>就绪状态，G在运行队列中, 等待M取出并运行</td>
</tr>
<tr>
<td>运行中_Grunning</td>
<td>M正在运行这个G, 这时候M会拥有一个P</td>
</tr>
<tr>
<td>系统调用中_Gsyscall</td>
<td>M正在运行这个G发起的系统调用, 这时候M并不拥有P</td>
</tr>
<tr>
<td>等待中_Gwaiting</td>
<td>G在等待某些条件完成, 这时候G不在运行也不在运行队列中(可能在channel的等待队列中)</td>
</tr>
<tr>
<td>已中止_Gdead</td>
<td>G未被使用, 可能已执行完毕</td>
</tr>
<tr>
<td>栈复制中_Gcopystack</td>
<td>G正在获取一个新的栈空间并把原来的内容复制过去(用于防止GC扫描)</td>
</tr>
</tbody></table>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/5.2.goroutine_state.jpg" alt="img"></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="#创建"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%88%9B%E5%BB%BA">#</a>创建</h3><p>通过<code>go</code>关键字调用底层函数<code>runtime.newproc()</code>创建一个<code>goroutine</code></p>
<p>当调用该函数之后，goroutine会被设置成<code>runnable</code>状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;func routine&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Println(<span class="string">&quot;main goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p>创建好的这个goroutine会新建一个自己的栈空间，同时在G的sched中维护栈地址与程序计数器这些信息。</p>
<p>每个 G 在被创建之后，都会被优先放入到本地队列中，如果本地队列已经满了，就会被放入到全局队列中。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="#运行"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E8%BF%90%E8%A1%8C">#</a>运行</h3><p>goroutine 本身只是一个数据结构，真正让 goroutine 运行起来的是<strong>调度器</strong>。Go 实现了一个用户态的调度器（GMP模型），这个调度器充分利用现代计算机的多核特性，同时让多个 goroutine 运行，同时 goroutine 设计的很轻量级，调度和上下文切换的代价都比较小。</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220406201146142.png" alt="img"></p>
<p><strong>调度时机：</strong></p>
<ul>
<li>新起一个协程和协程执行完毕</li>
<li>会阻塞的系统调用，比如文件io、网络io</li>
<li>channel、mutex等阻塞操作</li>
<li>time.sleep</li>
<li>垃圾回收之后</li>
<li>主动调用runtime.Gosched()</li>
<li>运行过久或系统调用过久等等</li>
</ul>
<p>每个 M 开始执行 P 的本地队列中的 G时，goroutine会被设置成<code>running</code>状态</p>
<p>如果某个 M 把本地队列中的G都执行完成之后，然后就会去全局队列中拿 G，这里需要注意，每次去全局队列拿 G 的时候，都需要上锁，避免同样的任务被多次拿。</p>
<p>如果全局队列都被拿完了，而当前 M 也没有更多的 G 可以执行的时候，它就会去其他 P 的本地队列中拿任务，这个机制被称之为 work stealing 机制，每次会拿走一半的任务，向下取整，比如另一个 P 中有 3 个任务，那一半就是一个任务。</p>
<p>当全局队列为空，M 也没办法从其他的 P 中拿任务的时候，就会让自身进入自选状态，等待有新的 G 进来。最多只会有 GOMAXPROCS 个 M 在自旋状态，过多 M 的自旋会浪费 CPU 资源。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="#阻塞"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E9%98%BB%E5%A1%9E">#</a>阻塞</h3><p>channel的读写操作、等待锁、等待网络数据、系统调用等都有可能发生阻塞，会调用底层函数<code>runtime.gopark()</code>，会让出CPU时间片，让调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
<p>当调用该函数之后，goroutine会被设置成<code>waiting</code>状态</p>
<h3 id="唤醒"><a href="#唤醒" class="headerlink" title="#唤醒"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E5%94%A4%E9%86%92">#</a>唤醒</h3><p>处于waiting状态的goroutine，在调用<code>runtime.goready()</code>函数之后会被唤醒，唤醒的goroutine会被重新放到M对应的上下文P对应的runqueue中，等待被调度。</p>
<p>当调用该函数之后，goroutine会被设置成<code>runnable</code>状态</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="#退出"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-1.html#%E9%80%80%E5%87%BA">#</a>退出</h3><p>当goroutine执行完成后，会调用底层函数<code>runtime.Goexit()</code></p>
<p>当调用该函数之后，goroutine会被设置成<code>dead</code>状态</p>
<h1 id="2-Go-goroutine和线程的区别"><a href="#2-Go-goroutine和线程的区别" class="headerlink" title="2.Go goroutine和线程的区别?"></a>2.Go goroutine和线程的区别?</h1><hr>
<p><em>caspar</em> <em>1393</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go goroutine和线程的区别?</summary><iframe src="https://player.bilibili.com/player.html?aid=768052346&amp;bvid=BV1Kr4y1W72a&amp;cid=571804872&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<table>
<thead>
<tr>
<th align="center"></th>
<th>goroutine</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存占用</td>
<td>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容</td>
<td>创建一个 线程 的栈内存消耗为 1 MB</td>
</tr>
<tr>
<td align="center">创建和销毀</td>
<td>goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</td>
<td>线程 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池</td>
</tr>
<tr>
<td align="center">切换</td>
<td>goroutines 切换只需保存三个寄存器：PC、SP、BP goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。</td>
<td>当线程切换时，需要保存各种寄存器，以便恢复现场。 线程切换会消耗 1000-1500 ns，相当于 12000-18000 条指令。</td>
</tr>
</tbody></table>
<h1 id="3-Go-goroutine泄露的场景"><a href="#3-Go-goroutine泄露的场景" class="headerlink" title="3.Go goroutine泄露的场景?"></a>3.Go goroutine泄露的场景?</h1><hr>
<p><em>caspar</em> <em>1383</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go goroutine泄露的场景?</summary><iframe src="https://player.bilibili.com/player.html?aid=340504079&amp;bvid=BV1k94y1Z7nr&amp;cid=572581713&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="泄露原因"><a href="#泄露原因" class="headerlink" title="#泄露原因"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0">#</a>泄露原因</h2><ul>
<li>Goroutine 内进行channel&#x2F;mutex 等读写操作被一直阻塞。</li>
<li>Goroutine 内的业务逻辑进入死循环，资源一直无法释放。</li>
<li>Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待</li>
</ul>
<h2 id="泄露场景"><a href="#泄露场景" class="headerlink" title="#泄露场景"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E6%B3%84%E9%9C%B2%E5%9C%BA%E6%99%AF">#</a>泄露场景</h2><p>如果输出的 goroutines 数量是在不断增加的，就说明存在泄漏</p>
<p><strong>nil channel</strong></p>
<p>channel 如果忘记初始化，那么无论你是读，还是写操作，都会造成阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    block1()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after goroutines: &quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            &lt;-ch</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>复制代码</p>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before goroutines:  1</span><br><span class="line">after goroutines:  11</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<p><strong>发送不接收</strong></p>
<p>channel 发送数量 超过 channel接收数量，就会造成阻塞</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p><strong>接收不发送</strong></p>
<p>channel 接收数量 超过 channel发送数量，也会造成阻塞</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            &lt;-ch</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p><strong>http request body未关闭</strong></p>
<p><code>resp.Body.Close()</code> 未被调用时，goroutine不会退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithNoClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, err := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred while fetching page, error: %s&quot;</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred while fetching page, error: %s&quot;</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                requestWithNoClose()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    block4()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p>
<p>复制代码</p>
<p>一般发起http请求时，需要确保关闭body</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p><strong>互斥锁忘记解锁</strong></p>
<p>第一个协程获取 <code>sync.Mutex</code> 加锁了，但是他可能在处理业务逻辑，又或是忘记 <code>Unlock</code> 了。</p>
<p>因此导致后面的协程想加锁，却因锁未释放被阻塞了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p><strong>sync.WaitGroup使用不当</strong></p>
<p>由于 <code>wg.Add</code> 的数量与 <code>wg.Done</code> 数量并不匹配，因此在调用 <code>wg.Wait</code> 方法后一直阻塞等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block6</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">2</span>)</span><br><span class="line">            wg.Done()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<h2 id="如何排查"><a href="#如何排查" class="headerlink" title="#如何排查"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-3.html#%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5">#</a>如何排查</h2><p>单个函数：调用 <code>runtime.NumGoroutine</code> 方法来打印 执行代码前后Goroutine 的运行数量，进行前后比较，就能知道有没有泄露了。</p>
<p>生产&#x2F;测试环境：使用<code>PProf</code>实时监测Goroutine的数量</p>
<h1 id="4-Go-如何查看正在执行的goroutine数量"><a href="#4-Go-如何查看正在执行的goroutine数量" class="headerlink" title="4.Go 如何查看正在执行的goroutine数量?"></a>4.Go 如何查看正在执行的goroutine数量?</h1><hr>
<p><em>caspar</em> <em>1234</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 如何查看正在执行的goroutine数量?</summary><iframe src="https://player.bilibili.com/player.html?aid=810595015&amp;bvid=BV1M34y1v7zF&amp;cid=573196220&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="程序中引入pprof-pakage"><a href="#程序中引入pprof-pakage" class="headerlink" title="#程序中引入pprof pakage"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-4.html#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%BC%95%E5%85%A5pprof-pakage">#</a>程序中引入pprof pakage</h2><p>在程序中引入pprof package：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>程序中开启HTTP监听服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</p>
<p>复制代码</p>
<h2 id="分析goroutine文件"><a href="#分析goroutine文件" class="headerlink" title="#分析goroutine文件"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-4.html#%E5%88%86%E6%9E%90goroutine%E6%96%87%E4%BB%B6">#</a>分析goroutine文件</h2><p>在命令行下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=:1248 http://127.0.0.1:6060/debug/pprof/goroutine</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>会自动打开浏览器页面如下图所示</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/pprof.png" alt="img"></p>
<p>在图中可以清晰的看到goroutine的数量以及调用关系，可以看到有103个goroutine</p>
<h1 id="5-Go-如何控制并发的goroutine数量"><a href="#5-Go-如何控制并发的goroutine数量" class="headerlink" title="5.Go 如何控制并发的goroutine数量?"></a>5.Go 如何控制并发的goroutine数量?</h1><hr>
<p><em>caspar</em> <em>1217</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 如何控制并发的goroutine数量?</summary><iframe src="https://player.bilibili.com/player.html?aid=640694479&amp;bvid=BV1aY4y1h78p&amp;cid=574632056&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h3 id="为什么要控制goroutine并发的数量？"><a href="#为什么要控制goroutine并发的数量？" class="headerlink" title="#为什么要控制goroutine并发的数量？"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-5.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%A7%E5%88%B6goroutine%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B0%E9%87%8F">#</a><strong>为什么要控制goroutine并发的数量？</strong></h3><p>在开发过程中，如果不对goroutine加以控制而进行滥用的话，可能会导致服务整体崩溃。比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。</p>
<h3 id="用什么方法控制goroutine并发的数量？"><a href="#用什么方法控制goroutine并发的数量？" class="headerlink" title="#用什么方法控制goroutine并发的数量？"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/6-5.html#%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%8E%A7%E5%88%B6goroutine%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B0%E9%87%8F">#</a><strong>用什么方法控制goroutine并发的数量？</strong></h3><p><strong>有缓冲channel</strong></p>
<p>利用缓冲满时发送阻塞的特性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 模拟用户请求数量</span></span><br><span class="line">    requestCount := <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;goroutine_num&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    <span class="comment">// 管道长度即最大并发数</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; requestCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="literal">true</span></span><br><span class="line">        <span class="keyword">go</span> Read(ch, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine_num: %d, go func: %d\n&quot;</span>, runtime.NumGoroutine(), i)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30</p>
<p>复制代码</p>
<p>输出结果：默认最多不超过3（4-1）个goroutine并发执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">goroutine_num 1</span><br><span class="line">goroutine_num: 4, go func: 1</span><br><span class="line">goroutine_num: 4, go func: 3</span><br><span class="line">goroutine_num: 4, go func: 2</span><br><span class="line">goroutine_num: 4, go func: 0</span><br><span class="line">goroutine_num: 4, go func: 4</span><br><span class="line">goroutine_num: 4, go func: 5</span><br><span class="line">goroutine_num: 4, go func: 6</span><br><span class="line">goroutine_num: 4, go func: 8</span><br><span class="line">goroutine_num: 4, go func: 9</span><br><span class="line">goroutine_num: 4, go func: 7</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p><strong>无缓冲channel</strong></p>
<p>任务发送和执行分离，指定消费者并发协程数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 模拟用户请求数量</span></span><br><span class="line">    requestCount := <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;goroutine_num&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> Read(ch, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; requestCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _ = <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;goroutine_num: %d, go func: %d\n&quot;</span>, runtime.NumGoroutine(), i)</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33</p>
<p>复制代码</p>
<h1 id="第七章：调度模型"><a href="#第七章：调度模型" class="headerlink" title="第七章：调度模型"></a>第七章：调度模型</h1><h1 id="1-Go-线程实现模型？"><a href="#1-Go-线程实现模型？" class="headerlink" title="1.Go 线程实现模型？"></a>1.Go 线程实现模型？</h1><hr>
<p><em>caspar</em> <em>2220</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 线程实现模型？</summary><iframe src="https://player.bilibili.com/player.html?aid=638430133&amp;bvid=BV1HY4y1Y7rg&amp;cid=583054009&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go实现的是两级线程模型（M：N)，准确的说是GMP模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="#背景"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-1.html#%E8%83%8C%E6%99%AF">#</a>背景</h2><table>
<thead>
<tr>
<th></th>
<th>含义</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>单进程时代</td>
<td>每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程</td>
<td>1. 无法并发，只能串行 2. 进程阻塞所带来的 CPU 时间浪费</td>
</tr>
<tr>
<td>多进程&#x2F;线程时代</td>
<td>一个线程阻塞， cpu 可以立刻切换到其他线程中去执行</td>
<td>1. 进程&#x2F;线程占用内存高 2. 进程&#x2F;线程上下文切换成本高</td>
</tr>
<tr>
<td>协程时代</td>
<td>协程（用户态线程）绑定线程（内核态线程），cpu调度线程执行</td>
<td>1. 实现起来较复杂，协程和线程的绑定依赖调度器算法</td>
</tr>
</tbody></table>
<p>线程 -&gt; CPU 由 操作系统 调度，协程 -&gt; 线程 由Go调度器来调度，协程与线程的映射关系有三种线程模型</p>
<h2 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="#三种线程模型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-1.html#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">#</a>三种线程模型</h2><p>线程实现模型主要分为：<code>内核级线程模型</code>、<code>用户级线程模型</code>、<code>两级线程模型</code>，他们的区别在于用户线程与内核线程之间的对应关系。</p>
<p><strong>内核级线程模型（1：1）</strong></p>
<p>1个用户线程对应1个内核线程，这种最容易实现，协程的调度都由 CPU 完成了</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/ult_klt_1_1.jpg" alt="img"></p>
<p>优点：</p>
<ul>
<li>实现起来最简单</li>
<li>能够利用多核</li>
<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>
</ul>
<p>缺点：</p>
<ul>
<li>上下文切换成本高，创建、删除和切换都由 CPU 完成</li>
</ul>
<p><strong>用户级线程模型（N：1）</strong></p>
<p>1个进程中的所有线程对应1个内核线程</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/ult_klt_n_1.jpg" alt="img"></p>
<p>优点：</p>
<ul>
<li>上下文切换成本低，在用户态即可完成协程切换</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法利用多核</li>
<li>一旦协程阻塞，造成线程阻塞，本线程的其它协程无法执行</li>
</ul>
<p><strong>两级线程模型（M：N)</strong></p>
<p>M个线程对应N个内核线程</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/ult_klt_n_m.jpg" alt="img"></p>
<p>优点：</p>
<ul>
<li>能够利用多核</li>
<li>上下文切换成本低</li>
<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现起来最复杂</li>
</ul>
<h1 id="2-Go-GMP和GM模型？"><a href="#2-Go-GMP和GM模型？" class="headerlink" title="2.Go GMP和GM模型？"></a>2.Go GMP和GM模型？</h1><hr>
<p><em>caspar</em> <em>2542</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go GMP和GM模型？</summary><iframe src="https://player.bilibili.com/player.html?aid=553411002&amp;bvid=BV1Xi4y127Cx&amp;cid=583954200&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>什么才是一个好的调度器？</p>
<p>能在适当的时机将合适的协程分配到合适的位置，保证公平和效率。</p>
<p>Go采用了GMP模型（对两级线程模型的改进实现），使它能够更加灵活地进行线程之间的调度。</p>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="#GMP模型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-2.html#gmp%E6%A8%A1%E5%9E%8B">#</a>GMP模型</h2><p>GMP是Go运行时调度层面的实现，包含4个重要结构，分别是G、M、P、Sched</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419120403666.png" alt="img"></p>
<p><strong>G（Goroutine）</strong>：代表Go 协程Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等。<strong>G的数量无限制，理论上只受内存的影响</strong>，创建一个 G 的初始栈大小为2-4K，配置一般的机器也能简简单单开启数十万个 Goroutine ，而且Go语言在 G 退出的时候还会把 G 清理之后放到 P 本地或者全局的闲置列表 gFree 中以便复用。</p>
<p><strong>M（Machine）</strong>： Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程，想要在 CPU 上执行代码必须有线程，通过系统调用 clone 创建。M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。<strong>M的数量有限制，默认数量限制是 10000</strong>，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。</p>
<p><strong>P（Processor）：虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来。P 的数量决定了系统内最大可并行的 G 的数量，</strong>P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。</p>
<p><strong>Sched：调度器结构</strong>，它维护有存储M和G的全局队列，以及调度器的一些状态信息</p>
<table>
<thead>
<tr>
<th></th>
<th>G</th>
<th>M</th>
<th>P</th>
</tr>
</thead>
<tbody><tr>
<td>数量限制</td>
<td>无限制，受机器内存影响</td>
<td>有限制，默认最多10000</td>
<td>有限制，最多GOMAXPROCS个</td>
</tr>
<tr>
<td>创建时机</td>
<td>go func</td>
<td>当没有足够的M来关联P并运行其中的可运行的G时会请求创建新的M</td>
<td>在确定了P的最大数量n后，运行时系统会根据这个数量创建个P</td>
</tr>
</tbody></table>
<p><strong>核心数据结构:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    goid    <span class="type">int64</span> <span class="comment">// 唯一的goroutine的ID</span></span><br><span class="line">    sched gobuf <span class="comment">// goroutine切换时，用于保存g的上下文</span></span><br><span class="line">    stack stack <span class="comment">// 栈</span></span><br><span class="line">  gopc        <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">    startpc    <span class="type">uintptr</span> <span class="comment">// pc of goroutine function</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line">    id          <span class="type">int32</span></span><br><span class="line">    status      <span class="type">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">    runqhead <span class="type">uint32</span> <span class="comment">// 本地队列队头</span></span><br><span class="line">    runqtail <span class="type">uint32</span> <span class="comment">// 本地队列队尾</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr <span class="comment">// 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高</span></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0            *g     </span><br><span class="line">    <span class="comment">// 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度</span></span><br><span class="line">    curg          *g    </span><br><span class="line">    <span class="comment">// 当前正在执行的G</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    runq     gQueue <span class="comment">// 全局队列，链表（长度无限制）</span></span><br><span class="line">    runqsize <span class="type">int32</span>  <span class="comment">// 全局队列长度</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37</p>
<p>复制代码</p>
<p>GMP模型的实现算是Go调度器的一大进步，但调度器仍然有一个令人头疼的问题，那就是不支持抢占式调度，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现“饿死”的情况。</p>
<p>当只有一个 P（GOMAXPROCS&#x3D;1）时，整个 Go 程序中的其他 G 都将“饿死”。于是在 Go 1.2 版本中实现了基于协作的“抢占式”调度，在Go 1.14 版本中实现了基于信号的“抢占式”调度。</p>
<h2 id="GM模型"><a href="#GM模型" class="headerlink" title="#GM模型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-2.html#gm%E6%A8%A1%E5%9E%8B">#</a>GM模型</h2><p>Go早期是GM模型，没有P组件</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220412194120600.png" alt="img"></p>
<p>**GM调度存在的问题： **</p>
<ol>
<li><strong>全局队列的锁竞争</strong>，当 M 从全局队列中添加或者获取 G 的时候，都需要获取队列锁，导致激烈的锁竞争</li>
<li><strong>M 转移 G 增加额外开销</strong>，当 M1 在执行 G1 的时候， M1 创建了 G2，为了继续执行 G1，需要把 G2 保存到全局队列中，无法保证G2是被M1处理。因为 M1 原本就保存了 G2 的信息，所以 G2 最好是在 M1 上执行，这样的话也不需要转移G到全局队列和线程上下文切换</li>
<li><strong>线程使用效率不能最大化</strong>，没有<strong>work-stealing</strong> 和<strong>hand-off</strong> 机制</li>
</ol>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，为了解决这一的问题 go 从 1.1 版本引入P，在运行时系统的时候加入 P 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理 的 G</p>
<h1 id="3-Go-调度原理？"><a href="#3-Go-调度原理？" class="headerlink" title="3.Go 调度原理？"></a>3.Go 调度原理？</h1><hr>
<p><em>caspar</em> <em>2048</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 调度原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=896063378&amp;bvid=BV1LA4y1D7yo&amp;cid=584907309&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>goroutine调度的本质就是将 <strong>Goroutine (G）</strong>按照一定算法放到CPU上去执行。</p>
<p>CPU感知不到Goroutine，只知道内核线程，所以需要<strong>Go调度器</strong>将协程调度到内核线程上面去，然后<strong>操作系统调度器</strong>将内核线程放到CPU上去执行</p>
<p>M是对内核级线程的封装，<strong>所以Go调度器的工作就是将G分配到M</strong></p>
<p>Go 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的 GM 模型、到 GMP模型，从<strong>不支持抢占</strong>，到<strong>支持协作式抢占</strong>，再到<strong>支持基于信号的异步抢占</strong>，经历了不断地优化与打磨。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="#设计思想"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">#</a>设计思想</h2><ul>
<li>线程复用（<strong>work stealing 机制</strong>和<strong>hand off 机制</strong>）</li>
<li>利用并行（利用多核CPU）</li>
<li>抢占调度（解决公平性问题）</li>
</ul>
<h2 id="调度对象"><a href="#调度对象" class="headerlink" title="#调度对象"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E5%AF%B9%E8%B1%A1">#</a>调度对象</h2><p>Go 调度器</p>
<blockquote>
<p>Go 调度器是属于Go runtime中的一部分，Go runtime负责实现Go的<strong>并发调度</strong>、<strong>垃圾回收</strong>、<strong>内存堆栈管理</strong>等关键功能</p>
</blockquote>
<h2 id="被调度对象"><a href="#被调度对象" class="headerlink" title="#被调度对象"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%A2%AB%E8%B0%83%E5%BA%A6%E5%AF%B9%E8%B1%A1">#</a>被调度对象</h2><p>G的来源</p>
<ul>
<li>P的runnext（只有1个G，局部性原理，永远会被最先调度执行）</li>
<li>P的本地队列（数组，最多256个G）</li>
<li>全局G队列（链表，无限制）</li>
<li>网络轮询器<em>network poller</em>（存放网络调用被阻塞的G）</li>
</ul>
<p>P的来源</p>
<ul>
<li>全局P队列（数组，GOMAXPROCS个P）</li>
</ul>
<p>M的来源</p>
<ul>
<li>休眠线程队列（未绑定P，长时间休眠会等待GC回收销毁）</li>
<li>运行线程（绑定P，指向P中的G）</li>
<li>自旋线程（绑定P，指向M的G0）</li>
</ul>
<p>其中运行线程数 + 自旋线程数 &lt;&#x3D; P的数量（GOMAXPROCS），M个数 &gt;&#x3D; P个数</p>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="#调度流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">#</a>调度流程</h2><p>协程的调度采用了生产者-消费者模型，实现了用户任务与调度器的解耦</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419200002580.png" alt="img"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/ddyl519.jpg" alt="img"></p>
<p>生产端我们开启的每个协程都是一个计算任务，这些任务会被提交给 go 的 runtime。如果计算任务非常多，有成千上万个，那么这些任务是不可能同时被立刻执行的，所以这个计算任务一定会被先暂存起来，一般的做法是放到内存的队列中等待被执行。</p>
<p>G的生命周期：G 从创建、保存、被获取、调度和执行、阻塞、销毁，步骤如下：</p>
<p><strong>步骤 1：创建 G</strong>，关键字 <code>go func()</code> 创建 G <strong>步骤 2：保存 G</strong>，创建的 G 优先保存到本地队列 P，如果 P 满了，则会平衡部分P到全局队列中</p>
<p><strong>步骤3</strong>：<strong>唤醒或者新建M</strong>执行任务，进入调度循环（步骤4,5,6)</p>
<p><strong>步骤 4：M 获取 G</strong>，M首先从P的本地队列获取 G，如果 P为空，则从全局队列获取 G，如果全局队列也为空，则从另一个本地队列偷取一半数量的 G（负载均衡），这种从其它P偷的方式称之为 work stealing</p>
<p><strong>步骤 5：M 调度和执行 G</strong>，M调用 <code>G.func()</code> 函数执行 G</p>
<ul>
<li>如果 M在执行 G 的过程发生<strong>系统调用阻塞</strong>（同步），会阻塞G和M（操作系统限制），此时P会和当前M解绑，并寻找新的M，如果没有空闲的M就会新建一个M ，接管正在阻塞G所属的P，接着继续执行 P中其余的G，这种阻塞后释放P的方式称之为hand off。当<strong>系统调用结束</strong>后，这个G会尝试获取一个空闲的P执行，优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入到全局队列中。</li>
<li>如果M在执行G的过程发生网络IO等操作阻塞时（异步），阻塞G，<strong>不会阻塞M</strong>。M会寻找P中其它可执行的G继续执行，G会被网络轮询器network poller 接手，当阻塞的G恢复后，G1从network poller 被移回到P的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I&#x2F;O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</li>
</ul>
<p><strong>步骤6：M执行完G后清理现场</strong>，重新进入调度循环（将M上运⾏的goroutine切换为G0，G0负责调度时协程的切换）</p>
<p>其中步骤2中保存 G的详细流程如下：</p>
<ul>
<li>执行 go func 的时候，主线程 M0 会调用 newproc()生成一个 G 结构体，这里会先选定当前 M0 上的 P 结构</li>
<li>每个协程 G 都会被尝试先放到 P 中的 runnext，若 runnext 为空则放到 runnext 中，生产结束</li>
<li>若 runnext 满，则将原来 runnext 中的 G 踢到本地队列中，将当前 G 放到 runnext 中，生产结束</li>
<li>若本地队列也满了，则将本地队列中的 G 拿出一半，放到全局队列中，生产结束。</li>
</ul>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/33653a35dca9472fd1e487d3a94557c6.png" alt="img"></p>
<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="#调度时机"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">#</a>调度时机</h2><p><strong>什么时候进行调度（执行&#x2F;切换）？</strong></p>
<p>在以下情形下，会切换正在执行的goroutine</p>
<ul>
<li>抢占式调度<ul>
<li>sysmon 检测到协程运行过久（比如sleep，死循环）<ul>
<li>切换到g0，进入调度循环</li>
</ul>
</li>
</ul>
</li>
<li>主动调度<ul>
<li>新起一个协程和协程执行完毕<ul>
<li>触发调度循环</li>
</ul>
</li>
<li>主动调用runtime.Gosched()<ul>
<li>切换到g0，进入调度循环</li>
</ul>
</li>
<li>垃圾回收之后<ul>
<li>stw之后，会重新选择g开始执行</li>
</ul>
</li>
</ul>
</li>
<li>被动调度<ul>
<li>系统调用（比如文件IO）阻塞（同步）<ul>
<li>阻塞G和M，P与M分离，将P交给其它M绑定，其它M执行P的剩余G</li>
</ul>
</li>
<li>网络IO调用阻塞（异步）<ul>
<li>阻塞G，G移动到NetPoller，M执行P的剩余G</li>
</ul>
</li>
<li>atomic&#x2F;mutex&#x2F;channel等阻塞（异步）<ul>
<li>阻塞G，G移动到channel的等待队列中，M执行P的剩余G</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="#调度策略"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-3.html#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5">#</a>调度策略</h2><p><strong>使用什么策略来挑选下一个goroutine执行？</strong></p>
<p>由于 P 中的 G 分布在 runnext、本地队列、全局队列、网络轮询器中，则需要挨个判断是否有可执行的 G，大体逻辑如下：</p>
<ul>
<li>每执行61次调度循环，从全局队列获取G，若有则直接返回</li>
<li>从P 上的 runnext 看一下是否有 G，若有则直接返回</li>
<li>从P 上的 本地队列 看一下是否有 G，若有则直接返回</li>
<li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他 P 中窃取，<strong>一直阻塞</strong>直到获取到一个可用的 G 为止</li>
</ul>
<p>源码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 每执行61次调度循环会看一下全局队列。为了保证公平，避免全局队列一直无法得到执行的情况，当全局运行队列中有待执行的G时，通过schedtick保证有一定几率会从全局的运行队列中查找对应的Goroutine；</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 先尝试从P的runnext和本地队列查找G</span></span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 仍找不到，去全局队列中查找。还找不到，要去网络轮询器中查找是否有G等待运行；仍找不到，则尝试从其他P中窃取G来执行。</span></span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">        <span class="comment">// 这个函数是阻塞的，执行到这里一定会获取到一个可执行的G</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用execute，继续调度循环</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26</p>
<p>复制代码</p>
<p>从全局队列查找时，如果要所有 P 平分全局队列中的 G，每个 P 要分得多少个，这里假设会分得 n 个。然后把这 n 个 G，转移到当前 G 所在 P 的本地队列中去。但是最多不能超过 P 本地队列长度的一半（即 128）。这样做的目的是，如果下次调度循环到来的时候，就不必去加锁到全局队列中在获取一次 G 了，性能得到了很好的保障。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(_p_ *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// gomaxprocs = p的数量</span></span><br><span class="line">   <span class="comment">// sched.runqsize是全局队列长度</span></span><br><span class="line">   <span class="comment">// 这里n = 全局队列的G平分到每个P本地队列上的数量 + 1</span></span><br><span class="line">   n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">      n = sched.runqsize</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">      n = max</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 平分后的数量n不能超过本地队列长度的一半，也就是128</span></span><br><span class="line">   <span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq))/<span class="number">2</span> &#123;</span><br><span class="line">      n = <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq)) / <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行将G从全局队列中取n个分到当前P本地队列的操作</span></span><br><span class="line">   sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">   gp := sched.runq.pop()</span><br><span class="line">   n--</span><br><span class="line">   <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">      gp1 := sched.runq.pop()</span><br><span class="line">      runqput(_p_, gp1, <span class="literal">false</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28</p>
<p>复制代码</p>
<p>从其它P查找时，会偷一半的G过来放到当前P的本地队列</p>
<h1 id="4-Go-work-stealing-机制？"><a href="#4-Go-work-stealing-机制？" class="headerlink" title="4.Go work stealing 机制？"></a>4.Go work stealing 机制？</h1><hr>
<p><em>caspar</em> <em>1352</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go work stealing 机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=641003955&amp;bvid=BV17Y4y187uE&amp;cid=585705371&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-5"><a href="#概念-5" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>当线程M⽆可运⾏的G时，尝试从其他M绑定的P偷取G，减少空转，提高了线程利用率（避免闲着不干活）。</p>
<p>当从本线程绑定 P 本地 队列、全局G队列、netpoller都找不到可执行的 g，会从别的 P 里窃取G并放到当前P上面。</p>
<p>从<em>netpoller</em> 中拿到的G是_Gwaiting状态（ 存放的是因为网络IO被阻塞的G），从其它地方拿到的G是_Grunnable状态</p>
<p>从全局队列取的G数量：N &#x3D; min(len(GRQ)&#x2F;GOMAXPROCS + 1, len(GRQ&#x2F;2)) （根据GOMAXPROCS负载均衡）</p>
<p>从其它P本地队列<strong>窃取</strong>的G数量：N &#x3D; len(LRQ)&#x2F;2（平分）</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419153014030.png" alt="img"></p>
<h2 id="窃取流程"><a href="#窃取流程" class="headerlink" title="#窃取流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E7%AA%83%E5%8F%96%E6%B5%81%E7%A8%8B">#</a>窃取流程</h2><p>源码见runtime&#x2F;proc.go stealWork函数，窃取流程如下，如果经过多次努力一直找不到需要运行的goroutine则调用stopm进入睡眠状态，等待被其它工作线程唤醒。</p>
<ol>
<li>选择要窃取的P</li>
<li>从P中偷走一半G</li>
</ol>
<h3 id="选择要窃取的P"><a href="#选择要窃取的P" class="headerlink" title="#选择要窃取的P"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E9%80%89%E6%8B%A9%E8%A6%81%E7%AA%83%E5%8F%96%E7%9A%84p">#</a><strong>选择要窃取的P</strong></h3><p>窃取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列</p>
<p>为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p，而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">offset := <span class="type">uint32</span>(random()) % nprocs</span><br><span class="line">coprime := 随机选取一个小于nprocs且与nprocs互质的数</span><br><span class="line"><span class="keyword">const</span> stealTries = <span class="number">4</span> <span class="comment">// 最多重试4次</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nprocs; i++ &#123;</span><br><span class="line">      p := allp[offset]</span><br><span class="line">        从p的运行队列偷取goroutine</span><br><span class="line">        <span class="keyword">if</span> 偷取成功 &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">     &#125;</span><br><span class="line">        offset += coprime</span><br><span class="line">        offset = offset % nprocs</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>复制代码</p>
<p>可以看到只要随机数不一样，偷取p的顺序也不一样，但可以保证经过nprocs次循环，每个p都会被访问到。</p>
<h3 id="从P中偷走一半G"><a href="#从P中偷走一半G" class="headerlink" title="#从P中偷走一半G"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-4.html#%E4%BB%8Ep%E4%B8%AD%E5%81%B7%E8%B5%B0%E4%B8%80%E5%8D%8Ag">#</a><strong>从P中偷走一半G</strong></h3><p>源码见runtime&#x2F;proc.go runqsteal函数：</p>
<p>挑选出盗取的对象p之后，则调用runqsteal盗取p的运行队列中的goroutine，runqsteal函数再调用runqgrap从p的本地队列尾部批量偷走一半的g</p>
<p>为啥是偷一半的g，可以理解为负载均衡</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(_p_ *p, batch *[256]guintptr, batchHead <span class="type">uint32</span>, stealRunNextG <span class="type">bool</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">        t := atomic.LoadAcq(&amp;_p_.runqtail) <span class="comment">// load-acquire, synchronize with the producer</span></span><br><span class="line">        n := t - h        <span class="comment">//计算队列中有多少个goroutine</span></span><br><span class="line">        n = n - n/<span class="number">2</span>     <span class="comment">//取队列中goroutine个数的一半</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>复制代码</p>
<h1 id="5-Go-hand-off-机制？"><a href="#5-Go-hand-off-机制？" class="headerlink" title="5.Go hand off 机制？"></a>5.Go hand off 机制？</h1><hr>
<p><em>caspar</em> <em>1172</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go hand off 机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=511037431&amp;bvid=BV11u411k7M9&amp;cid=586406898&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-6"><a href="#概念-6" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-5.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>也称为P分离机制，当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率（避免站着茅坑不拉shi）。</p>
<h2 id="分离流程"><a href="#分离流程" class="headerlink" title="#分离流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-5.html#%E5%88%86%E7%A6%BB%E6%B5%81%E7%A8%8B">#</a>分离流程</h2><p>当前线程M阻塞时，释放P，给其它空闲的M处理</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220419152721948.png" alt="img"></p>
<h1 id="6-Go-抢占式调度？"><a href="#6-Go-抢占式调度？" class="headerlink" title="6.Go 抢占式调度？"></a>6.Go 抢占式调度？</h1><hr>
<p><em>caspar</em> <em>1352</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 抢占式调度？</summary><iframe src="https://player.bilibili.com/player.html?aid=298581997&amp;bvid=BV1iF411u7GC&amp;cid=587306773&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>在1.2版本之前，Go的调度器仍然不支持抢占式调度，程序只能依靠Goroutine主动让出CPU资源才能触发调度，这会引发一些问题，比如：</p>
<ul>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿</li>
<li>垃圾回收器是需要stop the world的，如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine停下来，这会造成较长时间的等待时间</li>
</ul>
<p>为解决这个问题：</p>
<ul>
<li>Go 1.2 中实现了基于协作的“抢占式”调度</li>
<li>Go 1.14 中实现了基于信号的“抢占式”调度</li>
</ul>
<h2 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="#基于协作的抢占式调度"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-6.html#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">#</a>基于协作的抢占式调度</h2><p>协作式：大家都按事先定义好的规则来，比如：一个goroutine执行完后，退出，让出p，然后下一个goroutine被调度到p上运行。这样做的缺点就在于 是否让出p的决定权在groutine自身。一旦某个g不主动让出p或执行时间较长，那么后面的goroutine只能等着，没有方法让前者让出p，导致延迟甚至饿死。</p>
<p>非协作式: 就是由runtime来决定一个goroutine运行多长时间，如果你不主动让出，对不起，我有手段可以抢占你，把你踢出去，让后面的goroutine进来运行。</p>
<p>基于协作的抢占式调度流程：</p>
<ul>
<li>编译器会在调用函数前插入 runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占调度</li>
<li>Go语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms，那么会在这个协程设置一个抢占标记</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack会检查抢占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里</li>
</ul>
<p>这种解决方案只能说局部解决了“饿死”问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。</p>
<p>比如，死循环等并没有给编译器插入抢占代码的机会，以下程序在 go 1.14 之前的 go版本中，运行后会一直卡住，而不会打印 <code>I got scheduled!</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;I got scheduled!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p>复制代码</p>
<p>为了解决这些问题，<strong>Go 在 1.14 版本中增加了对非协作的抢占式调度的支持</strong>，这种<strong>抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行的 Goroutine</strong></p>
<h2 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="#基于信号的抢占式调度"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-6.html#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">#</a>基于信号的抢占式调度</h2><p>真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。不管协程有没有意愿主动让出 cpu 运行权，只要某个协程执行时间过长，就会发送信号强行夺取 cpu 运行权。</p>
<ul>
<li>M 注册一个 SIGURG 信号的处理函数：sighandler</li>
<li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占P超过10ms，会给M发送抢占信号</li>
<li>M 收到信号后，内核执行 sighandler 函数把当前协程的状态从_Grunning正在执行改成 _Grunnable可执行，把抢占的协程放到全局队列里，M继续寻找其他 goroutine 来运行</li>
<li>被抢占的 G 再次调度过来执行时，会继续原来的执行流</li>
</ul>
<p>抢占分为<code>_Prunning</code>和<code>_Psyscall</code>，<code>_Psyscall</code>抢占通常是由于阻塞性系统调用引起的，比如磁盘io、cgo。<code>_Prunning</code>抢占通常是由于一些类似死循环的计算逻辑引起的。</p>
<h1 id="7-Go-如何查看运行时调度信息？"><a href="#7-Go-如何查看运行时调度信息？" class="headerlink" title="7.Go 如何查看运行时调度信息？"></a>7.Go 如何查看运行时调度信息？</h1><hr>
<p><em>caspar</em> <em>985</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 如何查看运行时调度信息？</summary><iframe src="https://player.bilibili.com/player.html?aid=426062407&amp;bvid=BV1H3411K7pG&amp;cid=588120648&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>有 2 种方式可以查看一个程序的调度GMP信息，分别是go tool trace和GODEBUG</p>
<p>trace.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p>
<p>复制代码</p>
<h2 id="go-tool-trace"><a href="#go-tool-trace" class="headerlink" title="#go tool trace"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-7.html#go-tool-trace">#</a>go tool trace</h2><p>启动可视化界面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run trace.go</span><br><span class="line">go tool trace trace.out</span><br><span class="line">2022/04/22 10:44:11 Parsing trace...</span><br><span class="line">2022/04/22 10:44:11 Splitting trace...</span><br><span class="line">2022/04/22 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:35488</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>
<p><strong>1.打开 <code>http://127.0.0.1:35488</code> 查看可视化界面：</strong></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422214355669.png" alt="img"></p>
<p>点击 <code>view trace</code> 能够看见可视化的调度流程：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422213604926.png" alt="img"></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422210738598.png" alt="img"></p>
<p>一共有2个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，另外一个是G1 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>2. 点击 Threads 那一行可视化的数据条，我们会看到M详细的信息</strong></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422211223494.png" alt="img"></p>
<p>一共有2个 M 在程序中，一个是特殊的 M0，用于初始化使用，另外一个是用于执行G1的M1</p>
<p><strong>3. 点击 Proc 那一行可视化的数据条，我们会看到P上正在运行goroutine详细的信息</strong></p>
<p>一共有3个 P 在程序中，分别是P0、P1、P2</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220422212719433.png" alt="img"></p>
<p>点击具体的 Goroutine 行为后可以看到其相关联的详细信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Start：开始时间</span><br><span class="line">Wall Duration：持续时间</span><br><span class="line">Self Time：执行时间</span><br><span class="line">Start Stack Trace：开始时的堆栈信息</span><br><span class="line">End Stack Trace：结束时的堆栈信息</span><br><span class="line">Incoming flow：输入流</span><br><span class="line">Outgoing flow：输出流</span><br><span class="line">Preceding events：之前的事件</span><br><span class="line">Following events：之后的事件</span><br><span class="line">All connected：所有连接的事件</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<h2 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="#GODEBUG"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/7-7.html#godebug">#</a>GODEBUG</h2><p>GODEBUG 变量可以控制运行时内的调试变量。查看调度器信息，将会使用如下两个参数：</p>
<ul>
<li>schedtrace：设置 <code>schedtrace=X</code> 参数可以使运行时在每 X 毫秒发出一行调度器的摘要信息到标准 err 输出中。</li>
<li>scheddetail：设置 <code>schedtrace=X</code> 和 <code>scheddetail=1</code> 可以使运行时在每 X 毫秒发出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程 和 Goroutine 的状态。</li>
</ul>
<p><strong>查看基本信息</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build trace.go</span><br><span class="line">GODEBUG=schedtrace=1000 ./trace</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1010ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3024ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4027ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 5029ms: gomaxprocs=8 idleprocs=7 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p>sched：每一行都代表调度器的调试信息，后面提示的毫秒数表示启动到现在的运行时间，输出的时间间隔受 <code>schedtrace</code> 的值影响。</p>
<p>gomaxprocs：当前的 CPU 核心数（GOMAXPROCS 的当前值）。</p>
<p>idleprocs：空闲的处理器数量，后面的数字表示当前的空闲数量。</p>
<p>threads：OS 线程数量，后面的数字表示当前正在运行的线程数量。</p>
<p>spinningthreads：自旋状态的 OS 线程数量。</p>
<p>idlethreads：空闲的线程数量。</p>
<p>runqueue：全局队列中中的 Goroutine 数量，而后面的[0 0 0 0 0 0 0 0] 则分别代表这 8 个 P 的本地队列正在运行的 Goroutine 数量。</p>
<p><strong>查看详细信息</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build trace.go</span><br><span class="line">GODEBUG=scheddetail=1,schedtrace=1000 ./trace</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0</span><br><span class="line">  P0: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=1 gfreecnt=0 timerslen=0</span><br><span class="line">  P1: status=1 schedtick=0 syscalltick=0 m=2 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0</span><br><span class="line">  M3: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M2: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=-1</span><br><span class="line">  M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=<span class="literal">false</span> blocked=<span class="literal">false</span> lockedg=1</span><br><span class="line">  G1: status=1(chan receive) m=-1 lockedm=0</span><br><span class="line">  G2: status=1() m=-1 lockedm=-1</span><br><span class="line">  G3: status=1() m=-1 lockedm=-1</span><br><span class="line">  G4: status=4(GC scavenge <span class="built_in">wait</span>) m=-1 lockedm=-1</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>复制代码</p>
<p>G</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status：G 的运行状态。</span><br><span class="line">m：隶属哪一个 M。</span><br><span class="line">lockedm：是否有锁定 M。</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>复制代码</p>
<p>G 的运行状态共涉及如下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_Gidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行初始化。</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>1</td>
<td>已经在运行队列中，还没有执行用户代码。</td>
</tr>
<tr>
<td>_Grunning</td>
<td>2</td>
<td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>正在执行系统调用，此时分配了 M。</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td>
</tr>
<tr>
<td>_Gmoribund_unused</td>
<td>5</td>
<td>尚未使用，但是在 gdb 中进行了硬编码。</td>
</tr>
<tr>
<td>_Gdead</td>
<td>6</td>
<td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td>
</tr>
<tr>
<td>_Genqueue_unused</td>
<td>7</td>
<td>尚未使用。</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>8</td>
<td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td>
</tr>
</tbody></table>
<p>M</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p：隶属哪一个 P。</span><br><span class="line">curg：当前正在使用哪个 G。</span><br><span class="line">runqsize：运行队列中的 G 数量。</span><br><span class="line">gfreecnt：可用的G（状态为 Gdead）。</span><br><span class="line">mallocing：是否正在分配内存。</span><br><span class="line">throwing：是否抛出异常。</span><br><span class="line">preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>复制代码</p>
<p>P</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status：P 的运行状态。</span><br><span class="line">schedtick：P 的调度次数。</span><br><span class="line">syscalltick：P 的系统调用次数。</span><br><span class="line">m：隶属哪一个 M。</span><br><span class="line">runqsize：运行队列中的 G 数量。</span><br><span class="line">gfreecnt：可用的G（状态为 Gdead）</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_Pidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行进行初始化。</td>
</tr>
<tr>
<td>_Prunning</td>
<td>1</td>
<td>当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。</td>
</tr>
<tr>
<td>_Psyscall</td>
<td>2</td>
<td>正在执行系统调用。</td>
</tr>
<tr>
<td>_Pgcstop</td>
<td>3</td>
<td>暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。</td>
</tr>
<tr>
<td>_Pdead</td>
<td>4</td>
<td>废弃，不再使用。</td>
</tr>
</tbody></table>
<h1 id="第八章：内存管理"><a href="#第八章：内存管理" class="headerlink" title="第八章：内存管理"></a>第八章：内存管理</h1><h1 id="1-Go-内存分配机制？"><a href="#1-Go-内存分配机制？" class="headerlink" title="1.Go 内存分配机制？"></a>1.Go 内存分配机制？</h1><hr>
<p><em>caspar</em> <em>2605</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 内存分配机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=298768505&amp;bvid=BV1XF411T7bK&amp;cid=714416149&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p>
<h2 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="#设计思想"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">#</a>设计思想</h2><ul>
<li>内存分配算法采用Google的<code>TCMalloc算法</code>，每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争</li>
<li>把内存切分的非常的细小，分为多级管理，以降低锁的粒度</li>
<li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li>
</ul>
<h2 id="分配组件"><a href="#分配组件" class="headerlink" title="#分配组件"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E5%88%86%E9%85%8D%E7%BB%84%E4%BB%B6">#</a>分配组件</h2><p>Go的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code>和<code>mheap</code></p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220501185553347.png" alt="img"></p>
<h4 id="内存管理单元：mspan"><a href="#内存管理单元：mspan" class="headerlink" title="#内存管理单元：mspan"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83-mspan">#</a>内存管理单元：mspan</h4><p><code>mspan</code>是 内存管理的基本单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个mspan，每个<code>mspan</code> 都管理 <code>npages</code> 个大小为 8KB 的页，一个span 是由多个page组成的，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。</p>
<p><code>page</code>是内存存储的基本单元，“对象”放到<code>page</code>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan <span class="comment">// 后指针</span></span><br><span class="line">    prev *mspan <span class="comment">// 前指针</span></span><br><span class="line">    startAddr <span class="type">uintptr</span> <span class="comment">// 管理页的起始地址，指向page</span></span><br><span class="line">    npages    <span class="type">uintptr</span> <span class="comment">// 页数</span></span><br><span class="line">    spanclass   spanClass <span class="comment">// 规格</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> spanClass <span class="type">uint8</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<p>Go有68种不同大小的spanClass，用于小对象的分配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const _NumSizeClasses = 68</span><br><span class="line">var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<p>如果按照序号为1的spanClass（对象规格为8B）分配，每个span占用堆的字节数：8k，mspan可以保存1024个对象</p>
<p>如果按照序号为2的spanClass（对象规格为16B）分配，每个span占用堆的字节数：8k，mspan可以保存512个对象</p>
<p>…</p>
<p>如果按照序号为67的spanClass（对象规格为32K）分配，每个span占用堆的字节数：32k，mspan可以保存1个对象</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg4NzQ0,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>字段含义：</p>
<ul>
<li>class： class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型</li>
<li>bytes&#x2F;obj：该class代表对象的字节数</li>
<li>bytes&#x2F;span：每个span占用堆的字节数，也即页数*页大小</li>
<li>objects: 每个span可分配的对象个数，也即（bytes&#x2F;spans）&#x2F;（bytes&#x2F;obj）</li>
<li>waste bytes: 每个span产生的内存碎片，也即（bytes&#x2F;spans）%（bytes&#x2F;obj）</li>
</ul>
<p>大于32k的对象出现时，会直接从heap分配一个特殊的span，这个特殊的span的类型(class)是0, 只包含了一个大对象</p>
<h4 id="线程缓存：mcache"><a href="#线程缓存：mcache" class="headerlink" title="#线程缓存：mcache"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98-mcache">#</a>线程缓存：mcache</h4><p>mcache管理线程在本地缓存的mspan，每个goroutine绑定的P都有一个<code>mcache</code>字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [numSpanClasses]*mspan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_NumSizeClasses = <span class="number">68</span></span><br><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>68*2=136</code>，其中*2是将spanClass分成了有指针和没有指针两种,方便与垃圾回收。对于每种规格，有2个mspan，一个mspan不包含指针，另一个mspan则包含指针。对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。</p>
<p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p>
<h4 id="中心缓存：mcentral"><a href="#中心缓存：mcentral" class="headerlink" title="#中心缓存：mcentral"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E4%B8%AD%E5%BF%83%E7%BC%93%E5%AD%98-mcentral">#</a>中心缓存：mcentral</h4><p>mcentral管理全局的mspan供所有线程使用，全局mheap变量包含central字段，每个 mcentral 结构都维护在<strong>mheap</strong>结构内</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    spanclass spanClass <span class="comment">// 指当前规格大小</span></span><br><span class="line"></span><br><span class="line">    partial [<span class="number">2</span>]spanSet <span class="comment">// 有空闲object的mspan列表</span></span><br><span class="line">    full    [<span class="number">2</span>]spanSet <span class="comment">// 没有空闲object的mspan列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<p>每个mcentral管理一种spanClass的mspan，并将有空闲空间和没有空闲空间的mspan分开管理。partial和 full<code>的数据类型为</code>spanSet，表示 <code>mspans</code>集，可以通过pop、push来获得mspans</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> spanSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    spineLock mutex</span><br><span class="line">    spine     unsafe.Pointer <span class="comment">// 指向[]span的指针</span></span><br><span class="line">    spineLen  <span class="type">uintptr</span>        <span class="comment">// Spine array length, accessed atomically</span></span><br><span class="line">    spineCap  <span class="type">uintptr</span>        <span class="comment">// Spine array cap, accessed under lock</span></span><br><span class="line"></span><br><span class="line">    index headTailIndex  <span class="comment">// 前32位是头指针，后32位是尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p>
<ul>
<li>获取； 加锁，从<code>partial</code>链表找到一个可用的<code>mspan</code>；并将其从<code>partial</code>链表删除；将取出的<code>mspan</code>加入到<code>full</code>链表；将<code>mspan</code>返回给工作线程，解锁。</li>
<li>归还； 加锁，将<code>mspan</code>从<code>full</code>链表删除；将<code>mspan</code>加入到<code>partial</code>链表，解锁。</li>
</ul>
<h4 id="页堆：mheap"><a href="#页堆：mheap" class="headerlink" title="#页堆：mheap"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E9%A1%B5%E5%A0%86-mheap">#</a>页堆：mheap</h4><p>mheap管理Go的所有动态分配内存，可以认为是Go程序持有的整个堆空间，全局唯一</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mheap_ mheap</span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex    <span class="comment">// 全局锁</span></span><br><span class="line">    pages     pageAlloc <span class="comment">// 页面分配的数据结构</span></span><br><span class="line">    allspans []*mspan <span class="comment">// 所有通过 mheap_ 申请的mspans</span></span><br><span class="line">        <span class="comment">// 堆</span></span><br><span class="line">    arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 所有中心缓存mcentral</span></span><br><span class="line">    central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>复制代码</p>
<p>所有<code>mcentral</code>的集合则是存放于<code>mheap</code>中的。<code>mheap</code>里的<code>arena</code> 区域是堆内存的抽象，运行时会将 <code>8KB</code> 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。</p>
<p>当申请内存时，依次经过 <code>mcache</code> 和 <code>mcentral</code> 都没有可用合适规格的大小内存，这时候会向 <code>mheap</code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 <code>mcentral</code> 的 <code>非空闲列表</code> 后面</p>
<h3 id="分配对象"><a href="#分配对象" class="headerlink" title="#分配对象"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1">#</a>分配对象</h3><ul>
<li>微对象 (0, 16B)：先使用线程缓存上的微型分配器，再依次尝试线程缓存、中心缓存、堆 分配内存；</li>
<li>小对象 [16B, 32KB]：依次尝试线程缓存、中心缓存、堆 分配内存；</li>
<li>大对象 (32KB, +∞)：直接尝试堆分配内存；</li>
</ul>
<h3 id="分配流程"><a href="#分配流程" class="headerlink" title="#分配流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-1.html#%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B">#</a>分配流程</h3><ul>
<li>首先通过计算使用的大小规格</li>
<li>然后使用<code>mcache</code>中对应大小规格的块分配。</li>
<li>如果<code>mcentral</code>中没有可用的块，则向<code>mheap</code>申请，并根据算法找到最合适的<code>mspan</code>。</li>
<li>如果申请到的<code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li>
<li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）</li>
</ul>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220501185248901.png" alt="img"></p>
<h1 id="2-Go-内存逃逸机制？"><a href="#2-Go-内存逃逸机制？" class="headerlink" title="2.Go 内存逃逸机制？"></a>2.Go 内存逃逸机制？</h1><hr>
<p><em>caspar</em> <em>1781</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 内存逃逸机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=641383238&amp;bvid=BV1rY4y1b7qH&amp;cid=716100960&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-7"><a href="#概念-7" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从”栈”上逃逸到”堆”上的现象就成为内存逃逸。</p>
<p>在栈上分配的地址，一般由系统申请和释放，不会有额外性能的开销，比如函数的入参、局部变量、返回值等。在堆上分配的内存，如果要回收掉，需要进行 GC，那么GC 一定会带来额外的性能开销。编程语言不断优化GC算法，主要目的都是为了减少 GC带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<h2 id="逃逸机制"><a href="#逃逸机制" class="headerlink" title="#逃逸机制"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6">#</a>逃逸机制</h2><p>编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中;</li>
<li>如果栈上放不下，则必定放到堆上;</li>
</ol>
<p>逃逸分析也就是由编译器决定哪些变量放在栈，哪些放在堆中，通过编译参数<code>-gcflag=-m</code>可以查看编译过程中的逃逸分析，发生逃逸的几种场景如下：</p>
<h2 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="#指针逃逸"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%8C%87%E9%92%88%E9%80%83%E9%80%B8">#</a>指针逃逸</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func escape1() *int &#123;</span><br><span class="line">    var a int = 1</span><br><span class="line">    <span class="built_in">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    escape1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>复制代码</p>
<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:4:6: moved to heap: a</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>函数返回值为局部变量的指针，函数虽然退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</p>
<h2 id="栈空间不足"><a href="#栈空间不足" class="headerlink" title="#栈空间不足"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%A0%88%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3">#</a>栈空间不足</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>复制代码</p>
<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:4:11: make([]int, 10000, 10000) escapes to heap</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量s占用内存过大，编译器会将其分配到堆上</p>
<h2 id="变量大小不确定"><a href="#变量大小不确定" class="headerlink" title="#变量大小不确定"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E5%8F%98%E9%87%8F%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A">#</a>变量大小不确定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">10</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, number) <span class="comment">// 编译期间无法确定slice的长度</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>复制代码</p>
<p>编译期间无法确定slice的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。直接<code>s := make([]int, 10)</code>不会发生逃逸</p>
<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="#动态类型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">#</a>动态类型</h2><p>动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸</p>
<p>空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="number">1111</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape4()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:6:14: 1111 escapes to heap</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>fmt.Println(a …interface{})函数参数为interface，编译器不确定参数的类型，会将变量分配到堆上</p>
<h2 id="闭包引用对象"><a href="#闭包引用对象" class="headerlink" title="#闭包引用对象"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E9%97%AD%E5%8C%85%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">#</a>闭包引用对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escape5</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    escape5()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>复制代码</p>
<p>通过<code>go build -gcflags=-m main.go</code>查看逃逸情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:4:6: moved to heap: i</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>复制代码</p>
<p>闭包函数中局部变量i在后续函数是继续使用的，编译器将其分配到堆上</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="#总结"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-2.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><ol>
<li>栈上分配内存比在堆中分配内存效率更高</li>
<li>栈上分配的内存不需要 GC 处理，而堆需要</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ol>
<p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率（而不是传指针）更高一点。</p>
<h1 id="3-Go-内存对齐机制？"><a href="#3-Go-内存对齐机制？" class="headerlink" title="3.Go 内存对齐机制？"></a>3.Go 内存对齐机制？</h1><hr>
<p><em>caspar</em> <em>1326</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 内存对齐机制？</summary><iframe src="https://player.bilibili.com/player.html?aid=896475637&amp;bvid=BV1QA4y1S71h&amp;cid=717667872&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="#什么是内存对齐"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">#</a>什么是内存对齐</h2><p>为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。<strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。</strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。</p>
<h2 id="对齐系数"><a href="#对齐系数" class="headerlink" title="#对齐系数"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E5%AF%B9%E9%BD%90%E7%B3%BB%E6%95%B0">#</a>对齐系数</h2><p>不同硬件平台占用的大小和对齐值都可能是不一样的，每个特定平台上的编译器都有自己的默认”对齐系数”，32位系统对齐系数是4，64位系统对齐系数是8</p>
<p>不同类型的对齐系数也可能不一样，使用<code>Go</code>语言中的<code>unsafe.Alignof</code>函数可以返回相应类型的对齐系数，对齐系数都符合<code>2^n</code>这个规律，最大也不会超过8</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">bool</span>(<span class="literal">true</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;string alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">string</span>(<span class="string">&quot;a&quot;</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">int</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;float alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">float64</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;int32 alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">int32</span>(<span class="number">0</span>)))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;float32 alignof is %d\n&quot;</span>, unsafe.Alignof(<span class="type">float32</span>(<span class="number">0</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>复制代码</p>
<p>可以查看到各种类型在Mac 64位上的对齐系数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool alignof is 1</span><br><span class="line">string alignof is 8</span><br><span class="line">int alignof is 8</span><br><span class="line">int32 alignof is 4</span><br><span class="line">float32 alignof is 4</span><br><span class="line"><span class="built_in">float</span> alignof is 8</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="#优点"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E4%BC%98%E7%82%B9">#</a>优点</h3><ol>
<li>提高可移植性，有些<code>CPU</code>可以访问任意地址上的任意数据，而有些<code>CPU</code>只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了</li>
<li>提高内存的访问效率，32位CPU下一次可以从内存中读取32位（4个字节）的数据，64位CPU下一次可以从内存中读取64位（8个字节）的数据，这个长度也称为CPU的字长。CPU一次可以读取1个字长的数据到内存中，如果所需要读取的数据正好跨了1个字长，那就得花两个CPU周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="#缺点"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E7%BC%BA%E7%82%B9">#</a>缺点</h3><ol>
<li>存在内存空间的浪费，实际上是空间换时间</li>
</ol>
<h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="#结构体对齐"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-3.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">#</a>结构体对齐</h2><p>对齐原则：</p>
<ol>
<li><strong>结构体变量中成员的偏移量必须是成员大小的整数倍</strong></li>
<li><strong>整个结构体的地址必须是最大字节的整数倍</strong>（结构体的内存占用是1&#x2F;4&#x2F;8&#x2F;16byte…)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i16  <span class="type">int16</span> <span class="comment">// 2 byte</span></span><br><span class="line">    <span class="type">bool</span> <span class="type">bool</span>  <span class="comment">// 1 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i8  <span class="type">int8</span>  <span class="comment">// 1 byte</span></span><br><span class="line">    i64 <span class="type">int64</span> <span class="comment">// 8 byte</span></span><br><span class="line">    i32 <span class="type">int32</span> <span class="comment">// 4 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i8  <span class="type">int8</span>  <span class="comment">// 1 byte</span></span><br><span class="line">    i32 <span class="type">int32</span> <span class="comment">// 4 byte</span></span><br><span class="line">    i64 <span class="type">int64</span> <span class="comment">// 8 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOARCH) <span class="comment">// amd64</span></span><br><span class="line"></span><br><span class="line">    t1 := T1&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t1)) <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    t2 := T2&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t2)) <span class="comment">// 24 bytes</span></span><br><span class="line"></span><br><span class="line">    t3 := T3&#123;&#125;</span><br><span class="line">    fmt.Println(unsafe.Sizeof(t3)) <span class="comment">// 16 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37</p>
<p>复制代码</p>
<p>以T1结构体为例，实际存储数据的只有3字节，但实际用了4字节，浪费了1个字节：</p>
<p>i16并没有直接放在bool的后面，而是在bool中填充了一个空白后，放到了偏移量为2的位置上。如果i16从偏移量为1的位置开始占用2个字节，根据对齐原则2：构体变量中成员的偏移量必须是成员大小的整数倍，套用公式 1 % 2 &#x3D; 1，就不满足对齐的要求，所以i16从偏移量为2的位置开始</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502132935164.png" alt="img"></p>
<p>以T2结构体为例，实际存储数据的只有13字节，但实际用了24字节，浪费了11个字节：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502133003644.png" alt="img"></p>
<p>以T3结构体为例，实际存储数据的只有13字节，但实际用了16字节，浪费了3个字节：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220502133303337.png" alt="img"></p>
<h1 id="4-Go-GC实现原理？"><a href="#4-Go-GC实现原理？" class="headerlink" title="4.Go GC实现原理？"></a>4.Go GC实现原理？</h1><hr>
<p><em>caspar</em> <em>1956</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go GC实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=811515979&amp;bvid=BV1B34y1h73h&amp;cid=718559520&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="什么是GC？"><a href="#什么是GC？" class="headerlink" title="#什么是GC？"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%BB%80%E4%B9%88%E6%98%AFgc">#</a>什么是GC？</h2><p>垃圾回收也称为GC（Garbage Collection），是一种自动内存管理机制</p>
<p>现代高级编程语言管理内存的方式分为两种：自动和手动，像C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。</p>
<p>在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC负责回收堆内存，而不负责回收栈中的内存：</p>
<p>栈是线程的专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈，函数执行完后，编译器可以将栈上分配的内存可以直接释放，不需要通过GC来回收。</p>
<p>堆是程序共享的内存，需要GC进行回收在堆上分配的内存。</p>
<p>垃圾回收器的执行过程被划分为两个半独立的组件：</p>
<ul>
<li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li>
<li>回收器（Collector）：负责执行垃圾回收的代码。</li>
</ul>
<h2 id="主流GC算法"><a href="#主流GC算法" class="headerlink" title="#主流GC算法"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%B8%BB%E6%B5%81gc%E7%AE%97%E6%B3%95">#</a>主流GC算法</h2><p>目前比较常见的垃圾回收算法有三种：</p>
<ol>
<li>引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。<ul>
<li>代表语言：<strong>Python</strong>、<strong>PHP</strong>、<strong>Swift</strong></li>
<li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li>
<li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li>
</ul>
</li>
<li>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。<ul>
<li>代表语言：<strong>Java</strong></li>
<li>优点：回收性能好</li>
<li>缺点：算法复杂</li>
</ul>
</li>
<li>标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。<ul>
<li>代表语言：<strong>Golang</strong>（三色标记法）</li>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要 STW，暂时停掉程序运行。</li>
</ul>
</li>
</ol>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220503232512072.png" alt="img"></p>
<h2 id="Go-GC算法"><a href="#Go-GC算法" class="headerlink" title="#Go GC算法"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#go-gc%E7%AE%97%E6%B3%95">#</a>Go GC算法</h2><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="#三色标记法"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95">#</a><strong>三色标记法</strong></h4><p>此算法是在Go 1.5版本开始使用，Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和混合写屏障技术，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW</p>
<p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p>
<ul>
<li>灰色：对象还在标记队列中等待</li>
<li>黑色：对象已被标记，<code>gcmarkBits</code> 对应位为 <code>1</code> （该对象不会在本次 GC 中被回收）</li>
<li>白色：对象未被标记，<code>gcmarkBits</code> 对应位为 <code>0</code> （该对象将会在本次 GC 中被清理）</li>
</ul>
<p>step 1: 创建：白、灰、黑 三个集合</p>
<p>step 2: 将所有对象放入白色集合中</p>
<p>step 3: 遍历所有<strong>root对象</strong>，把遍历到的对象从白色集合放入灰色集合 (这里放入灰色集合的都是根节点的对象)</p>
<p>step 4: 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，自身标记为黑色</p>
<p>step 5: 重复步骤4，直到灰色中无任何对象，其中用到2个机制：</p>
<ul>
<li><strong>写屏障（Write Barrier）</strong>：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后<strong>指针传递时</strong>会把指针标记，即本轮不回收，下次 GC 时再确定。</li>
<li><strong>辅助 GC（Mutator Assist）</strong>：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
</ul>
<p>step 6: 收集所有白色对象（垃圾）</p>
<h4 id="root对象"><a href="#root对象" class="headerlink" title="#root对象"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#root%E5%AF%B9%E8%B1%A1">#</a><strong>root对象</strong></h4><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p>
<p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上指向堆内存的指针。 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p>
<h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="#插入写屏障"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>插入写屏障</strong></h4><p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p>
<p>缺点：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活</p>
<h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="#删除写屏障"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>删除写屏障</strong></h4><p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p>
<p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="#混合写屏障"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C">#</a><strong>混合写屏障</strong></h4><p>GC没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p>
<ul>
<li>GC开始将栈上的对象全部扫描并标记为黑色。</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ul>
<h2 id="GC流程"><a href="#GC流程" class="headerlink" title="#GC流程"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E6%B5%81%E7%A8%8B">#</a>GC流程</h2><p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p>
<ol>
<li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记 ，与用户程序并发执行</li>
<li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行</li>
</ol>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504185906969.png" alt="img"></p>
<h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="#GC触发时机"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">#</a>GC触发时机</h2><p><strong>主动触发：</strong></p>
<ul>
<li>调用 runtime.GC() 方法，触发 GC</li>
</ul>
<p><strong>被动触发：</strong></p>
<ul>
<li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</li>
<li>根据内存分配阈值触发，该触发条件由环境变量GOGC控制，默认值为100（100%），当前堆内存占用是上次GC结束后占用内存的2倍时，触发GC</li>
</ul>
<h2 id="GC算法演进"><a href="#GC算法演进" class="headerlink" title="#GC算法演进"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-4.html#gc%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B">#</a>GC算法演进</h2><ul>
<li>Go 1：mark and sweep操作都需要STW</li>
<li><strong>Go 1.3</strong>：分离了mark和sweep操作，mark过程需要 STW，mark完成后让sweep任务和普通协程任务一样并行，停顿时间在约几百ms</li>
<li><strong>Go 1.5</strong>：引入三色并发标记法、插入写屏障，不需要每次都扫描整个内存空间，可以减少stop the world的时间，停顿时间在100ms以内</li>
<li>Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在10ms以内</li>
<li>Go 1.7：停顿时间控制在2ms以内</li>
<li><strong>Go 1.8</strong>：混合写屏障（插入写屏障和删除写屏障），停顿时间在0.5ms左右</li>
<li>Go 1.9：彻底移除了栈的重扫描过程</li>
<li>Go 1.12：整合了两个阶段的 Mark Termination</li>
<li>Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger</li>
<li>Go 1.14：替代了仅存活了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题</li>
</ul>
<h1 id="5-Go-GC如何调优？"><a href="#5-Go-GC如何调优？" class="headerlink" title="5.Go GC如何调优？"></a>5.Go GC如何调优？</h1><hr>
<p><em>caspar</em> <em>1243</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go GC如何调优？</summary><iframe src="https://player.bilibili.com/player.html?aid=641500627&amp;bvid=BV1qY4y1473g&amp;cid=720776915&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<ul>
<li>控制内存分配的速度，限制 Goroutine 的数量，提高赋值器 mutator 的 CPU 利用率（降低GC的CPU利用率）</li>
<li>少量使用<code>+</code>连接string</li>
<li>slice提前分配足够的内存来降低扩容带来的拷贝</li>
<li>避免map key对象过多，导致扫描时间增加</li>
<li>变量复用，减少对象分配，例如使用 sync.Pool 来复用需要频繁创建临时对象、使用全局变量等</li>
<li>增大 GOGC 的值，降低 GC 的运行频率</li>
</ul>
<h1 id="6-Go-如何查看GC信息？"><a href="#6-Go-如何查看GC信息？" class="headerlink" title="6.Go 如何查看GC信息？"></a>6.Go 如何查看GC信息？</h1><hr>
<p><em>caspar</em> <em>985</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 如何查看GC信息？</summary><iframe src="https://player.bilibili.com/player.html?aid=554207586&amp;bvid=BV1Ev4y1A7Da&amp;cid=724587744&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="1-GODEBUG-’gctrace-1’"><a href="#1-GODEBUG-’gctrace-1’" class="headerlink" title="#1. GODEBUG&#x3D;’gctrace&#x3D;1’"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_1-godebug-gctrace-1">#</a>1. GODEBUG&#x3D;’gctrace&#x3D;1’</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    for n := 1; n &lt; 100000; n++ &#123;</span><br><span class="line">        _ = make([]byte, 1&lt;&lt;20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>复制代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=&#x27;gctrace=1&#x27; go run main.go</span><br><span class="line"></span><br><span class="line">gc 1 @0.003s 4%: 0.013+1.7+0.008 ms clock, 0.10+0.67/1.2/0.018+0.064 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 2 @0.006s 2%: 0.006+4.5+0.058 ms clock, 0.048+0.070/0.027/3.6+0.47 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 3 @0.011s 3%: 0.021+1.3+0.009 ms clock, 0.17+0.041/0.41/0.046+0.072 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 4 @0.013s 5%: 0.025+0.38+0.26 ms clock, 0.20+0.054/0.15/0.009+2.1 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 5 @0.014s 5%: 0.021+0.16+0.002 ms clock, 0.17+0.098/0.028/0.001+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 6 @0.014s 7%: 0.025+1.6+0.003 ms clock, 0.20+0.061/2.9/1.5+0.025 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 7 @0.016s 7%: 0.019+1.0+0.002 ms clock, 0.15+0.053/1.0/0.018+0.017 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 8 @0.017s 7%: 0.029+0.17+0.002 ms clock, 0.23+0.037/0.10/0.063+0.022 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 8 P</span><br><span class="line">gc 9 @0.018s 7%: 0.019+0.23+0.002 ms clock, 0.15+0.040/0.16/0.023+0.018 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 10 @0.018s 7%: 0.022+0.23+0.003 ms clock, 0.17+0.061/0.13/0.006+0.024 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P</span><br><span class="line">gc 11 @0.018s 7%: 0.019+0.11+0.001 ms clock, 0.15+0.033/0.051/0.013+0.015 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 12 @0.019s 7%: 0.018+0.19+0.001 ms clock, 0.14+0.035/0.10/0.018+0.014 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 13 @0.019s 7%: 0.018+0.35+0.002 ms clock, 0.15+0.21/0.054/0.013+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 14 @0.019s 8%: 0.024+0.27+0.002 ms clock, 0.19+0.022/0.13/0.014+0.017 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P</span><br><span class="line">gc 15 @0.020s 8%: 0.019+0.42+0.038 ms clock, 0.15+0.060/0.28/0.007+0.31 ms cpu, 4-&gt;17-&gt;13 MB, 5 MB goal, 8 P</span><br><span class="line">gc 16 @0.021s 8%: 0.018+0.53+0.060 ms clock, 0.14+0.045/0.39/0.005+0.48 ms cpu, 21-&gt;28-&gt;7 MB, 26 MB goal, 8 P</span><br><span class="line">gc 17 @0.021s 10%: 0.020+0.91+0.64 ms clock, 0.16+0.050/0.36/0.027+5.1 ms cpu, 12-&gt;16-&gt;4 MB, 14 MB goal, 8 P</span><br><span class="line">gc 18 @0.023s 10%: 0.020+0.55+0.002 ms clock, 0.16+0.053/0.50/0.081+0.023 ms cpu, 7-&gt;9-&gt;2 MB, 8 MB goal, 8 P</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>复制代码</p>
<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gc 2</td>
<td align="left">第二个 GC 周期</td>
</tr>
<tr>
<td align="left">0.006</td>
<td align="left">程序开始后的 0.006 秒</td>
</tr>
<tr>
<td align="left">2%</td>
<td align="left">该 GC 周期中 CPU 的使用率</td>
</tr>
<tr>
<td align="left">0.006</td>
<td align="left">标记开始时， STW 所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">4.5</td>
<td align="left">标记过程中，并发标记所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">0.058</td>
<td align="left">标记终止时， STW 所花费的时间（wall clock）</td>
</tr>
<tr>
<td align="left">0.048</td>
<td align="left">标记开始时， STW 所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.070</td>
<td align="left">标记过程中，标记辅助所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.027</td>
<td align="left">标记过程中，并发标记所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">3.6</td>
<td align="left">标记过程中，GC 空闲的时间（cpu time）</td>
</tr>
<tr>
<td align="left">0.47</td>
<td align="left">标记终止时， STW 所花费的时间（cpu time）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">标记开始时，堆的大小的实际值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">标记结束时，堆的大小的实际值</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">标记结束时，标记为存活的对象大小</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">标记结束时，堆的大小的预测值</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">P 的数量</td>
</tr>
</tbody></table>
<h2 id="2-go-tool-trace"><a href="#2-go-tool-trace" class="headerlink" title="#2. go tool trace"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_2-go-tool-trace">#</a>2. go tool trace</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;runtime/trace&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f, _ := os.Create(&quot;trace.out&quot;)</span><br><span class="line">    defer f.Close()</span><br><span class="line">    trace.Start(f)</span><br><span class="line">    defer trace.Stop()</span><br><span class="line">    for n := 1; n &lt; 100000; n++ &#123;</span><br><span class="line">        _ = make([]byte, 1&lt;&lt;20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p>复制代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ go tool trace trace.out</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>复制代码</p>
<p>打开浏览器后，可以看到如下统计：</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504204708533.png" alt="img"></p>
<p>点击View trace，可以查看当时的trace情况</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/f3d74b546b1e360c9d6946757ada4f64.png" alt="img"></p>
<p>点击 Minimum mutator utilization，可以查看到赋值器 mutator （用户程序）对 CPU 的利用率 74.1%，接近100%则代表没有针对GC的优化空间了</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220504204751752.png" alt="img"></p>
<h2 id="3-debug-ReadGCStats"><a href="#3-debug-ReadGCStats" class="headerlink" title="#3. debug.ReadGCStats"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_3-debug-readgcstats">#</a>3. debug.ReadGCStats</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGCStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(time.Second)</span><br><span class="line">    s := debug.GCStats&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            debug.ReadGCStats(&amp;s)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;gc %d last@%v, PauseTotal %v\n&quot;</span>, s.NumGC, s.LastGC, s.PauseTotal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> printGCStats()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">        _ = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25</p>
<p>复制代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"></span><br><span class="line">gc 3392 last@2022-05-04 19:22:52.877293 +0800 CST, PauseTotal 117.524907ms</span><br><span class="line">gc 6591 last@2022-05-04 19:22:53.876837 +0800 CST, PauseTotal 253.254996ms</span><br><span class="line">gc 10028 last@2022-05-04 19:22:54.87674 +0800 CST, PauseTotal 376.981595ms</span><br><span class="line">gc 13447 last@2022-05-04 19:22:55.87689 +0800 CST, PauseTotal 511.420111ms</span><br><span class="line">gc 16938 last@2022-05-04 19:22:56.876955 +0800 CST, PauseTotal 649.293449ms</span><br><span class="line">gc 20350 last@2022-05-04 19:22:57.876756 +0800 CST, PauseTotal 788.003014ms</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NumGC</td>
<td align="left">GC总次数</td>
</tr>
<tr>
<td align="left">LastGC</td>
<td align="left">上次GC时间</td>
</tr>
<tr>
<td align="left">PauseTotal</td>
<td align="left">STW总耗时</td>
</tr>
</tbody></table>
<h2 id="4-runtime-ReadMemStats"><a href="#4-runtime-ReadMemStats" class="headerlink" title="#4. runtime.ReadMemStats"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/8-6.html#_4-runtime-readmemstats">#</a>4. runtime.ReadMemStats</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(time.Second)</span><br><span class="line">    s := runtime.MemStats&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            runtime.ReadMemStats(&amp;s)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;gc %d last@%v, heap_object_num: %v, heap_alloc: %vMB, next_heap_size: %vMB\n&quot;</span>,</span><br><span class="line">                s.NumGC, time.Unix(<span class="type">int64</span>(time.Duration(s.LastGC).Seconds()), <span class="number">0</span>), s.HeapObjects, s.HeapAlloc/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>), s.NextGC/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> printMemStats()</span><br><span class="line">    fmt.Println(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">        _ = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<p>复制代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"></span><br><span class="line">gc 2978 last@2022-05-04 19:38:04 +0800 CST, heap_object_num: 391, heap_alloc: 20MB, next_heap_size: 28MB</span><br><span class="line">gc 5817 last@2022-05-04 19:38:05 +0800 CST, heap_object_num: 370, heap_alloc: 4MB, next_heap_size: 4MB</span><br><span class="line">gc 9415 last@2022-05-04 19:38:06 +0800 CST, heap_object_num: 392, heap_alloc: 7MB, next_heap_size: 8MB</span><br><span class="line">gc 11429 last@2022-05-04 19:38:07 +0800 CST, heap_object_num: 339, heap_alloc: 4MB, next_heap_size: 5MB</span><br><span class="line">gc 14706 last@2022-05-04 19:38:08 +0800 CST, heap_object_num: 436, heap_alloc: 6MB, next_heap_size: 8MB</span><br><span class="line">gc 18253 last@2022-05-04 19:38:09 +0800 CST, heap_object_num: 375, heap_alloc: 4MB, next_heap_size: 6M</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>复制代码</p>
<p>字段含义由下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NumGC</td>
<td align="left">GC总次数</td>
</tr>
<tr>
<td align="left">LastGC</td>
<td align="left">上次GC时间</td>
</tr>
<tr>
<td align="left">HeapObjects</td>
<td align="left">堆中已经分配的对象总数，GC内存回收后HeapObjects取值相应减小</td>
</tr>
<tr>
<td align="left">HeapAlloc</td>
<td align="left">堆中已经分配给对象的字节数，GC内存回收后HeapAlloc取值相应减小</td>
</tr>
<tr>
<td align="left">NextGC</td>
<td align="left">下次GC目标堆的大小</td>
</tr>
</tbody></table>
<h1 id="第九章：并发编程"><a href="#第九章：并发编程" class="headerlink" title="第九章：并发编程"></a>第九章：并发编程</h1><h1 id="1-Go-常用的并发模型？"><a href="#1-Go-常用的并发模型？" class="headerlink" title="1.Go 常用的并发模型？"></a>1.Go 常用的并发模型？</h1><hr>
<p><em>caspar</em> <em>2172</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 常用的并发模型？</summary><iframe src="https://player.bilibili.com/player.html?aid=854546792&amp;bvid=BV1z54y1o7kf&amp;cid=734101562&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行<strong>通信</strong>和协作。</p>
<h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="#线程间通信方式"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">#</a>线程间通信方式</h2><p>线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步信息</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="#共享内存"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">#</a><strong>共享内存</strong></h3><p><strong>抽象层级</strong>：抽象层级低，当我们遇到对资源进行更细粒度的控制或者对性能有极高要求的场景才应该考虑抽象层级更低的方法</p>
<p><strong>耦合</strong>：高，线程需要在读取或者写入数据时先获取保护该资源的互斥锁</p>
<p><strong>线程竞争</strong>：需要加锁，才能避免线程竞争和数据冲突</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="#发送消息"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">#</a><strong>发送消息</strong></h3><p><strong>抽象层级</strong>：抽象层级高，提供了更良好的封装和与领域更相关和契合的设计，比如Go 语言中的<code>Channel</code>就提供了 Goroutine 之间用于传递信息的方式，它在内部实现时就广泛用到了共享内存和锁，通过对两者进行的组合提供了更高级的同步机制</p>
<p><strong>耦合</strong>：低，生产消费者模型</p>
<p><strong>线程竞争</strong>：保证同一时间只有一个活跃的线程能够访问数据，channel维护所有被该chanel阻塞的协程，保证有资源的时候只唤醒一个协程，从而避免竞争</p>
<p>Go语言中实现了两种并发模型，一种是共享内存并发模型，另一种则是CSP模型。</p>
<h2 id="共享内存并发模型"><a href="#共享内存并发模型" class="headerlink" title="#共享内存并发模型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-1.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B">#</a>共享内存并发模型</h2><p>通过直接共享内存 + 锁的方式同步信息，传统多线程并发</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220514161804822.png" alt="img"></p>
<h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="#CSP并发模型"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-1.html#csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B">#</a>CSP并发模型</h2><p>通过发送消息的方式来同步信息，Go语言推荐使用的<em>通信顺序进程</em>（communicating sequential processes）并发模型，通过goroutine和channel来实现</p>
<ul>
<li><code>goroutine</code> 是Go语言中并发的执行单位，可以理解为”线程“</li>
<li><code>channel</code>是Go语言中各个并发结构体(<code>goroutine</code>)之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的”管道“，类似于Linux中的管道</li>
</ul>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220514161841437.png" alt="img"></p>
<h1 id="2-Go-有哪些并发同步原语？"><a href="#2-Go-有哪些并发同步原语？" class="headerlink" title="2.Go 有哪些并发同步原语？"></a>2.Go 有哪些并发同步原语？</h1><hr>
<p><em>caspar</em> <em>1569</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 有哪些并发同步原语？</summary><iframe src="https://player.bilibili.com/player.html?aid=512084516&amp;bvid=BV1qg411R7ix&amp;cid=735468748&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<p>Go是一门以并发编程见长的语言，它提供了一系列的同步原语方便开发者使用</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="#原子操作"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">#</a>原子操作</h2><p>Mutex、RWMutex 等并发原语的底层实现是通过 atomic 包中的一些原子操作来实现的，原子操作是最基础的并发原语</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/53d55255fe851754659d90cbee814f13.jpeg" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> opts <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add(&amp;opts, <span class="number">3</span>)</span><br><span class="line">    load(&amp;opts)</span><br><span class="line">    compareAndSwap(&amp;opts, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    swap(&amp;opts, <span class="number">5</span>)</span><br><span class="line">    store(&amp;opts, <span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(addr, delta) <span class="comment">//加操作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;add opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(addr *<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;load opts: &quot;</span>, atomic.LoadInt64(&amp;opts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareAndSwap</span><span class="params">(addr *<span class="type">int64</span>, oldValue <span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt64(addr, oldValue, newValue) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;cas opts: &quot;</span>, *addr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.SwapInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(addr *<span class="type">int64</span>, newValue <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    atomic.StoreInt64(addr, newValue)</span><br><span class="line">    fmt.Println(<span class="string">&quot;store opts: &quot;</span>, *addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p>
<p>复制代码</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="#Channel"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#channel">#</a>Channel</h2><p><code>channel</code> 管道，高级同步原语，goroutine之间通信的桥梁</p>
<p>使用场景：消息队列、数据传递、信号通知、任务编排、锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(<span class="string">&quot;通过ch访问临界区&quot;</span>)</span><br><span class="line">            &lt;-c</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>复制代码</p>
<h2 id="基本并发原语"><a href="#基本并发原语" class="headerlink" title="#基本并发原语"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD">#</a>基本并发原语</h2><p>Go 语言在 <code>sync</code>包中提供了用于同步的一些基本原语，这些基本原语提供了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级更高的 Channel 实现同步。</p>
<p>常见的并发原语如下：<code>sync.Mutex</code>、<code>sync.RWMutex</code>、<code>sync.WaitGroup</code>、<code>sync.Cond</code>、<code>sync.Once</code>、<code>sync.Pool</code>、<code>sync.Context</code></p>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="#sync.Mutex"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-mutex">#</a><strong>sync.Mutex</strong></h3><p><code>sync.Mutex</code> （互斥锁） 可以限制对临界资源的访问，保证只有一个 goroutine 访问共享资源</p>
<p>使用场景：大量读写，比如多个 goroutine 并发更新同一个资源，像计数器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 封装好的计数器</span></span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> gNum = <span class="number">1000</span></span><br><span class="line">    wg.Add(gNum)</span><br><span class="line">    <span class="comment">// 启动10个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; gNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            counter.Incr() <span class="comment">// 受到锁保护的方法</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的计数器类型</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加1的方法，内部使用互斥锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到计数器的值，也需要锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43</p>
<p>复制代码</p>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="#sync.RWMutex"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-rwmutex">#</a><strong>sync.RWMutex</strong></h3><p><code>sync.RWMutex</code> （读写锁） 可以限制对临界资源的访问，保证只有一个 goroutine 写共享资源，可以有多个goroutine 读共享资源</p>
<p>使用场景：大量并发读，少量并发写，有强烈的性能要求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 封装好的计数器</span></span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">var</span> gNum = <span class="number">1000</span></span><br><span class="line">    <span class="comment">// 启动10个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; gNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            counter.Count() <span class="comment">// 受到锁保护的方法</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;incr&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的计数器类型</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加1的方法，内部使用互斥锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到计数器的值，也需要锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44</p>
<p>复制代码</p>
<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="#sync.WaitGroup"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-waitgroup">#</a><strong>sync.WaitGroup</strong></h3><p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回</p>
<p>使用场景：并发等待，任务编排，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>复制代码</p>
<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="#sync.Cond"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-cond">#</a><strong>sync.Cond</strong></h3><p><code>sync.Cond</code> 可以让一组的 Goroutine 都在满足特定条件时被唤醒</p>
<p>使用场景：利用等待 &#x2F; 通知机制实现阻塞或者唤醒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> listen(c)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">go</span> broadcast(c)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">    c.Signal()</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36</p>
<p>复制代码</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="#sync.Once"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-once">#</a><strong>sync.Once</strong></h3><p><code>sync.Once</code> 可以保证在 Go 程序运行期间的某段代码只会执行一次</p>
<p>使用场景：常常用于单例对象的初始化场景</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>复制代码</p>
<h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="#sync.Pool"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-pool">#</a><strong>sync.Pool</strong></h3><p><code>sync.Pool</code>可以将暂时将不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能（频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺）</p>
<p>使用场景：对象池化， TCP连接池、数据库连接池、Worker Pool</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        v := pool.Get().(<span class="type">int</span>)</span><br><span class="line">        fmt.Println(v) <span class="comment">// 取出来的值是put进去的，对象复用；如果是新建对象，则取出来的值为0</span></span><br><span class="line">        pool.Put(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>复制代码</p>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="#sync.Map"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-map">#</a><strong>sync.Map</strong></h3><p><code>sync.Map</code> 线程安全的map</p>
<p>使用场景：map 并发读写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scene sync.Map</span><br><span class="line">    <span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">    scene.Store(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    scene.Store(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    scene.Store(<span class="string">&quot;3&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">    fmt.Println(scene.Load(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    <span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">    scene.Delete(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">    scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23</p>
<p>复制代码</p>
<h3 id="sync-Context"><a href="#sync-Context" class="headerlink" title="#sync.Context"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#sync-context">#</a><strong>sync.Context</strong></h3><p><code>sync.Context</code> 可以进行上下文信息传递、提供超时和取消机制、控制子 goroutine 的执行</p>
<p>使用场景：取消一个goroutine的执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;goroutine exit&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;receive cancel signal!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29</p>
<p>复制代码</p>
<h2 id="扩展并发原语"><a href="#扩展并发原语" class="headerlink" title="#扩展并发原语"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD">#</a>扩展并发原语</h2><h3 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="#ErrGroup"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#errgroup">#</a><strong>ErrGroup</strong></h3><p><code>errgroup</code> 可以在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能</p>
<p>使用场景：只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费，并且返回错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">    &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var g errgroup.Group</span><br><span class="line">    var urls = []string&#123;</span><br><span class="line">        &quot;http://www.baidu.com/&quot;,</span><br><span class="line">        &quot;https://www.sina.com.cn/&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    for i := range urls &#123;</span><br><span class="line">        url := urls[i]</span><br><span class="line">        g.Go(func() error &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            if err == nil &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">            return err</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    err := g.Wait()</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        fmt.Println(&quot;Successfully fetched all URLs.&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;fetched error:&quot;, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p>
<p>复制代码</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="#Semaphore"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#semaphore">#</a><strong>Semaphore</strong></h3><p><code>Semaphore</code>带权重的信号量，控制多个goroutine同时访问资源</p>
<p>使用场景：控制 goroutine 的阻塞和唤醒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/semaphore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">    sema       = semaphore.NewWeighted(<span class="type">int64</span>(maxWorkers)) <span class="comment">//信号量</span></span><br><span class="line">    task       = <span class="built_in">make</span>([]<span class="type">int</span>, maxWorkers*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务数，是worker的四</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> task &#123;</span><br><span class="line">        <span class="comment">// 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span></span><br><span class="line">        <span class="keyword">if</span> err := sema.Acquire(ctx, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动worker goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> sema.Release(<span class="number">1</span>)</span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">            task[i] = i + <span class="number">1</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求所有的worker,这样能确保前面的worker都执行完</span></span><br><span class="line">    <span class="keyword">if</span> err := sema.Acquire(ctx, <span class="type">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;获取所有的worker失败: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(maxWorkers, task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40</p>
<p>复制代码</p>
<h3 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="#SingleFlight"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-2.html#singleflight">#</a><strong>SingleFlight</strong></h3><p>用于抑制对下游的重复请求</p>
<p>使用场景：访问缓存、数据库等场景，缓存过期时只有一个请求去更新数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟从数据库读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArticle</span><span class="params">(id <span class="type">int</span>)</span></span> (article <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 假设这里会对数据库进行调用, 模拟不同并发下耗时不同</span></span><br><span class="line">    atomic.AddInt32(&amp;count, <span class="number">1</span>)</span><br><span class="line">    time.Sleep(time.Duration(count) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;article: %d&quot;</span>, id), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟优先读缓存，缓存不存在读取数据库，并且只有一个请求读取数据库，其它请求等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleflightGetArticle</span><span class="params">(sg *singleflight.Group, id <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    v, err, _ := sg.Do(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getArticle(id)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v.(<span class="type">string</span>), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.AfterFunc(<span class="number">1</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;count, -count)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        wg  sync.WaitGroup</span><br><span class="line">        now = time.Now()</span><br><span class="line">        n   = <span class="number">1000</span></span><br><span class="line">        sg  = &amp;singleflight.Group&#123;&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            res, _ := singleflightGetArticle(sg, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// res, _ := getArticle(1)</span></span><br><span class="line">            <span class="keyword">if</span> res != <span class="string">&quot;article: 1&quot;</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;同时发起 %d 次请求，耗时: %s&quot;</span>, n, time.Since(now))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58</p>
<p>复制代码</p>
<h1 id="3-Go-WaitGroup实现原理？"><a href="#3-Go-WaitGroup实现原理？" class="headerlink" title="3.Go WaitGroup实现原理？"></a>3.Go WaitGroup实现原理？</h1><hr>
<p><em>caspar</em> <em>1257</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go WaitGroup实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=812510386&amp;bvid=BV1G34y157K8&amp;cid=747586781&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-8"><a href="#概念-8" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p><code>Go</code>标准库提供了<code>WaitGroup</code>原语, 可以用它来等待一批 Goroutine 结束</p>
<h2 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="#底层数据结构"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line"> noCopy noCopy</span><br><span class="line"> state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>
<p>其中 <code>noCopy</code> 是 golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错。但需要注意的是，noCopy 不会影响程序正常的编译和运行。</p>
<p><code>state1</code>主要是存储着状态和信号量，状态维护了 2 个计数器，一个是请求计数器counter ，另外一个是等待计数器waiter（已调用 <code>WaitGroup.Wait</code> 的 goroutine 的个数）</p>
<p>当数组的首地址是处于一个<code>8</code>字节对齐的位置上时，那么就将这个数组的前<code>8</code>个字节作为<code>64</code>位值使用表示状态，后<code>4</code>个字节作为<code>32</code>位值表示信号量(<code>semaphore</code>)；同理如果首地址没有处于<code>8</code>字节对齐的位置上时，那么就将前<code>4</code>个字节作为<code>semaphore</code>，后<code>8</code>个字节作为<code>64</code>位数值。</p>
<p><img src="/2024/08/29/golang%E9%9D%A2%E8%AF%95/image-20220522104433409.png" alt="img"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="#使用方法"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-3.html#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">#</a>使用方法</h2><p>在WaitGroup里主要有3个方法：</p>
<ul>
<li><code>WaitGroup.Add()</code>：可以添加或减少请求的goroutine数量，*<code>Add(n)</code> 将会导致 <code>counter += n</code>*</li>
<li><code>WaitGroup.Done()</code>：相当于Add(-1)，<code>Done()</code> 将导致 <code>counter -=1</code>，请求计数器counter为0 时通过信号量调用<code>runtime_Semrelease</code>唤醒waiter线程</li>
<li><code>WaitGroup.Wait()</code>：会将 <code>waiter++</code>，同时通过信号量调用 <code>runtime_Semacquire(semap)</code>阻塞当前 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>复制代码</p>
<h1 id="4-Go-Cond实现原理？"><a href="#4-Go-Cond实现原理？" class="headerlink" title="4. Go Cond实现原理？"></a>4. Go Cond实现原理？</h1><hr>
<p><em>caspar</em> <em>1030</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go Cond实现原理？</summary><iframe src="https://player.bilibili.com/player.html?aid=940065407&amp;bvid=BV1uW4y167ow&amp;cid=747735289&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-9"><a href="#概念-9" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p><code>Go</code>标准库提供了<code>Cond</code>原语，可以让 Goroutine 在满足特定条件时被阻塞和唤醒</p>
<h2 id="底层数据结构-2"><a href="#底层数据结构-2" class="headerlink" title="#底层数据结构"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a>底层数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait   <span class="type">uint32</span></span><br><span class="line">    notify <span class="type">uint32</span></span><br><span class="line">    lock   <span class="type">uintptr</span> <span class="comment">// key field of the mutex</span></span><br><span class="line">    head   unsafe.Pointer</span><br><span class="line">    tail   unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>复制代码</p>
<p>主要有<code>4</code>个字段：</p>
<ul>
<li><code>nocopy</code> ： golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错，但需要注意的是，noCopy 不会影响程序正常的编译和运行</li>
<li><code>checker</code>：用于禁止运行期间发生拷贝，双重检查(<code>Double check</code>)</li>
<li><code>L</code>：可以传入一个读写锁或互斥锁，当修改条件或者调用<code>Wait</code>方法时需要加锁</li>
<li><code>notify</code>：通知链表，调用<code>Wait()</code>方法的<code>Goroutine</code>会放到这个链表中，从这里获取需被唤醒的Goroutine列表</li>
</ul>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="#使用方法"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-4.html#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">#</a>使用方法</h2><p>在Cond里主要有3个方法：</p>
<ul>
<li><code>sync.NewCond(l Locker)</code>: 新建一个 sync.Cond 变量，注意该函数需要一个 Locker 作为必填参数，这是因为在 <code>cond.Wait()</code> 中底层会涉及到 Locker 的锁操作</li>
<li><code>Cond.Wait()</code>: 阻塞等待被唤醒，调用Wait函数前<strong>需要先加锁</strong>；并且由于Wait函数被唤醒时存在虚假唤醒等情况，导致唤醒后发现，条件依旧不成立，因此需要使用 for 语句来循环地进行等待，直到条件成立为止</li>
<li><code>Cond.Signal()</code>: 只唤醒一个最先 Wait 的 goroutine，可以不用加锁</li>
<li><code>Cond.Broadcast()</code>: 唤醒所有Wait的goroutine，可以不用加锁</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> listen(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> broadcast(c)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    atomic.StoreInt64(&amp;status, <span class="number">1</span>) </span><br><span class="line">    c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">        c.Wait() </span><br><span class="line">        <span class="comment">// Wait 内部会先调用 c.L.Unlock()，来先释放锁，如果调用方不先加锁的话，会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35</p>
<p>复制代码</p>
<h1 id="5-Go-有哪些方式安全读写共享变量？"><a href="#5-Go-有哪些方式安全读写共享变量？" class="headerlink" title="5. Go 有哪些方式安全读写共享变量？"></a>5. Go 有哪些方式安全读写共享变量？</h1><hr>
<p><em>caspar</em> <em>967</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】 Go 有哪些方式安全读写共享变量？</summary><iframe src="https://player.bilibili.com/player.html?aid=470081677&amp;bvid=BV1HT411G714&amp;cid=747745495&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<table>
<thead>
<tr>
<th>方法</th>
<th>并发原语</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>不要修改变量</td>
<td>sync.Once</td>
<td>不要去写变量，变量只初始化一次</td>
</tr>
<tr>
<td>只允许一个goroutine访问变量</td>
<td>Channel</td>
<td>不要通过共享变量来通信，通过通信(channel)来共享变量</td>
</tr>
<tr>
<td>允许多个goroutine访问变量，但是同一时间只允许一个goroutine访问</td>
<td>sync.Mutex、sync.RWMutex、原子操作</td>
<td>实现锁机制，同时只有一个线程能拿到锁</td>
</tr>
</tbody></table>
<h1 id="6-Go-如何排查数据竞争问题？"><a href="#6-Go-如何排查数据竞争问题？" class="headerlink" title="6. Go 如何排查数据竞争问题？"></a>6. Go 如何排查数据竞争问题？</h1><hr>
<p><em>caspar</em> <em>975</em></p>
<details class="custom-block details" style="display: block; border-radius: 2px; margin: 1em 0px; padding: 1rem; background-color: var(--code-color);"><summary style="outline: none; cursor: pointer;">【点击观看视频】Go 如何排查数据竞争问题？</summary><iframe src="https://player.bilibili.com/player.html?aid=597686006&amp;bvid=BV1EB4y1D7WW&amp;cid=752341585&amp;page=1&amp;high_quality=1&amp;autoplay=0" width="100%" height="610px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="allowfullscreen"></iframe></details>

<h2 id="概念-10"><a href="#概念-10" class="headerlink" title="#概念"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-6.html#%E6%A6%82%E5%BF%B5">#</a>概念</h2><p>只要有两个以上的goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争；全是读的情况下是不存在数据竞争的。</p>
<h2 id="排查方式"><a href="#排查方式" class="headerlink" title="#排查方式"></a><a target="_blank" rel="noopener" href="https://vip.golangroadmap.com/class/gointerview/9-6.html#%E6%8E%92%E6%9F%A5%E6%96%B9%E5%BC%8F">#</a>排查方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i++ <span class="comment">// write i</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(i) <span class="comment">// read i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>复制代码</p>
<p><code>go命令行</code>有个参数<code>race</code>可以帮助检测代码中的数据竞争</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run -race main.go</span><br><span class="line"></span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c0000ba008 by goroutine 7:</span><br><span class="line"><span class="built_in">exit</span> status 66</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>复制代码</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">编程基础随想录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-29 01:18:25" itemprop="dateCreated datePublished" datetime="2024-08-29T01:18:25+08:00">2024-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-07 21:23:37" itemprop="dateModified" datetime="2024-09-07T21:23:37+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-如何理解同步和异步？"><a href="#1-如何理解同步和异步？" class="headerlink" title="1. 如何理解同步和异步？"></a>1. 如何理解同步和异步？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1MC411a7rY/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/image-20240829012145437.png" alt="image-20240829012145437"></p>
<p><img src="/2024/08/29/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9A%8F%E6%83%B3%E5%BD%95/image-20240829012334628.png" alt="image-20240829012334628"></p>
<p><strong>追问：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么情况下用同步？</span><br><span class="line">什么情况下用异步？</span><br><span class="line">两者有什么差异？</span><br><span class="line">怎么在用户态层面实现异步？内核态又是怎么实现异步的？</span><br><span class="line">rpc接口是同步的还是异步的，为什么？该如何实现？</span><br></pre></td></tr></table></figure>



<h2 id="2-如何理解阻塞和非阻塞？"><a href="#2-如何理解阻塞和非阻塞？" class="headerlink" title="2. 如何理解阻塞和非阻塞？"></a>2. 如何理解阻塞和非阻塞？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1MK421x7Sa/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="3-什么是回调函数？"><a href="#3-什么是回调函数？" class="headerlink" title="3. 什么是回调函数？"></a>3. 什么是回调函数？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1cW421N7P2/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="4-什么是IO多路复用？"><a href="#4-什么是IO多路复用？" class="headerlink" title="4. 什么是IO多路复用？"></a>4. 什么是IO多路复用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1RJ4m1b7cy/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="5-如何理解并行和并发？"><a href="#5-如何理解并行和并发？" class="headerlink" title="5. 如何理解并行和并发？"></a>5. 如何理解并行和并发？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1fA4m1c7YT/?spm_id_from=333.788&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>



<h2 id="6-什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？"><a href="#6-什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？" class="headerlink" title="6. 什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？"></a>6. 什么是哈希表？如何解决哈希冲突？golang中的哈希表结构是什么？</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-28 02:25:22" itemprop="dateCreated datePublished" datetime="2024-08-28T02:25:22+08:00">2024-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-30 22:35:25" itemprop="dateModified" datetime="2024-08-30T22:35:25+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">linux系统编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-如何理解Linux中的一切皆文件？"><a href="#1-如何理解Linux中的一切皆文件？" class="headerlink" title="1. 如何理解Linux中的一切皆文件？"></a>1. 如何理解Linux中的一切皆文件？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1db411E72q/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240829004845341.png" alt="image-20240829004845341"></p>
<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240829005053280.png" alt="image-20240829005053280"></p>
<h2 id="10P-grep和xargs"><a href="#10P-grep和xargs" class="headerlink" title="10P-grep和xargs"></a>10P-grep和xargs</h2><p>grep命令：找文件内容</p>
<p>grep -r ‘copy’ .&#x2F; -n</p>
<p>-n参数：:显示行号</p>
<p>ps监控后台进程工作情况，默认只显示当前可以和用户交互的进程</p>
<p>ps aux | grep ‘cupsd’  – 检索进程结果集。</p>
<p>下图显示和内核相关进程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12581134/1630508074765-13709755-d1e9-4819-a105-21ebff745367.png" alt="img"></p>
<p>使用grep搜索进程，有一条结果是搜索进程本身</p>
<p>find … | xargs ls -l 对find操作的结果集进行操作</p>
<p>等价于</p>
<p>find … -exec ls -l {} \；</p>
<p>两者差别在于当结果集合很大的时候，xargs会对结果进行分段处理，所以性能好些</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12581134/1631080505786-1e6cd36f-111a-4634-b4ea-fd8ff03839b3.png" alt="img"></p>
<p>-xargs：将find搜索的结果集执行某一指定命令。  当结果集数量过大时，可以分片映射。</p>
<p>find &#x2F;usr&#x2F; -name ‘<em>tmp</em>‘ | xargs ls -ld </p>
<p>创建名字带空格的文件方法：</p>
<ul>
<li>第一个方法，文件名加引号</li>
<li>第二个方法，转义</li>
</ul>
<p>但xargs也有缺陷，xargs默认用【空格】来分割结果集，当文件名有空格的时候，会因为文件名被切割失效</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12581134/1630508074980-2ee210b5-f1d6-4200-a6e6-737fa10d96e8.png" alt="img"></p>
<p>xargs缺陷演示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12581134/1630508076210-69645e68-93fa-4d0f-8f2e-9d8d40a73e9d.png" alt="img"></p>
<p>解决xargs的缺陷，指定切分符号位null</p>
<p>-print0：</p>
<p>​	<code>find /usr/ -name &#39;*tmp*&#39; -print0 | xargs  -print0 ls -l</code></p>
<p>   第一个print0指定结果集分隔为null，第二个print0指定xargs分隔为null</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12581134/1630508076505-9dfd7102-ed2c-4b5c-8409-b04a323f4da0.png" alt="img"></p>
<p><img src="/2024/08/28/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/image-20240830223525803.png" alt="image-20240830223525803"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法-1排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-26 17:02:18" itemprop="dateCreated datePublished" datetime="2024-08-26T17:02:18+08:00">2024-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-07 21:50:50" itemprop="dateModified" datetime="2024-09-07T21:50:50+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-选择排序与冒泡排序"><a href="#1-选择排序与冒泡排序" class="headerlink" title="1. 选择排序与冒泡排序"></a>1. 选择排序与冒泡排序</h1><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240826170655954.png" alt="image-20240826170655954"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240826170729362.png" alt="image-20240826170729362"></p>
<h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h1><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<p>最好情况：O(N)，最坏情况：O(N^2)</p>
<p>算法流程按照最差情况来估计时间复杂度</p>
<p>类似于打扑克牌抓牌时的插入</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240829164912630.png" alt="image-20240829164912630"></p>
<h1 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/submissions/">https://leetcode.cn/problems/sort-an-array/submissions/</a></p>
<p><strong>使用「快速排序」解决的经典问题（非常重要）：</strong></p>
<ul>
<li>TopK 问题：「力扣」第 215 题：数组中的第 K 个最大元素</li>
</ul>
<p>​		<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">https://leetcode.cn/problems/kth-largest-element-in-an-array/description/</a></p>
<ul>
<li>荷兰国旗问题：「力扣」第 75 题：颜色分类</li>
</ul>
<p>​		<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/description/">https://leetcode.cn/problems/sort-colors/description/</a></p>
<h1 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h1><p>堆排序的细节和复杂度分析</p>
<p>时间复杂度O(N*logN)，额外空间复杂度O(1) </p>
<p>堆结构非常重要</p>
<p>1，堆结构的heapInsert与heapify </p>
<p>2，堆结构的增大和减少 </p>
<p>3，如果只是建立堆的过程，时间复杂度为O(N) </p>
<p>4，优先级队列结构，就是堆结构</p>
<p>使用堆排序解决的经典问题：</p>
<ul>
<li><p>TopK 问题：「力扣」第 215 题：数组中的第 K 个最大元素</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/submissions/560152694/">https://leetcode.cn/problems/sort-an-array/submissions/560152694/</a></p>
</li>
<li><p>排序几乎有序的数组</p>
</li>
</ul>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240831184709207.png" alt="image-20240831184709207"></p>
<p>假设要求升序排列，由题意，数组最小的数一定在下标。0–k 的范围内，所以将 0–k 范围内的数建立成小根堆，则下标0的数即为数组最小值，然后 k 窗口依次往右移动</p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240831185648360.png" alt="image-20240831185648360"></p>
<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902160735736.png" alt="image-20240902160735736"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/submissions/560674602/">https://leetcode.cn/problems/sort-an-array/submissions/560674602/</a>. – 用归并排序解决数组排序问题题解</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a></li>
</ul>
<p>​		<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/submissions/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/submissions/</a></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/submissions/">https://leetcode.cn/problems/count-of-smaller-numbers-after-self/submissions/</a></p>
</li>
</ul>
<h1 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6. 哈希表"></a>6. 哈希表</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902191649354.png" alt="image-20240902191649354"></p>
<h1 id="7-有序表"><a href="#7-有序表" class="headerlink" title="7. 有序表"></a>7. 有序表</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240902191719761.png" alt="image-20240902191719761"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240830152141731.png" alt="image-20240830152141731"></p>
<p><img src="/2024/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240830152152732.png" alt="image-20240830152152732"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/24/golang%E5%88%87%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/24/golang%E5%88%87%E7%89%87/" class="post-title-link" itemprop="url">golang切片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-24 16:38:21" itemprop="dateCreated datePublished" datetime="2024-08-24T16:38:21+08:00">2024-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-29 02:02:36" itemprop="dateModified" datetime="2024-08-29T02:02:36+08:00">2024-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">golang基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-make切片时，是否指定size有什么区别？"><a href="#1-make切片时，是否指定size有什么区别？" class="headerlink" title="1. make切片时，是否指定size有什么区别？"></a>1. make切片时，是否指定size有什么区别？</h1><p><strong>切片是否指定size有什么区别呢？</strong><br><strong>例如：</strong><br><strong>slice :&#x3D; make([]int)</strong><br><strong>slice :&#x3D; make([]int, 5)</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建切片时，是否指定 <code>size</code>（即长度）会影响切片的初始状态。下面解释两种情况下的区别：</p>
<h3 id="1-不指定长度"><a href="#1-不指定长度" class="headerlink" title="1. 不指定长度"></a>1. 不指定长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：如果你这样创建切片，由于没有指定长度和容量，Go 将会报错，因为 <code>make([]int)</code> 语法是无效的。</li>
<li><strong>原因</strong>：<code>make</code> 函数在用于创建切片时至少需要一个参数（长度），你必须指定切片的初始长度。</li>
</ul>
<p>因此，你需要至少指定长度，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 0 的切片，其容量也为 0。这是一个空的切片，但仍然可以追加元素。</p>
<h3 id="2-指定长度"><a href="#2-指定长度" class="headerlink" title="2. 指定长度"></a>2. 指定长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：这段代码创建了一个长度为 5 的切片，其容量也为 5。切片中的 5 个元素会被初始化为类型 <code>int</code> 的零值（即 0）。切片的底层数组会包含 5 个元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(slice) <span class="comment">// 输出: [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 输出: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><p><strong>未指定长度（非法操作）</strong>：如果你不指定长度并直接调用 <code>make([]int)</code>，Go 编译器会报错，因为这种用法是不合法的。你至少需要指定长度。</p>
</li>
<li><p><strong>指定长度</strong>：当你指定长度时，切片会被创建并初始化为指定长度的切片。它的容量和长度都等于你指定的长度。如果你在创建切片时指定的长度为 5，那么切片将包含 5 个元素，所有元素的初始值为 0。</p>
</li>
<li><p><strong>创建空切片</strong>：如果你需要一个空切片（长度为 0），你可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这个切片的长度和容量都为 0，可以使用 <code>append</code> 函数向其中添加元素，容量会根据需要自动扩展。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在创建切片时，必须至少指定长度。指定长度的切片会分配一个具有该长度的底层数组，未指定长度（即长度为 0）时，你得到的是一个空切片。</p>
<h1 id="2-make切片时，是否指定容量有什么区别？"><a href="#2-make切片时，是否指定容量有什么区别？" class="headerlink" title="2. make切片时，是否指定容量有什么区别？"></a>2. make切片时，是否指定容量有什么区别？</h1><ul>
<li><p><strong>未指定容量</strong>：当你使用 <code>make([]T, len)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 的切片，并且容量（capacity）等于长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度和容量均为 5 的切片。切片的所有元素都会被初始化为类型 <code>T</code> 的零值（比如对于 <code>int</code> 类型，零值是 0）。</p>
</li>
<li><p><strong>指定容量</strong>：当你使用 <code>make([]T, len, cap)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 且容量为 <code>cap</code> 的切片。容量可以比长度大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 5、容量为 10 的切片。这意味着虽然切片的当前长度是 5，但它最多可以扩展到 10 个元素而无需重新分配内存。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会将容量设置为与长度相同。</li>
<li>如果指定了容量，Go 会为切片预留更多的空间。这在切片需要频繁追加元素的场景下非常有用，因为预先指定较大的容量可以减少在追加元素时的内存重新分配操作，提高性能。</li>
</ul>
<h2 id="3-slice避坑指南"><a href="#3-slice避坑指南" class="headerlink" title="3. slice避坑指南"></a>3. slice避坑指南</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1EL4y1P7hh?p=5&amp;vd_source=51d632fc88dc2672d78996251d66eda0</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/24/golang%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/24/golang%E9%9A%8F%E6%83%B3%E5%BD%95/" class="post-title-link" itemprop="url">golang随想录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-24 16:32:07 / 修改时间：16:47:32" itemprop="dateCreated datePublished" datetime="2024-08-24T16:32:07+08:00">2024-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">golang基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-关于make是否指定容量"><a href="#1-关于make是否指定容量" class="headerlink" title="1. 关于make是否指定容量"></a>1. 关于make是否指定容量</h1><p><strong>在 Go 语言中，make 函数用于创建通道（channel）、切片（slice）和映射（map）。 根据是否指定size，channel分为非缓冲通道 和 缓冲通道； 那么对于切片（slice）和映射（map）来说，make时是否指定size，有什么区别呢？</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建通道（channel）、切片（slice）和映射（map）。对于切片和映射，<code>make</code> 函数的行为在是否指定大小（size）时有所不同。下面分别讨论切片和映射在使用 <code>make</code> 函数时是否指定大小的区别。</p>
<h3 id="切片（Slice）"><a href="#切片（Slice）" class="headerlink" title="切片（Slice）"></a>切片（Slice）</h3><ul>
<li><p><strong>未指定大小</strong>：当你使用 <code>make([]T, len)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 的切片，并且容量（capacity）等于长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个长度和容量均为 5 的切片。切片的所有元素都会被初始化为类型 <code>T</code> 的零值（比如对于 <code>int</code> 类型，零值是 0）。</p>
</li>
<li><p><strong>指定容量</strong>：当你使用 <code>make([]T, len, cap)</code> 创建切片时，<code>make</code> 会创建一个长度为 <code>len</code> 且容量为 <code>cap</code> 的切片。容量可以比长度大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个长度为 5、容量为 10 的切片。这意味着虽然切片的当前长度是 5，但它最多可以扩展到 10 个元素而无需重新分配内存。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会将容量设置为与长度相同。</li>
<li>如果指定了容量，Go 会为切片预留更多的空间。这在切片需要频繁追加元素的场景下非常有用，因为预先指定较大的容量可以减少在追加元素时的内存重新分配操作，提高性能。</li>
</ul>
<h3 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h3><ul>
<li><p><strong>未指定大小</strong>：当你使用 <code>make(map[T1]T2)</code> 创建映射时，Go 会创建一个初始大小适合较小规模使用的映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个空的映射。虽然初始容量是非零的，但如果往映射中插入了超出初始容量的元素，映射会自动扩展。</p>
</li>
<li><p><strong>指定大小</strong>：当你使用 <code>make(map[T1]T2, cap)</code> 创建映射时，<code>cap</code> 表示预估的元素数量。Go 会为映射预分配足够的空间来存储 <code>cap</code> 个元素，以减少在实际使用过程中发生的扩展操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个初始容量为 10 的映射。这意味着 Go 会为至少 10 个键值对分配内存，减少当实际插入元素数量接近或超过 10 时的内存重新分配次数。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>如果不指定容量，Go 会为映射分配一个默认的小容量，并在需要时自动扩展。</li>
<li>如果指定了容量，Go 会为映射预分配足够的内存以存储指定数量的元素，从而提高性能，尤其是在已知需要存储大量元素的场景下。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>切片</strong>：指定容量可以让切片在追加元素时减少内存重新分配，从而提高性能。未指定容量时，容量等于长度。</li>
<li><strong>映射</strong>：指定容量可以减少映射在插入大量元素时的扩展次数，从而提高性能。未指定容量时，映射的容量是初始的小值，并会根据需要自动扩展。</li>
</ul>
<h1 id="2-切片是否指定size有什么区别？"><a href="#2-切片是否指定size有什么区别？" class="headerlink" title="2. 切片是否指定size有什么区别？"></a>2. 切片是否指定size有什么区别？</h1><p><strong>切片是否指定size有什么区别呢？</strong><br><strong>例如：</strong><br><strong>slice :&#x3D; make([]int)</strong><br><strong>slice :&#x3D; make([]int, 5)</strong></p>
<p>在 Go 语言中，<code>make</code> 函数用于创建切片时，是否指定 <code>size</code>（即长度）会影响切片的初始状态。下面解释两种情况下的区别：</p>
<h3 id="1-不指定长度"><a href="#1-不指定长度" class="headerlink" title="1. 不指定长度"></a>1. 不指定长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：如果你这样创建切片，由于没有指定长度和容量，Go 将会报错，因为 <code>make([]int)</code> 语法是无效的。</li>
<li><strong>原因</strong>：<code>make</code> 函数在用于创建切片时至少需要一个参数（长度），你必须指定切片的初始长度。</li>
</ul>
<p>因此，你需要至少指定长度，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个长度为 0 的切片，其容量也为 0。这是一个空的切片，但仍然可以追加元素。</p>
<h3 id="2-指定长度"><a href="#2-指定长度" class="headerlink" title="2. 指定长度"></a>2. 指定长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>：这段代码创建了一个长度为 5 的切片，其容量也为 5。切片中的 5 个元素会被初始化为类型 <code>int</code> 的零值（即 0）。切片的底层数组会包含 5 个元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(slice) <span class="comment">// 输出: [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 输出: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><p><strong>未指定长度（非法操作）</strong>：如果你不指定长度并直接调用 <code>make([]int)</code>，Go 编译器会报错，因为这种用法是不合法的。你至少需要指定长度。</p>
</li>
<li><p><strong>指定长度</strong>：当你指定长度时，切片会被创建并初始化为指定长度的切片。它的容量和长度都等于你指定的长度。如果你在创建切片时指定的长度为 5，那么切片将包含 5 个元素，所有元素的初始值为 0。</p>
</li>
<li><p><strong>创建空切片</strong>：如果你需要一个空切片（长度为 0），你可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这个切片的长度和容量都为 0，可以使用 <code>append</code> 函数向其中添加元素，容量会根据需要自动扩展。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在创建切片时，必须至少指定长度。指定长度的切片会分配一个具有该长度的底层数组，未指定长度（即长度为 0）时，你得到的是一个空切片。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">golang并发编程--基础篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-24 16:03:53" itemprop="dateCreated datePublished" datetime="2024-08-24T16:03:53+08:00">2024-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-07 07:22:35" itemprop="dateModified" datetime="2024-09-07T07:22:35+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">golang基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824160554038.png" alt="image-20240824160554038"></p>
<p>有缓冲channel和无缓冲channel</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824161109182.png" alt="image-20240824161109182"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825222826148.png" alt="image-20240825222826148"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223113423.png" alt="image-20240825223113423"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223516012.png" alt="image-20240825223516012"></p>
<p>1、并行与并发</p>
<ol>
<li>并行<br>要求CPU具备多核计算的能力<br>在同一时刻需要多个线程在多个CPU上同时执行指令，无论宏观上还是微观上都会看到多个线程在同时运行</li>
<li>并发<br>并不要求CPU具备多核计算的能力<br>单核CPU都是独立的，CPU与CPU之间不需要交互</li>
</ol>
<p>2、CSP并发模型</p>
<ol>
<li>Communicating Sequential Process: 通信顺序进程模型</li>
<li>Go语言中有两种并发模型:<br>1、线程与锁的并发模型<br>2、CSP通信顺序进程模型</li>
</ol>
<p>3、根据资源访问权限的不同，内存分为:</p>
<ol>
<li>内核空间<br>可以直接调用计算机底层资源，比如: I&#x2F;O资源</li>
<li>用户空间<br>没有权限调用底层资源，需要通过系统调用等方式切换为内核态从而调用底层资源</li>
</ol>
<p>4、线程是操作系统能调度的最小单位</p>
<ol>
<li>用户线程<ol>
<li>用户空间的代码创建、管理、销毁</li>
<li>同一进程下创建的多个线程对CPU的争夺是进程为单位的，</li>
<li>这只能够对其用户进程被分配的CPU时间，无论很好的利用多线程计算</li>
<li>我们一般情况下说的线程其实是指用户线程</li>
<li>用户线程无法被系统感知，用户线程所属的进程或者内核线程才能被系统直接调用</li>
</ol>
</li>
<li>内核线程<ol>
<li>由操作系统创建、管理、调度</li>
<li>能够直接获取系统底层资源</li>
<li>线程切换时的CPU需要切换到内核态</li>
<li>能够很好的利用多核CPU进行计算的优势</li>
<li>开发人员可以通过系统调用的方式使用内核线程</li>
</ol>
</li>
</ol>
<p>5、线程模型</p>
<ol>
<li><p>用户级线程模型  </p>
<ol>
<li>一个进程对应一个内核线程  </li>
<li>进程内的多线程由用户代码完成，这使得线程的创建、管理，同时等工作量得异常显著级和高效  </li>
<li>进程内的多线程无法很好利用CPU多核运算的优势，只能通过分时复用的方式轮换执行  </li>
<li>如果进程内有线程阻塞，很可能会导致整个进程范围内的阻塞</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825223737636.png" alt="image-20240825223737636"></p>
</li>
<li><p>内核级线程模型</p>
<ol>
<li><p>进程中的每个线程都会对应一个内核线程  </p>
</li>
<li><p>进程内部创建一个线程程序会调用操作系统的线程库，在内核创建一个新的内核线程与之对应  </p>
</li>
<li><p>线程的管理和调度由内核系统负责  </p>
<p>这会导致每个线程切换上下文的代价较大，产生不小的资源消耗  </p>
<p>同时创建线程的数量需要限制在系统可创建的线程的数量  </p>
</li>
<li><p>优点是多线程可以充分利用CPU的多核并行计算能力  </p>
</li>
<li><p>进程内某个线程挂起并不会影响到其他线程的工作执行</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825232418190.png" alt="image-20240825232418190"></p>
</li>
</ol>
</li>
<li><p>两级线程模型</p>
<ol>
<li>相当于用户级线程和内核级线程的结合  </li>
<li>一个进程将会对应多个内核级线程，由进程内的调度器来决定进程内线程与内核线程的对应  </li>
<li>进程会先申请一定数量的内核级线程，然后将自己创建的线程与之对应  </li>
<li>线程的调度与管理由进程的调度器负责，而内核级线程的调度由操作系统负责  </li>
<li>这种模型能够有效降低线程创建和管理的资源消耗，也能够很好的提供程序并行计算的能力</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825232639991.png" alt="image-20240825232639991"></p>
</li>
<li><p>MPG模型</p>
<ol>
<li><p>go语言的mpg模型是一种特殊的两级线程模型，它将CPU、内核线程、用户线程之间的管理，描述为M、P、G三者的关系  </p>
</li>
<li><p>M：machine，一个对应一个内核级线程，相当于内核级线程在go中的的映射  </p>
</li>
<li><p>P：processor，一个P代表执行go代码所需要的上下文环境  </p>
</li>
<li><p>G：goroutine，是一个代码片段，相当于用户级线程  </p>
</li>
<li><p>go func aaa() { }，这里的aaa相当于一个用户级线程</p>
</li>
</ol>
</li>
<li><p>MPG  </p>
<ol>
<li>每个M都与一个内核级线程绑定，在运行时，一个M同时只能绑定一个P  </li>
<li>P和G的关系可以是一对多的  </li>
<li>在程序运行过程中，M和内核级线程的绑定关系不会发生变化，在M的生命周期内只会与一个内核级线程绑定</li>
<li>M和P P和G之间的关系都是动态可变的  </li>
<li>在实际的运行过程中，M和P的组合才能为G提供有效的运行环境  </li>
<li>多个可执行的G将会顺序排成一个队列挂在某个P上面，等待调度和执行</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233553727.png" alt="image-20240825233553727"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233652269.png" alt="image-20240825233652269"></p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240825233710063.png" alt="image-20240825233710063"></p>
</li>
<li><p>并发编程实践</p>
<ol>
<li>goroutine</li>
<li>channel</li>
<li>select</li>
<li>sync包</li>
<li>atomic包</li>
<li>context包</li>
</ol>
</li>
<li><p>goroutine简介<br>协程goroutine在go语言中属于是轻量级的线程<br>在运行时由runtime管理<br>每个go程序至少启动一个goroutine，main函数也在goroutine上运行  </p>
</li>
<li><p>启动goroutine  </p>
<ol>
<li>关键字 go  </li>
<li>模式  <ol>
<li>go 变量  </li>
<li>go 匿名函数</li>
<li>go 函数</li>
</ol>
</li>
</ol>
</li>
<li><p>需要注意的地方  </p>
<ol>
<li>main的goroutine结束后就意味着整个程序的运行已经结束了，换言之，go的执行是非阻塞的，不会等待  </li>
<li>goroutine之间的代码顺序并不能代表其真实的执行顺序  </li>
<li>go后面的函数的返回值会被忽略，也就是说协程不能有返回值，但是可以通过channel实现有返回值的效果</li>
<li>没有父子goroutine的概念，所有的goroutine是平等的被调度和执行的  </li>
<li>go程序在执行时会单独为main创建一个goroutine，遇到其他go关键字再去创建其他的goroutine  </li>
<li>go没有暴露goroutine id给用户，所以不能在一个goroutine里面显式地操作另一个goroutine</li>
</ol>
</li>
<li><p>channel<br>go语言当中使用channel作为goroutine之间同步和通信的手段</p>
<p>channel属于引用类型</p>
<p>每个channel只能传递固定类型的数据</p>
<p>声明格式：var channelName chan T  </p>
</li>
<li><p>channel的发送与接收</p>
<p>channel作为一个队列，会保证数据收发顺序总是遵循先入先出的原则进行<br>也会保证同一时刻只有一个goroutine访问channel来发送和获取数据<br>channel发送数据格式：channel &lt;- value<br>接收channel数据格式：value :&#x3D; &lt;- channel    value, ok :&#x3D; &lt;- channel<br>创建channel格式：ch :&#x3D; make(chan T, sizeOfChannel)  ch :&#x3D; make(chan string, 10)</p>
</li>
</ol>
<p>注意：</p>
<p>在业务代码中应使用 value, ok :&#x3D; &lt;- channel，而避免使用 value :&#x3D; &lt;- channel</p>
<p>在下面的情形中，将导致刷屏现象！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		val := &lt;-ch</span><br><span class="line">		fmt.Println(<span class="string">&quot;value is&quot;</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		ch &lt;- time.Now().Format(GOTIME)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例如下：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		val, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;value is&quot;</span>, val, <span class="string">&quot;, ok is&quot;</span>, ok)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;value is&quot;</span>, val, <span class="string">&quot;, ok is&quot;</span>, ok)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i am test1, new close chan.&quot;</span>)</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		ch &lt;- time.Now().Format(GOTIME)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>by the way， channel一般是写入方进行关闭，而不是读取方进行关闭</strong></p>
<ol>
<li><p>案例<br>无缓冲区channel – 阻塞</p>
<p>ch :&#x3D; make(chan string)</p>
<p>有缓冲区channel – 不阻塞</p>
<p>ch :&#x3D; make(chan string, 5)</p>
</li>
<li><p>select  </p>
<ol>
<li>需要接收多个goroutine中的消息时可以使用select  </li>
<li>当多个case同时到达，select将会执行一个随机算法随机选择一个case  </li>
<li>select与switch的区别：  <ol>
<li>select的每个case必须是一个操作  </li>
<li>select后边不带判断条件  </li>
<li>select中如果多个case同时到达，那么select将会执行一个随机算法，随机选择一个case执行</li>
</ol>
</li>
</ol>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240826012532525.png" alt="image-20240826012532525"></p>
</li>
</ol>
<h1 id="1-sync包"><a href="#1-sync包" class="headerlink" title="1. sync包"></a>1. sync包</h1><h2 id="1-1-Mutex-互斥锁"><a href="#1-1-Mutex-互斥锁" class="headerlink" title="1.1 Mutex 互斥锁"></a>1.1 Mutex 互斥锁</h2><p>确保在同一时间段内有且仅有一个goroutine持有锁<br>这就保证了在某一时间段内有且仅有一个goroutine访问共享资源，其他申请锁的goroutine将会被阻塞直到锁被释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;start func1 at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		lock.Lock()</span><br><span class="line">		fmt.Println(<span class="string">&quot;func1 get lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;func1 release lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;start func2 at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		lock.Lock()</span><br><span class="line">		fmt.Println(<span class="string">&quot;func2 get lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;func2 release lcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-2-RWMutex-读写锁"><a href="#1-2-RWMutex-读写锁" class="headerlink" title="1.2 RWMutex 读写锁"></a>1.2 RWMutex 读写锁</h2><ol>
<li>在同一时间段内只能有一个goroutine获取到写锁  </li>
<li>在同一时间段内可以有多个goroutine获取到读锁  </li>
<li>在同一时间段只能存在写锁或读锁（读锁和写锁互斥）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start read lock at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> lock.RUnlock()</span><br><span class="line">			lock.RLock()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start write lock at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">			lock.Lock()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get wlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release wlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240826015036876.png" alt="image-20240826015036876"></p>
<h2 id="1-3-WaitGroup-并发等待组"><a href="#1-3-WaitGroup-并发等待组" class="headerlink" title="1.3 WaitGroup 并发等待组"></a>1.3 WaitGroup 并发等待组</h2><p>使用WaitGroup的goroutine会被预设好数量的goroutine都提交执行结束后，才会继续往下执行代码</p>
<p>在goroutine调用WaitGroup之前需要保证WaitGroup中等待数量大于1</p>
<p>保证WaitGroup.Done()执行的次数与WaitGroup.Add()相同，WaitGroup.Done()过少会导致等待goroutine死锁，WaitGroup.Done()过多导致panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	GOTIME := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 正确的做法是把 wg.Add(1)，写到for循环中去，这样可以尽可能地保证 Add和Done的数量是一致的</span></span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;get rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">&quot;func&quot;</span>, i, <span class="string">&quot;release rlcok at&quot;</span>, time.Now().Format(GOTIME))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;over.......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-4-Map-并发安全字典"><a href="#1-4-Map-并发安全字典" class="headerlink" title="1.4 Map 并发安全字典"></a>1.4 Map 并发安全字典</h2><ul>
<li>go语言中原生的Map并不是并发安全的， 在多个goroutine同时往Map中添加数据时，可能会导致部分添加数据的丢失，甚至程序崩溃。</li>
<li>对键值的类型没有限制，在同一个map中可以存储多种不同的键值对</li>
</ul>
<ol>
<li><p>go语言中原生的Map并不是并发安全的，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//dict := make(map[int]int)</span></span><br><span class="line">	<span class="keyword">var</span> dict sync.Map</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;thread id is &quot;</span>, i)</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">//dict[i] = i</span></span><br><span class="line">			dict.Store(i, fmt.Sprintf(<span class="string">&quot;%daaa&quot;</span>, i))</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	value, ok := dict.Load(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824224252751.png" alt="image-20240824224252751"></p>
</li>
<li><p>sync包中的Map</p>
<p>Map对应的接口中的方法：</p>
<p><img src="/2024/08/24/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240824225149901.png" alt="image-20240824225149901"></p>
<p>常用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (m *Map) Load(key any) (value any, ok bool)</span><br><span class="line">根据k获取value，相当于get</span><br><span class="line"></span><br><span class="line">func (m *Map) Store(key, value any)</span><br><span class="line">存储，相当于set，对键值的类型没有限制，在同一个map中可以存储多种不同的键值对</span><br><span class="line"></span><br><span class="line">func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)</span><br><span class="line">如果key存在则返回对应的value，如果key不存在则设置key-value对</span><br><span class="line"></span><br><span class="line">func (m *Map) Range(f func(key, value any) bool)</span><br><span class="line">无序遍历map</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-5-Once-单例模式"><a href="#1-5-Once-单例模式" class="headerlink" title="1.5 Once 单例模式"></a>1.5 Once 单例模式</h2><h2 id="1-6-Cond-条件变量"><a href="#1-6-Cond-条件变量" class="headerlink" title="1.6 Cond 条件变量"></a>1.6 Cond 条件变量</h2><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/hpg-sync-cond.html">https://geektutu.com/post/hpg-sync-cond.html</a></p>
<h2 id="1-7-Pool-临时对象池"><a href="#1-7-Pool-临时对象池" class="headerlink" title="1.7 Pool 临时对象池"></a>1.7 Pool 临时对象池</h2><h1 id="2-atomic包"><a href="#2-atomic包" class="headerlink" title="2. atomic包"></a>2. atomic包</h1><ol>
<li><strong>atomic简介</strong></li>
</ol>
<p>当我们想要对某个变量并发安全的修改,除了使用官方提供的 mutex,还可以使用 sync&#x2F;atomic 包的原子操作,它能够<br>保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>Golang提供的原子操作都是非侵入式的,由标准库sync&#x2F;atmoic包提供,直接由底层CPU硬件支持。<br>也就是在硬件层次去实现的,性能较好,不需要像 mutex 那样记录很多状态。当然,mutex 不止是对变量的并发控制,更多的是<br>对代码块的并发控制,2者侧重点不一样。</p>
<ol start="2">
<li><strong>原子操作</strong></li>
</ol>
<ul>
<li><p>原子操作即是进行过程中不能被中断的操作,针对某个值的原子操作在被进行的过程中,CPU绝不会再去进行其他的针对<br>该值的操作。</p>
</li>
<li><p>具体的原子操作在不同的操作系统中实现是不同的。比如在Intel的CPU架构机器上,主要是使用总线锁的方式<br>实现的。大致的意思就是当一个CPU需要操作一个内存块的时候,向总线发送一个LOCK信号,所有CPU收到这个信号后就不对<br>这个内存块进行操作了。等待操作的CPU执行完操作后,发送UNLOCK信号,才结束。在AMD的CPU架构机器上就是使用MESI<br>一致性协议的方式来保证原子操作。所以我们在看atomic源码的时候,我们看到它针对不同的操作系统有不同汇编语言文件。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>Golang在sync包中已经提供了锁,为什么还需要使用atomic原子操作呢?</strong></p>
<ul>
<li><p>加锁的代价比较高,耗时多,需要上下文切换。</p>
</li>
<li><p>原子操作只针对基本数据类型,不支持结构体、自定义数据类型。</p>
</li>
<li><p>原子操作在用户态可以完成,性能比互斥锁要高。</p>
</li>
<li><p>针对特定需求原子操作步骤简单,无需加锁解锁步骤。</p>
</li>
</ul>
</li>
<li><p><strong>为什么 atomic 比mutex快?</strong></p>
<ul>
<li>原子操作很快,因为它们依赖于 CPU 指令而不是依赖外部锁。使用互斥锁时,每次获得锁时, goroutine 都会短暂暂停<br>或中断,这种阻塞占使用互斥锁所花费时间的很大一部分。原子操作可以在没有任何中断的情况下执行。</li>
<li>原子操作是能够保证执行期间是连续且不会被中断的,临界区只能保证访问共享数据是按顺序访问的,但并不能保证访问期间<br>不会被切换上下文。</li>
</ul>
</li>
<li><p>CAS<br>CAS是cpu硬件同步原语,是Compare And Swap的缩写</p>
<p>go中的Cas操作,是借用了CPU提供的原子性指令来实现。</p>
<p>CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查。本质还是不断的占用CPU资源换取加锁带来的开销(比如上下文切换开销)。</p>
<p>原子操作中的CAS,在sync&#x2F;atomic包中,这类原子操作由名称以CompareAndSwap为前缀的若干个函数提供</p>
<p><strong>优势:</strong><br>可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。</p>
<p><strong>劣势:</strong><br>在被操作值被频繁变更的情况下,CAS操作并不那么容易成功。因为需要对old值进行匹配,只有匹配成功了才进行下一步的修改。</p>
<p>当前atomic 包有以下几种原子操作: Add、CompareAndSwap、Load、Store、Swap</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/23/pprof%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/23/pprof%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">pprof使用指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-23 23:37:35" itemprop="dateCreated datePublished" datetime="2024-08-23T23:37:35+08:00">2024-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-24 00:00:09" itemprop="dateModified" datetime="2024-08-24T00:00:09+08:00">2024-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E8%B0%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">golang调试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/retrospro.png">
      <meta itemprop="name" content="Eric Hao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RETROSPRO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | RETROSPRO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Goland远程调试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-23 12:25:25" itemprop="dateCreated datePublished" datetime="2024-08-23T12:25:25+08:00">2024-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-24 00:01:59" itemprop="dateModified" datetime="2024-08-24T00:01:59+08:00">2024-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/golang%E8%B0%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">golang调试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Goland单步调试"><a href="#1-Goland单步调试" class="headerlink" title="1. Goland单步调试"></a>1. Goland单步调试</h1><h2 id="1-1-Goland侧配置"><a href="#1-1-Goland侧配置" class="headerlink" title="1.1 Goland侧配置"></a>1.1 Goland侧配置</h2><ol>
<li><p>配置代码同步</p>
<p><img src="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/image-20240823225107371.png" alt="image-20240823225107371"></p>
</li>
<li><p>添加Go Remote</p></li></ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/23/Goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Eric Hao</span>
  </div>



    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"retrospro","repo":"gitalk","client_id":"Ov23liOgrSkahiDbuNEk","client_secret":"af23b916424a5d6cb8b5e4e0f2f69eb66562e5eb","admin_user":"retrospro","distraction_free_mode":true,"proxy":"https://vercel.prohibitorum.top/github_access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
